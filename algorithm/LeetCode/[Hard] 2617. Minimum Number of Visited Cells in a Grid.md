2617. Minimum Number of Visited Cells in a Grid

You are given a **0-indexed** `m x n` integer matrix `grid`. Your initial position is at the **top-left** cell `(0, 0)`.

Starting from the cell `(i, j)`, you can move to one of the following cells:

* Cells `(i, k)` with `j < k <= grid[i][j] + j` (rightward movement), or
* Cells `(k, j)` with `i < k <= grid[i][j] + i` (downward movement).

Return the minimum number of cells you need to visit to reach the **bottom-right** cell `(m - 1, n - 1)`. If there is no valid path, return `-1`.

 

**Example 1:**

![2617_ex1.png](img/2617_ex1.png)
```
Input: grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]
Output: 4
Explanation: The image above shows one of the paths that visits exactly 4 cells.
```

**Example 2:**

![2617_ex2.png](img/2617_ex2.png)
```
Input: grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]
Output: 3
Explanation: The image above shows one of the paths that visits exactly 3 cells.
```

**Example 3:**

![2617_ex3.png](img/2617_ex3.png)
```
Input: grid = [[2,1,0],[1,0,0]]
Output: -1
Explanation: It can be proven that no path exists.
```

**Constraints:**

* `m == grid.length`
* `n == grid[i].length`
* `1 <= m, n <= 10^5`
* `1 <= m * n <= 10^5`
* `0 <= grid[i][j] < m * n`
* `grid[m - 1][n - 1] == 0`

# Submissions
---
**Solution 1: (BFS, Set)**

    [3,4,2,1],
    [4,2,3,1],
    [2,1,0,0],
    [2,4,0,0]

     x------> right
     | 
     |
     v->---x
  down

    

```
Runtime: 1239 ms, Beats 30.41%
Memory: 435.74 MB, Beats 39.17%
```
```c++
class Solution {
public:
    int minimumVisitedCells(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<set<int>> right(m), down(n);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                right[i].insert(j);
                down[j].insert(i);
            }
        }
        queue<array<int, 3>> q;
        q.push({0, 0, 1});
        while (!q.empty()) {
            auto [i, j, d] = q.front();
            q.pop();
            if (i == m - 1 && j == n - 1) {
                return d;
            }
            auto it = right[i].lower_bound(j + 1);
            while (it != right[i].end() && *it <= j + grid[i][j]) {
                q.push({i, *it, d + 1});
                down[*it].erase(i);
                right[i].erase(it++);
            }
            it = down[j].lower_bound(i + 1);
            while (it != down[j].end() && *it <= i + grid[i][j]) {
                q.push({*it, j, d + 1});
                right[*it].erase(j);
                down[j].erase(it++);
            }
        }
        return -1;
    }
};
```
