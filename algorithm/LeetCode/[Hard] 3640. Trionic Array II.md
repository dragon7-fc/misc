3640. Trionic Array II

You are given an integer array `nums` of length `n`.

A **trionic subarray** is a contiguous subarray `nums[l...r]` (with `0 <= l < r < n`) for which there exist indices `l < p < q < r` such that:

`nums[l...p]` is **strictly** increasing,
`nums[p...q]` is **strictly** decreasing,
`nums[q...r]` is **strictly** increasing.

Return the **maximum** sum of any trionic subarray in `nums`.

 

**Example 1:**
```
Input: nums = [0,-2,-1,-3,0,2,-1]

Output: -4

Explanation:

Pick l = 1, p = 2, q = 3, r = 5:

nums[l...p] = nums[1...2] = [-2, -1] is strictly increasing (-2 < -1).
nums[p...q] = nums[2...3] = [-1, -3] is strictly decreasing (-1 > -3)
nums[q...r] = nums[3...5] = [-3, 0, 2] is strictly increasing (-3 < 0 < 2).
Sum = (-2) + (-1) + (-3) + 0 + 2 = -4.
```

**Example 2:**
```
Input: nums = [1,4,2,7]

Output: 14

Explanation:

Pick l = 0, p = 1, q = 2, r = 3:

nums[l...p] = nums[0...1] = [1, 4] is strictly increasing (1 < 4).
nums[p...q] = nums[1...2] = [4, 2] is strictly decreasing (4 > 2).
nums[q...r] = nums[2...3] = [2, 7] is strictly increasing (2 < 7).
Sum = 1 + 4 + 2 + 7 = 14.
```

**Constraints:**

* `4 <= n = nums.length <= 10^5`
* `-109 <= nums[i] <= 10^9`
* It is guaranteed that at least one trionic subarray exists.

# Submissions
---
**Solution 1: (Greedy)**

__Intuition__
Just track l, p, q and r, and watch out for edge cases.

__Approach__
When we see a descent (middle interval), the previous last interval becomes the first one. However, there are a few considerations:

Make sure the updated first interval starts at l = q.
Exclude all negatives from the beginning, keeping at least two elements.
Simply increment l (no need for Kadane) as values are strictly increasing.

__Complexity__
Time: O(n)
Space: O(1)

```
Runtime: 5 ms, Beats 100.00%
Memory: 132.61 MB, Beats 100.00%
```
```c++
class Solution {
public:
    long long maxSumTrionic(vector<int>& nums) {
        long long n = nums.size(), res = LLONG_MIN, psum = nums[0];
        for (int l = 0, p = 0, q = 0, r = 1; r < nums.size(); ++r) {
            psum += nums[r];
            if (nums[r - 1] == nums[r]) {
                l = r;
                psum = nums[r];
            }
            else if (nums[r - 1] > nums[r]) {
                if (r > 1 && nums[r - 2] < nums[r - 1]) { // flip
                    p = r - 1;
                    while (l < q)
                        psum -= nums[l++];    
                    while (l + 1 < p && nums[l] < 0)
                        psum -= nums[l++];
                }
            }
            else {
                if (r > 1 && nums[r - 2] > nums[r - 1]) // flip
                    q = r - 1;
                if (l < p && p < q)
                    res = max(res, psum);
            }
        }
        return res;
    }
};
```

**Solution 2: (Grouped Loop)**
```
Runtime: 4 ms, Beats 89.09%
Memory: 132.60 MB, Beats 99.09%
```
```c++
class Solution {
public:
    long long maxSumTrionic(vector<int>& nums) {
        int n = nums.size();
        int p, q, j;
        long long max_sum, sum, res;
        long long ans = LLONG_MIN;
        for (int i = 0; i < n; i++) {
            j = i + 1;
            res = 0;
            // first segment
            for (; j < n && nums[j - 1] < nums[j]; j++);
            p = j - 1;
            if (p == i) {
                continue;
            }
            // second segment
            res += nums[p] + nums[p - 1];
            for (; j < n && nums[j - 1] > nums[j]; j++) {
                res += nums[j];
            }
            q = j - 1;
            if (q == p || q == n - 1 || (nums[j] <= nums[q])) {
                i = q;
                continue;
            }
            // third segment
            res += nums[q + 1];
            // find the maximum sum of the third segment
            max_sum = 0;
            sum = 0;
            for (int k = q + 2; k < n && nums[k] > nums[k - 1]; k++) {
                sum += nums[k];
                max_sum = max(max_sum, sum);
            }
            res += max_sum;
            // find the maximum sum of the first segment
            max_sum = 0;
            sum = 0;
            for (int k = p - 2; k >= i; k--) {
                sum += nums[k];
                max_sum = max(max_sum, sum);
            }
            res += max_sum;
            // update answer
            ans = max(ans, res);
            i = q - 1;
        }
        return ans;
    }
};
```

**Solution 3: (DP Bottom Up)**

dp0...dp3
* dpk[i] is the max sum of a subarray ending at i after finishing k of the four phases (start -> inc -> dec -> inc)
* dp0[i] = max(nums[i], dp0[i - 1] + nums[i])
* dpk[i] = max(dpk[i] + nums[i], dp(k-1)[i - 1] + nums[i])
              ^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^
              current segment          new segment        

             dp3 
      dp1   / /
    /\/ \  / /
   / /\  \/ / 
  / /  dp2  
  dp0       

             0  1  2  3  4  5  6
    nums = [ 0,-2,-1,-3, 0, 2,-1]
               -----------
 ^  dp0      0 -2 -3 -3 -3 -1
 ^  dp1           -3   
 v  dp2              -6
 ^  dp3                 -6 -4 

```
Runtime: 17 ms, Beats 62.73%
Memory: 172.66 MB, Beats 21.82%
```
```c++
class Solution {
public:
    long long maxSumTrionic(vector<int>& nums) {
        int n = nums.size(), i;
        vector<long long> dp0(n), dp1(n, -1e15), dp2(n, -1e15), dp3(n, -1e15);
        long long ans = LONG_LONG_MIN;
        dp0[0] = nums[0];
        for (i = 1; i < n; i ++) {
            dp0[i] = nums[i];
            if (nums[i] > nums[i - 1]) {
                dp0[i] = max(dp0[i], dp0[i - 1] + nums[i]);
            }
            if (nums[i] > nums[i - 1]) {
                dp1[i] = max(dp1[i - 1] + nums[i], dp0[i - 1] + nums[i]);
            }
            if (nums[i] < nums[i - 1]) {
                dp2[i] = max(dp2[i - 1] + nums[i], dp1[i - 1] + nums[i]);
            }
            if (nums[i] > nums[i - 1]) {
                dp3[i] = max(dp3[i - 1] + nums[i], dp2[i - 1] + nums[i]);
            }
            ans = max(ans, dp3[i]);
        }
        return ans;
    }
};
```

**Solution 4: (DP Bottom Up 1-D)**
```
Runtime: 0 ms, Beats 100.00%
Memory: 132.76 MB, Beats 80.00%
```
```c++
class Solution {
public:
    long long maxSumTrionic(vector<int>& nums) {
        int n = nums.size(), i;
        long long dp0, dp1 = -1e15, dp2 = -1e15, dp3 = -1e15;
        long long ans = LONG_LONG_MIN;
        dp0 = nums[0];
        for (i = 1; i < n; i ++) {
            if (nums[i] > nums[i - 1]) {
                dp3 = max(dp3 + nums[i], dp2 + nums[i]);
            } else {
                dp3 = -1e15;
            }
            if (nums[i] < nums[i - 1]) {
                dp2 = max(dp2 + nums[i], dp1 + nums[i]);
            } else {
                dp2 = -1e15;
            }
            if (nums[i] > nums[i - 1]) {
                dp1 = max(dp1 + nums[i], dp0 + nums[i]);
            } else {
                dp1 = -1e15;
            }
            if (nums[i] > nums[i - 1]) {
                dp0 = max(dp0 + nums[i], (long long)nums[i]);
            } else {
                dp0 = nums[i];
            }
            ans = max(ans, dp3);
        }
        return ans;
    }
};
```
