3830. Longest Alternating Subarray After Removing At Most One Element

You are given an integer array nums.

A subarray `nums[l..r]` is alternating if one of the following holds:

* `nums[l] < nums[l + 1] > nums[l + 2] < nums[l + 3] > ...`
* `nums[l] > nums[l + 1] < nums[l + 2] > nums[l + 3] < ...`

In other words, if we compare adjacent elements in the subarray, then the comparisons alternate between **strictly** greater and strictly smaller.

You can remove **at most one** element from nums. Then, you select an alternating subarray from `nums`.

Return an integer denoting the **maximum length** of the alternating subarray you can select.

A subarray of length 1 is considered alternating.

 

**Example 1:**
```
Input: nums = [2,1,3,2]

Output: 4

Explanation:

Choose not to remove elements.
Select the entire array [2, 1, 3, 2], which is alternating because 2 > 1 < 3 > 2.
```

**Example 2:**
```
Input: nums = [3,2,1,2,3,2,1]

Output: 4

Explanation:

Choose to remove nums[3] i.e., [3, 2, 1, 2, 3, 2, 1]. The array becomes [3, 2, 1, 3, 2, 1].
Select the subarray [3, 2, 1, 3, 2, 1].
```

**Example 3:**
```
Input: nums = [100000,100000]

Output: 1

Explanation:

Choose not to remove elements.
Select the subarray [100000, 100000].
```

**Constraints:**

* `2 <= nums.length <= 10^5`
* `1 <= nums[i] <= 10^5`

# Submissions
---
**Solution 1: (Prefix Sum, left right, enumeration)**
```
Runtime: 938 ms, Beats 9.09%
Memory: 416.79 MB, Beats 9.09%
```
```c++
class Solution {
public:
    int longestAlternating(vector<int>& nums) {
        int n = nums.size(), i, ans = 1;
        vector<vector<int>>dpl(n, vector<int>(2, 1));
        vector<vector<int>>dpr(n, vector<int>(2, 1));
        for (i = 1; i < n; i ++) {
            if (nums[i - 1] < nums[i]) {
                dpl[i][1] = dpl[i - 1][0] + 1;
            } else if (nums[i - 1] > nums[i]) {
                dpl[i][0] = dpl[i - 1][1] + 1;
            }
            ans = max({dpl[i][0], dpl[i][1], ans});
        }
        for (i = n - 2; i >= 0; i --) {
            if (nums[i] < nums[i + 1] ) {
                 dpr[i][1] = dpr[i + 1][0] + 1;
            } else if(nums[i] > nums[i + 1]){
                 dpr[i][0] = dpr[i + 1][1] + 1;
            }
        }
        for (i = 1; i < n - 1; i ++){
            if (nums[i - 1] > nums[i + 1]) {
                ans = max(ans, dpl[i - 1][1] + dpr[i + 1][1]);
            } else if (nums[i - 1] < nums[i + 1]) {
                ans = max(ans, dpl[i - 1][0] + dpr[i + 1][0]);
            }
        }
        return ans;
    }
};
```

**Solution 2: (Prefix Sum, left right, enumeration)**

             0  1  2  3  4  5  6
    nums = [ 3, 2, 1, 2, 3, 2, 1]
                               i
d              -1 -1  1  1 -1 -1
l            1  2  2  3  2  3  2
                i         
d           -1 -1  1  1 -1 -1 
r            2  3  2  3  2  2  1
                      i
rss                   3
                      i
d              -1  0  1  0 -1
L               1     2     2
R               2     2     1
res                   4

```
Runtime: 63 ms, Beats 81.82%
Memory: 265.10 MB, Beats 40.91%
```
```c++
class Solution {
public:
    int longestAlternating(vector<int>& nums) {
        int n = nums.size();
        auto cmp = [](int a, int b) {
            return (a > b) - (a < b);
        };
        vector<int> l(n, 1);
        for (int i = 1; i < n; i++) {
            int d = cmp(nums[i], nums[i - 1]);
            if (d != 0) {
                if (i > 1 && cmp(nums[i - 1], nums[i - 2]) == -d) l[i] = l[i - 1] + 1;
                else l[i] = 2;
            }
        }
        vector<int> r(n, 1);
        for (int i = n - 2; i >= 0; i--) {
            int d = cmp(nums[i + 1], nums[i]);
            if (d != 0) {
                if (i < n - 2 && cmp(nums[i + 2], nums[i + 1]) == -d) r[i] = r[i + 1] + 1;
                else r[i] = 2;
            }
        }
        int res = 0;
        for (int i = 0; i < n; i++) res = max(res, l[i]);
        for (int i = 1; i < n - 1; i++) {
            int d = cmp(nums[i + 1], nums[i - 1]);
            if (d != 0) {
                int L = (i > 1 && cmp(nums[i - 1], nums[i - 2]) == -d) ? l[i - 1] : 1;
                int R = (i < n - 2 && cmp(nums[i + 2], nums[i + 1]) == -d) ? r[i + 1] : 1;
                res = max(res, L + R);
            }
        }
        return res;
    }
};
```
