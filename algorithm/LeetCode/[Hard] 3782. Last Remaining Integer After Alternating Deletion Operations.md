3782. Last Remaining Integer After Alternating Deletion Operations

You are given an integer `n`.

We write the integers from 1 to `n` in a sequence from left to right. Then, alternately apply the following two operations until only one integer remains, starting with operation **1**:

* Operation 1: Starting from the left, delete every second number.
* Operation 2: Starting from the right, delete every second number.

Return the last remaining integer.

 

**Example 1:**
```
Input: n = 8

Output: 3

Explanation:

Write [1, 2, 3, 4, 5, 6, 7, 8] in a sequence.
Starting from the left, we delete every second number: [1, 2, 3, 4, 5, 6, 7, 8]. The remaining integers are [1, 3, 5, 7].
Starting from the right, we delete every second number: [1, 3, 5, 7]. The remaining integers are [3, 7].
Starting from the left, we delete every second number: [3, 7]. The remaining integer is [3].
```

**Example 2:**
```
Input: n = 5

Output: 1

Explanation:

Write [1, 2, 3, 4, 5] in a sequence.
Starting from the left, we delete every second number: [1, 2, 3, 4, 5]. The remaining integers are [1, 3, 5].
Starting from the right, we delete every second number: [1, 3, 5]. The remaining integers are [1, 5].
Starting from the left, we delete every second number: [1, 5]. The remaining integer is [1].
```

**Example 3:**
```
Input: n = 1

Output: 1

Explanation:

Write [1] in a sequence.
The last remaining integer is 1.
```

**Constraints:**

* `1 <= n <= 10^15`

# Submissions
---
**Solution 1: (Halve the sequence)**

__Approach__
The current sequence can be kept track by three variables:
a. first is the first number in the sequence
b. len is the count of numbers in the sequence
c. gap is the gap between adjacent numbers in the sequence
Start doing operations while maintaining the sequence:
a. Because we delete every second number, each operation multiplies the gap between numbers by 2. gap *= 2
b. For every 2 numbers in the sequence, we will delete one of them in an operation. Therefore, we keep ⌈len/2⌉ elements after an operation.len = (len + 1) / 2
c. The first number moves to the next number if and only if it is Operation 2 and the sequence has even length. This can be proven by casework.
It is trivial that Operation 1 will not move the first number because it deletes every second number starting from the left.
If the length is odd, Operation 2 will not delete the first number. ex: [1,2,3,4,5], Operation 2 deletes [4,2]
If the length is even, Operation 2 will delete the first number. ex: [1,2,3,4], Operation 2 deletes [3,1]
if(len % 2 == 0) start += gap; (for Operation 2)
Keep doing left and right operations until len = 1. The last remaining number will be first.

__Complexity__
Time complexity: O(logn)
Space complexity: O(1)

             v
       1  2  3  4  5  6  7  8
       ^first
len 8
gap 1
          x     x     x     x
             ^first
len 4
gap 2
       x           x
len 2
gap 4
                         x

       v
       1  2  3  4  5
       ^first
len 5
gap 1
          x     x
len 3
gap 2
             x
len 2
gap 4
                   x

```
Runtime: 0 ms, Beats 100.00%
Memory: 9.09 MB, Beats 47.37%
```
```c++
class Solution {
public:
    long long lastInteger(long long n) {
        long long first = 1, len = n, gap = 1;
        while(len > 1) {
            if(len > 1) {
                len = (len + 1) / 2;
                gap *= 2;   
            }
            if(len > 1) {
                if(len % 2 == 0) first += gap;
                len = (len + 1) / 2;
                gap *= 2;   
            }
        }
        return first;
    }
};
```
