3768. Minimum Inversion Count in Subarrays of Fixed Length

You are given an integer array `nums` of length `n` and an integer `k`.

An inversion is a pair of indices `(i, j)` from `nums` such that `i < j` and `nums[i] > nums[j]`.

The **inversion count** of a **subarray** is the number of inversions within it.

Return the **minimum** inversion count among all subarrays of `nums` with length `k`.

 

**Example 1:**
```
Input: nums = [3,1,2,5,4], k = 3

Output: 0

Explanation:

We consider all subarrays of length k = 3 (indices below are relative to each subarray):

[3, 1, 2] has 2 inversions: (0, 1) and (0, 2).
[1, 2, 5] has 0 inversions.
[2, 5, 4] has 1 inversion: (1, 2).
The minimum inversion count among all subarrays of length 3 is 0, achieved by subarray [1, 2, 5].
```

**Example 2:**
```
Input: nums = [5,3,2,1], k = 4

Output: 6

Explanation:

There is only one subarray of length k = 4: [5, 3, 2, 1].
Within this subarray, the inversions are: (0, 1), (0, 2), (0, 3), (1, 2), (1, 3), and (2, 3).
Total inversions is 6, so the minimum inversion count is 6.
```

**Example 3:**
```
Input: nums = [2,1], k = 1

Output: 0

Explanation:

All subarrays of length k = 1 contain only one element, so no inversions are possible.
The minimum inversion count is therefore 0.
```
 

**Constraints:**

* `1 <= n == nums.length <= 10^5`
* `1 <= nums[i] <= 10^9`
* `1 <= k <= n`

# Submissions
---
**Solution 1: (Segment Tree, BIT)**
```
Runtime: 924 ms, Beats 11.76%
Memory: 349.62 MB, Beats 5.88%
```
```c++
class Solution {
    struct BIT{
        int n;
        vector<int> bit;
        BIT(){}
        BIT(int _n){
            n = _n;
            bit = vector<int>(n + 1, 0);
        }
        void upd(int k, int v){
            while(k <= n){
                bit[k] += v;
                k += k&-k;
            }
        }
        int sum(int k){
            int s = 0;
            while(k > 0){
                s += bit[k];
                k -= k&-k;
            }
            return s;
        }
    };
    struct SLIDING_WINDOW{
        long long inv_count;
        deque<int> window;
        int m;
        BIT B;
        SLIDING_WINDOW(int _m){
            inv_count = 0;
            m = _m;
            B = BIT(m);
        }
        void expand(int x){
            inv_count += B.sum(m) - B.sum(x);
            
            window.push_back(x);
            B.upd(x, +1);
        }
        void shrink(){
            int x = window.front();
            inv_count -= B.sum(x - 1);
            
            window.pop_front();
            B.upd(x, -1);
        }
    };
public:
    long long minInversionCount(vector<int>& nums, int k) {
        int n = (int)nums.size();

        set<int> S;
        for(auto x : nums){
            S.insert(x);
        }
        int m = 1;
        map<int, int> convert;
        for(auto x : S){
            convert[x] = m ++;
        }
        for(auto &x : nums){
            x = convert[x];
        }
        
        SLIDING_WINDOW SW(m);
        for(int i = 0; i < k; i ++) SW.expand(nums[i]);
        long long ans = SW.inv_count;
        for(int i = k; i < n; i ++){
            SW.shrink();
            SW.expand(nums[i]);
            ans = min(ans, SW.inv_count);
        }
        return ans;
    }
};
```
