3812. Minimum Edge Toggles on a Tree

You are given an undirected tree with `n` nodes, numbered from 0 to `n - 1`. It is represented by a 2D integer array `edges` of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.

You are also given two binary strings `start` and `target` of length `n`. For each node `x`, `start[x]` is its initial color and `target[x]` is its desired color.

In one operation, you may pick an edge with index `i` and toggle both of its endpoints. That is, if the edge is `[u, v]`, then the colors of nodes `u` and `v` each flip from `'0'` to `'1'` or from `'1'` to `'0'`.

Return an array of edge indices whose operations transform `start` into `target`. Among all valid sequences with minimum possible length, return the edge indices in increasing order.

If it is impossible to transform `start` into `target`, return an array containing a single element equal to `-1`.

 

**Example 1:**

![3812_example1.png](img/3812_example1.png)
```
Input: n = 3, edges = [[0,1],[1,2]], start = "010", target = "100"

Output: [0]

Explanation:

Toggle edge with index 0, which flips nodes 0 and 1.
The string changes from "010" to "100", matching the target.
```

**Example 2:**

![3812_example2.png](img/3812_example2.png)
```
Input: n = 7, edges = [[0,1],[1,2],[2,3],[3,4],[3,5],[1,6]], start = "0011000", target = "0010001"

Output: [1,2,5]

Explanation:

Toggle edge with index 1, which flips nodes 1 and 2.
Toggle edge with index 2, which flips nodes 2 and 3.
Toggle edge with index 5, which flips nodes 1 and 6.
After these operations, the resulting string becomes "0010001", which matches the target.
```

**Example 3:**

![3812_example3.png](img/3812_example3.png)
```

Input: n = 2, edges = [[0,1]], start = "00", target = "01"

Output: [-1]

Explanation:

There is no sequence of edge toggles that transforms "00" into "01". Therefore, we return [-1].
```
 

**Constraints:**

* `2 <= n == start.length == target.length <= 10^5`
* `edges.length == n - 1`
* `edges[i] = [ai, bi]`
* `0 <= ai, bi < n`
* `start[i]` is either `'0'` or `'1'`.
* `target[i]` is either `'0'` or `'1'`.
* The input is generated such that `edges` represents a valid tree.

# Submissions
---
**Solution 1: (DFS)**

Intuition
Instead of repeatedly thinking about flipping 0->1 or 1->0, we can just create a diff[] array which is defined as diff[node] = start[node] ^ target, which means does the node require toggle?

Flipping an edge will affect both the endpoints, so it's better to start from the leaves and move upward (root) through their parents. It's safer to fix a node after it's children are fixed.

While traversing Post order:

if diff[child] = 1 then this must be flipped, there is no other option.
so we flip both values of diff[child] & diff[parent]. This will push the problem of the child upwards.
add the edge index to ans.
else, do nothing
Sort and return the ans.

```
Runtime: 271 ms, Beats 65.00%
Memory: 309.35 MB, Beats 40.00%
```
```c++
class Solution {
    void dfs(int node, int parent, vector<vector<pair<int, int>>> &adj, vector<int> &diff, vector<int> &ans) {
        for(auto &[nei, idx] : adj[node]) {
            if(nei == parent) continue;
            dfs(nei, node, adj, diff, ans);
            if(diff[nei] == 1) {
                ans.push_back(idx);
                diff[nei] ^= 1;
                diff[node] ^= 1;
            }
        }
    }
public:
    vector<int> minimumFlips(int n, vector<vector<int>>& edges, string start, string target) {
        vector<int> diff(n);
        for(int i = 0; i < n; ++i) diff[i] = (start[i] - '0') ^ (target[i] - '0');
        if(count(diff.begin(), diff.end(), 1) & 1) return {-1};
        vector<vector<pair<int, int>>> adj(n);
        for(int i = 0; i < n - 1; ++i) {
            int u = edges[i][0], v = edges[i][1];
            adj[u].push_back({v, i});
            adj[v].push_back({u, i});
        }
        vector<int> ans;
        dfs(0, -1, adj, diff, ans);
        sort(ans.begin(), ans.end());

        return ans;
    }
};
```
