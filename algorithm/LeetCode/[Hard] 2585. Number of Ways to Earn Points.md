2585. Number of Ways to Earn Points

There is a test that has `n` types of questions. You are given an integer `target` and a **0-indexed** 2D integer array `types` where `types[i] = [counti, marksi]` indicates that there are `counti` questions of the `i`th type, and each one of them is worth `marksi` points.

Return the number of ways you can earn **exactly** `target` points in the exam. Since the answer may be too large, return it modulo `10^9 + 7`.

**Note** that questions of the same type are indistinguishable.

* For example, if there are `3` questions of the same type, then solving the `1`st and `2`nd questions is the same as solving the `1`st and `3`rd questions, or the `2`nd and `3`rd questions.
 

**Example 1:**
```
Input: target = 6, types = [[6,1],[3,2],[2,3]]
Output: 7
Explanation: You can earn 6 points in one of the seven ways:
- Solve 6 questions of the 0th type: 1 + 1 + 1 + 1 + 1 + 1 = 6
- Solve 4 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 1 + 2 = 6
- Solve 2 questions of the 0th type and 2 questions of the 1st type: 1 + 1 + 2 + 2 = 6
- Solve 3 questions of the 0th type and 1 question of the 2nd type: 1 + 1 + 1 + 3 = 6
- Solve 1 question of the 0th type, 1 question of the 1st type and 1 question of the 2nd type: 1 + 2 + 3 = 6
- Solve 3 questions of the 1st type: 2 + 2 + 2 = 6
- Solve 2 questions of the 2nd type: 3 + 3 = 6
```

**Example 2:**
```
Input: target = 5, types = [[50,1],[50,2],[50,5]]
Output: 4
Explanation: You can earn 5 points in one of the four ways:
- Solve 5 questions of the 0th type: 1 + 1 + 1 + 1 + 1 = 5
- Solve 3 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 2 = 5
- Solve 1 questions of the 0th type and 2 questions of the 1st type: 1 + 2 + 2 = 5
- Solve 1 question of the 2nd type: 5
```

**Example 3:**
```
Input: target = 18, types = [[6,1],[3,2],[2,3]]
Output: 1
Explanation: You can only earn 18 points by answering all questions.
```

**Constraints:**

* `1 <= target <= 1000`
* `n == types.length`
* `1 <= n <= 50`
* `types[i].length == 2`
* `1 <= counti, marksi <= 50`

# Submissions
---
**Solution 1: (DP Bottom-Up, Knapsack)**
```
Runtime: 602 ms
Memory: 8.4 MB
```
```c++
class Solution {
public:
    int waysToReachTarget(int target, vector<vector<int>>& types) {
        const int n = types.size();
        vector<long long int> dp(target+1); //dp[i] = number of ways to get i points
        const int m = 1e9+7;
        dp[0]=1;
        for(int index=0;index<n;index++){ //process the types
            for(int points=target;points>=0;points--){ //iterate in reverse order of points to avoid duplicate calculation
                for(int count=1;count<=types[index][0];count++){ //same as knapsack
                    if(points>=types[index][1]*count) {
                        dp[points]+=dp[points-types[index][1]*count];
                        dp[points]%=m;
                    }
                }
            }
        }
        return dp[target];
    }
};
```

**Solution 2: (DFS, prefix sum)**

     ^      v0 root |
     |    /   \     |
     |  v1     ...  v
     |   \         costToOthers = totalCost - revCost[i]
     |    vi
     |  ans[i] = costToStartNode + costToOthers
  costToStartNode 
  = depth[i] - revCost[i]

           2 (1,1,0) // depth,revCost,ans
         /    \
        v      v
(2,1,1) 1      0 (0,0,1)
         \
          V
           3 (3,1,2)
    
totalCost: 1

```
Runtime: 149 ms, Beats 93.14%
Memory: 216.94 MB, Beats 64.48%
```
```c++
class Solution {
    int totalCost = 0;
    void dfs(vector<vector<pair<int,int>>> &g, int u, int p, vector<int> &revCost, vector<int>& depth, int currentDepth) {
        depth[u] = currentDepth;
        for (auto [v, cost] : g[u]) {
            if (v != p) {
                revCost[v] = revCost[u] + cost;
                totalCost += cost;
                dfs(g, v, u, revCost, depth, currentDepth + 1);
            }
        }
    }
public:
    vector<int> minEdgeReversals(int n, vector<vector<int>>& edges) {
        int i;
        vector<vector<pair<int,int>>> g(n);
        for (auto &e: edges) {
            g[e[0]].push_back({e[1], 0});
            g[e[1]].push_back({e[0], 1});
        }
        vector<int> revCost(n, 0);
        vector<int> depth(n, 0);
        dfs(g, 0, -1, revCost, depth, 0);
        vector<int> ans(n);
        ans[0] = totalCost;
        for (i = 1; i < n; i++) {
            int costToStartNode = depth[i] - revCost[i];
            int costToOthers = totalCost - revCost[i];
            ans[i] = costToStartNode + costToOthers;
        }
        return ans;
    }
};
```
