3655. XOR After Range Multiplication Queries II

You are given an integer array `nums` of length `n` and a 2D integer array `queries` of size `q`, where `queries[i] = [li, ri, ki, vi]`.

For each query, you must apply the following operations in order:

* Set `idx = li`.
* While `idx <= ri`:
    * `Update: nums[idx] = (nums[idx] * vi) % (10^9 + 7).`
    * Set `idx += ki`.

Return the bitwise XOR of all elements in `nums` after processing all queries.

 

**Example 1:**
```
Input: nums = [1,1,1], queries = [[0,2,1,4]]

Output: 4

Explanation:

A single query [0, 2, 1, 4] multiplies every element from index 0 through index 2 by 4.
The array changes from [1, 1, 1] to [4, 4, 4].
The XOR of all elements is 4 ^ 4 ^ 4 = 4.
```

**Example 2:**
```
Input: nums = [2,3,1,5,4], queries = [[1,4,2,3],[0,2,1,2]]

Output: 31

Explanation:

The first query [1, 4, 2, 3] multiplies the elements at indices 1 and 3 by 3, transforming the array to [2, 9, 1, 15, 4].
The second query [0, 2, 1, 2] multiplies the elements at indices 0, 1, and 2 by 2, resulting in [4, 18, 2, 15, 4].
Finally, the XOR of all elements is 4 ^ 18 ^ 2 ^ 15 ^ 4 = 31.â€‹
```

Constraints:

* `1 <= n == nums.length <= 10^5`
* `1 <= nums[i] <= 10^9`
* `1 <= q == queries.length <= 10^5`
* `queries[i] = [li, ri, ki, vi]`
* `0 <= li <= ri < n`
* `1 <= ki <= n`
* `1 <= vi <= 10^5`

# Submissions
---
**Solution 1: (Square Root Decomposition, Sweep Line)**

Approach
Use the square root decomposition technique.
Let S = sqrt(n) + 1
For a given query,
if k >= S, use brute force to update all values in place
if k < S, we store this update event and work on this later similar to sweep line technique

We store the starting event and ending event
Let's say the given query is l, r, k, v
so store this as
starting event events[k][l] = (events[k][l] * v) % MOD;
ending event events[k][r2] = (events[k][r2] * modInverse(v)) % MOD;

here r2 is the smallest number greater than r which comes in sequence i, i+k, i+2*k, ....

Now for a given k, we will apply these sorted events similar to sweep line technique.
Let's say for k = 2 we had these queries
{0, 8, 2, 3}
{4, 8, 2, 4}
{3, 12, 2, 7}

so our events map for k=2 would look like
{0, 3} {3, 7} {4, 4} {10, modInv(3) * modInv(4)} {13, modInv(7)}

We will repeat the below process until this events map becomes empty
pick the first element from this map
start from key of this element (here i = 0)
now since k = 2, we want apply any updates for index 0, 2, 4, 8, 10, 12 ...
Along this path we have check for other events as well, if have considered that event remove that event. For example here in this path we other events for (i = 4, 10) .

Using this sweep line technique helped us to combine the 1st 2 queries ({0, 8, 2, 3}, {4, 8, 2, 4}) and we avoided iterating indexes (4, 6, 8) twice

```
Runtime: 9 ms, Beats 100.00%
Memory: 209.25 MB, Beats 100.00%
```
```c++
class Solution {
    long long modInverse(long long a,long long MOD){
        return modPower(a,MOD-2,MOD);
    }

    long long modPower(long long x, long long y, long long P){    
        if( y == 0LL) return 1LL;
        long long tmp = modPower(x, y/2LL, P);
    
        if(y&1) return (((x*tmp)%P)*tmp)%P ;
        else return  ((tmp*tmp)%P) ;
    }

    int getOrDefault(map<int,int>& mp, int key, int defaultVal) {
        auto it = mp.find(key);
        if(it == mp.end()) return defaultVal;
        return it->second;
    }

    int getAndRemove(map<int,int>& mp, int key, int defaultVal) {
        auto it = mp.find(key);
        if(it == mp.end()) return defaultVal;
        int res = it->second;
        mp.erase(it);
        return res;
    }
public:
    int xorAfterQueries(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int S = sqrt(n) + 1; 
        vector<map<int,int>> events(S);
        int MOD = 1e9 + 7;

        for(auto& q: queries) {
            int l = q[0], r = q[1], k = q[2], v = q[3];

            if(k >= S) {
                for(int i=l; i<=r; i+=k) {
                    nums[i] = (1LL * nums[i] * v) % MOD;
                }
                continue;
            }

            //smaller k
            events[k][l] = (1LL * getOrDefault(events[k], l, 1) * v) % MOD;

            int r2 = r + (k - (r - l)%k);
            if(r2 < n) {
                events[k][r2] = (1LL* getOrDefault(events[k], r2, 1) * modInverse(v, MOD)) % MOD;
            }
        }

        for(int k=1; k<S; k++){
            map<int,int>& e = events[k];

            while(e.size() > 0) {
                int start = (e.begin())->first;
                int multBy = 1;
                for(int i=start; i<n; i+=k) {
                    multBy = (1LL * multBy * getAndRemove(e, i, 1)) % MOD;
                    nums[i] = (1LL * nums[i] * multBy) % MOD;
                }
            }
        }

        int res = 0;
        for(int x : nums) res ^= x;
        return res;
    }
};
```
