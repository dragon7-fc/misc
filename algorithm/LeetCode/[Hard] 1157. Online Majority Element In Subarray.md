1157. Online Majority Element In Subarray

Implementing the class MajorityChecker, which has the following API:

* `MajorityChecker(int[] arr)` constructs an instance of MajorityChecker with the given array arr;
* `int query(int left, int right, int threshold)` has arguments such that:
    * `0 <= left <= right < arr.length`representing a subarray of arr;
    * `2 * threshold > right - left + 1`, ie. the `threshold` is always a strict majority of the length of the subarray

Each `query(...)` returns the element in `arr[left], arr[left+1], ..., arr[right]` that occurs at least `threshold` times, or `-1` if no such element exists.

 

**Example:**
```
MajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]);
majorityChecker.query(0,5,4); // returns 1
majorityChecker.query(0,3,3); // returns -1
majorityChecker.query(2,3,2); // returns 2
```

**Constraints:**

* `1 <= arr.length <= 20000`
* `1 <= arr[i] <= 20000`
* For each query, `0 <= left <= right < len(arr)`
* For each query, `2 * threshold > right - left + 1`
* The number of queries is at most `10000`

# Submissions
---
**Solution 1: (Binary Search)**
```
Runtime: 456 ms
Memory Usage: 20.1 MB
```
```python
class MajorityChecker:

    def __init__(self, arr: List[int]):
        self.loc = collections.defaultdict(list)
        for i, n in enumerate(arr):
            self.loc[n].append(i)    
        self.nums = sorted(self.loc.keys(), key = lambda n: len(self.loc[n]), reverse=True)

    def query(self, left: int, right: int, threshold: int) -> int:
        for n in self.nums:
            if len(self.loc[n]) < threshold: return -1
            l, r = bisect.bisect_left(self.loc[n], left), bisect.bisect_right(self.loc[n], right)
            if r - l >= threshold: return n
        return -1


# Your MajorityChecker object will be instantiated and called as such:
# obj = MajorityChecker(arr)
# param_1 = obj.query(left,right,threshold)
```

**Solution 2:(Segment Tree)**

     0              5
    [1, 1, 2, 2, 1, 1]

         [0, 5]
           1,2
          /   \
    [0, 2]    [3, 5]
     1,1        1,1
     /  \       /  \
  [0,1] [2]   [3,4] [5]
   1,2  2,1   1,0   1,1
   / \         / \
[0,0][1,1] [3,3][4,4]
  1,1 1,1   2,1  1,1

```
Runtime: 54 ms, Beats 82.14%
Memory: 120.58 MB, Beats 43.30%
```
```c++
class MajorityChecker {
    int n;
    vector<pair<int,int>> tree;
    unordered_map<int,vector<int>> g;
    void build(int i, int left, int right, vector<int> &arr) {
        if (left == right) {
            tree[i] = {arr[left], 1};
            return;
        }
        int mid = left + (right - left)/2;
        build(2*i + 1, left, mid, arr);
        build(2*i + 2, mid + 1, right, arr);
        auto [a, ak] = tree[2*i + 1];
        auto [b, bk] = tree[2*i + 2];
        if (a == b) {
            tree[i] = {a, ak + bk};
        } else {
            if (ak > bk) {
                tree[i] = {a, ak - bk};
            } else {
                tree[i] = {b, bk - ak};
            }
        }
    }
    pair<int,int> _query(int i, int q_left, int q_right, int left, int right) {
        if (q_left > right || q_right < left) {
            return {-1, 0};
        }
        if (q_left <= left && q_right >= right) {
            return tree[i];
        }
        int mid = left + (right - left)/2;
        auto [a, ak] = _query(2*i + 1, q_left, q_right, left, mid);
        auto [b, bk] = _query(2*i + 2, q_left, q_right, mid+1, right);
        if (a == b) {
            return {a, ak + bk};
        } else {
            if (ak > bk) {
                return {a, ak - bk};
            } else {
                return {b, bk - ak};
            }
        }
    }
public:
    MajorityChecker(vector<int>& arr) {
        n = arr.size();
        tree.resize(4*n);
        build(0, 0, n-1, arr);
        for (int i = 0; i < n; i ++) {
            g[arr[i]].push_back(i);
        }
    }
    
    int query(int left, int right, int threshold) {
        auto [a, ak] = _query(0, left, right, 0, n-1);
        if (a == -1 || !g.count(a)) {
            return -1;
        }
        auto left_it = lower_bound(g[a].begin(), g[a].end(), left);
        auto right_it = upper_bound(g[a].begin(), g[a].end(), right);
        if (right_it - left_it >= threshold) {
            return a;
        }
        return -1;
    }
};

/**
 * Your MajorityChecker object will be instantiated and called as such:
 * MajorityChecker* obj = new MajorityChecker(arr);
 * int param_1 = obj->query(left,right,threshold);
 */
```

**Solution 3:(Random Pick)**

Hint 1
What's special about a majority element ?
Hint 2
A majority element appears more than half the length of the array number of times.
Hint 3
If we tried a random index of the array, what's the probability that this index has a majority element ?
Hint 4
It's more than 50% if that array has a majority element.
Hint 5
Try a random index for a proper number of times so that the probability of not finding the answer tends to zero.

```
Runtime: 69 ms, Beats 72.20%
Memory: 128.04 MB, Beats 25.56%
```
```c++
class MajorityChecker {
    vector<vector<int>> g;
    vector<int> dp;
public:
    MajorityChecker(vector<int>& arr) {
        g.resize(20001);
        for (int i = 0; i < arr.size(); i ++) {
            g[arr[i]].push_back(i);
        }
        dp = arr;
    }
    
    int query(int left, int right, int threshold) {
        int i, j, k = right - left + 1, a;
        for (i = 0; i < 10; i ++) {
            j = left + rand()%k;
            a = dp[j];
            if (upper_bound(g[a].begin(), g[a].end(), right) - lower_bound(g[a].begin(), g[a].end(), left) >= threshold) {
                return a;
            }
        }
        return -1;
    }
};

/**
 * Your MajorityChecker object will be instantiated and called as such:
 * MajorityChecker* obj = new MajorityChecker(arr);
 * int param_1 = obj->query(left,right,threshold);
 */
```
