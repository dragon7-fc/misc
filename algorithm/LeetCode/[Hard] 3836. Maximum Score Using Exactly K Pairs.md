3836. Maximum Score Using Exactly K Pairs

You are given two integer arrays `nums1` and `nums2` of lengths `n` and `m` respectively, and an integer `k`.

You must choose exactly `k` pairs of indices `(i1, j1), (i2, j2), ..., (ik, jk)` such that:

* `0 <= i1 < i2 < ... < ik < n`
* `0 <= j1 < j2 < ... < jk < m`

For each chosen pair `(i, j)`, you gain a score of `nums1[i] * nums2[j]`.

The total score is the sum of the products of all selected pairs.

Return an integer representing the **maximum** achievable total score.

 

**Example 1:**
```
Input: nums1 = [1,3,2], nums2 = [4,5,1], k = 2

Output: 22

Explanation:

One optimal choice of index pairs is:

(i1, j1) = (1, 0) which scores 3 * 4 = 12
(i2, j2) = (2, 1) which scores 2 * 5 = 10
This gives a total score of 12 + 10 = 22.
```

**Example 2:**
```
Input: nums1 = [-2,0,5], nums2 = [-3,4,-1,2], k = 2

Output: 26

Explanation:

One optimal choice of index pairs is:

(i1, j1) = (0, 0) which scores -2 * -3 = 6
(i2, j2) = (2, 1) which scores 5 * 4 = 20
The total score is 6 + 20 = 26.
```

**Example 3:**
```
Input: nums1 = [-3,-2], nums2 = [1,2], k = 2

Output: -7

Explanation:

The optimal choice of index pairs is:

(i1, j1) = (0, 0) which scores -3 * 1 = -3
(i2, j2) = (1, 1) which scores -2 * 2 = -4
The total score is -3 + (-4) = -7.
```
 

**Constraints:**

* `1 <= n == nums1.length <= 100`
* `1 <= m == nums2.length <= 100`
* `-10^6 <= nums1[i], nums2[i] <= 10^6`
* `1 <= k <= min(n, m)`

# Submissions
---
**Solution 1: (DP Top-Down)**
```
Runtime: 1111 ms, Beats 29.79%
Memory: 553.62 MB, Beats 45.09%
```
```c++
class Solution {
    long long dfs(int i, int j, int r, vector<vector<vector<long long>>> &dp, vector<int> &nums1, vector<int> &nums2) {
        if (r == 0) {
            return 0;
        }
        if (i >= nums1.size() || j >= nums2.size()) {
            return LONG_LONG_MIN / 2;
        }
        if (dp[i][j][r] != LONG_LONG_MIN) {
            return dp[i][j][r];
        }
        long long rst = 1LL * nums1[i] * nums2[j] + dfs(i + 1, j + 1, r - 1, dp, nums1, nums2);
        rst = max(rst, dfs(i + 1, j, r, dp, nums1, nums2));
        rst = max(rst, dfs(i, j + 1, r, dp, nums1, nums2));
        dp[i][j][r] = rst;
        return rst;
    }
public:
    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {
        int m = nums1.size(), n = nums2.size();
        vector<vector<vector<long long>>> dp(m, vector<vector<long long>>(n, vector<long long>(k + 1, LONG_LONG_MIN)));
        return dfs(0, 0, k, dp, nums1, nums2);
    }
};
```

**Solution 2: (DP Bottom-Up)**
```
Runtime: 487 ms, Beats 85.00%
Memory: 57.50 MB, Beats 95.13%
```
```c++
class Solution {
    const long long NEG = -4e18;
    long long dp[101][101][101];
public:
    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {
        int n = nums1.size();
        int m = nums2.size();

        // initialize DP with NEG
        for (int i = 0; i <= n; i++)
            for (int j = 0; j <= m; j++)
                for (int t = 0; t <= k; t++)
                    dp[i][j][t] = NEG;

        // base case
        dp[0][0][0] = 0;

        // fill DP table
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                for (int t = 0; t <= k; t++) {

                    if (i > 0)
                        dp[i][j][t] =
                            max(dp[i][j][t], dp[i-1][j][t]);

                    if (j > 0)
                        dp[i][j][t] =
                            max(dp[i][j][t], dp[i][j-1][t]);

                    if (i > 0 && j > 0 && t > 0 &&
                        dp[i-1][j-1][t-1] != NEG) {

                        dp[i][j][t] = max(
                            dp[i][j][t],
                            dp[i-1][j-1][t-1]
                            + 1LL * nums1[i-1] * nums2[j-1]
                        );
                    }
                }
            }
        }

        return dp[n][m][k];
    }
};
```
