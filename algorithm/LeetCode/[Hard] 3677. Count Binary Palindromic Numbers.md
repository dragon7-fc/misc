3677. Count Binary Palindromic Numbers

You are given a non-negative integer `n`.

A non-negative integer is called **binary-palindromic** if its binary representation (written without leading zeros) reads the same forward and backward.

Return the number of integers `k` such that `0 <= k <= n` and the binary representation of `k` is a **palindrome**.

**Note**: The number 0 is considered binary-palindromic, and its representation is `"0"`.

 

**Example 1:**
```
Input: n = 9

Output: 6

Explanation:

The integers k in the range [0, 9] whose binary representations are palindromes are:

0 → "0"
1 → "1"
3 → "11"
5 → "101"
7 → "111"
9 → "1001"
All other values in [0, 9] have non-palindromic binary forms. Therefore, the count is 6.
```

**Example 2:**
```
Input: n = 0

Output: 1

Explanation:

Since "0" is a palindrome, the count is 1.
```
 

**Constraints:**

* `0 <= n <= 10^15`

# Submissions
---
**Solution 1: (O(logn))**

__Explanation__
The code counts binary palindromes up to n by splitting the problem into two parts:

Count smaller palindromes:
It adds up all binary palindromes that have fewer digits than n.
The number of k-digit binary palindromes is 2^((k+1)//2 - 1).
The code sums this value for all k from 1 to n-1.

Count same-length palindromes:
It checks for palindromes with the same number of digits as n.
It does this by creating a "mirror" number from the first half of n's binary string.
The number of such palindromes is the value of this mirrored number.

Finally, it checks if n itself is a palindrome and adds 1 to the total if it is.

__Complexity__
Time O(logn)
Space O(logn)

```
Runtime: 6 ms, Beats -%
Memory: 17.68 MB, Beats 100.00%
```
```python
class Solution:
    def countBinaryPalindromes(self, n: int) -> int:
        if n == 0: return 1
        res = 1
        A = [int(i) for i in bin(n)[2:]]
        n = len(A)
        for k in range(1, n):
            res += 1 << ((k + 1) // 2 - 1)
        half = (n + 1) // 2
        for i in range(1, half):
            if A[i] == 1:
                res += 1 << (half - i - 1)
        res += A[:half][::-1] <= A[-half:]
        return res
```
