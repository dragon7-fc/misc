3725. Count Ways to Choose Coprime Integers from Rows

You are given a `m x n` matrix `mat` of positive integers.

Return an integer denoting the number of ways to choose exactly one integer from each row of `mat` such that the **greatest common divisor** of all chosen integers is 1.

Since the answer may be very large, return it modulo `10^9 + 7`.

 

**Example 1:**
```
Input: mat = [[1,2],[3,4]]

Output: 3

Explanation:

Chosen integer in the first row	Chosen integer in the second row	Greatest common divisor of chosen integers
1	3	1
1	4	1
2	3	1
2	4	2
3 of these combinations have a greatest common divisor of 1. Therefore, the answer is 3.
```

**Example 2:**
```
Input: mat = [[2,2],[2,2]]

Output: 0

Explanation:

Every combination has a greatest common divisor of 2. Therefore, the answer is 0.
```
 

**Constraints:**

* `1 <= m == mat.length <= 150`
* `1 <= n == mat[i].length <= 150`
* `1 <= mat[i][j] <= 150`

# Submissions
---
**Solution 1: (DP Bottom-Up)**
```
Runtime: 1096 ms, Beats 5.02%
Memory: 54.46 MB, Beats 12.50%
```
```c++
class Solution {
public:
    int countCoprime(vector<vector<int>>& mat) {
        int m = mat.size(), n = mat[0].size(), i, j, k, MOD = 1e9 + 7;
        vector<vector<long long>> dp(m, vector<long long>(151));
        for (j = 0; j < n; j ++) {
            dp[0][mat[0][j]] += 1;
        }
        for (i = 1; i < m; i ++) {
            for (j = 0; j < n; j ++) {
                for (k = 1; k <= 150; k ++) {
                    dp[i][gcd(mat[i][j], k)] += dp[i-1][k];
                    dp[i][gcd(mat[i][j], k)] %= MOD;
                }
            }
        }
        return dp[m - 1][1];
    }
};
```

**Solution 2: (DP Bottom-Up, 1-D)**
```
Runtime: 391 ms, Beats 35.05%
Memory: 52.70 MB, Beats 18.75%
```
```c++
class Solution {
public:
    int countCoprime(vector<vector<int>>& mat) {
        const int MOD = 1e9 + 7;
        unordered_map<int, int> cnt;
        cnt[0] = 1;
        for (auto row: mat) {
            unordered_map<int, int> nxt;
            for (int a : row) {
                for (auto &p : cnt) {
                    int g = gcd(a, p.first);
                    nxt[g] = (nxt[g] + p.second) % MOD;
                }
            }
            cnt.swap(nxt);
        }
        return cnt[1];
    }
};
```
