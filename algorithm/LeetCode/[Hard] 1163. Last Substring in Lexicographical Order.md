1163. Last Substring in Lexicographical Order

Given a string `s`, return the last substring of `s` in lexicographical order.

 

**Example 1:**
```
Input: "abab"
Output: "bab"
Explanation: The substrings are ["a", "ab", "aba", "abab", "b", "ba", "bab"]. The lexicographically maximum substring is "bab".
```

**Example 2:**
```
Input: "leetcode"
Output: "tcode"
```

**Note:**

* `1 <= s.length <= 4 * 10^5`
* `s` contains only lowercase English letters.

# Submissions
---
**Solution 1: (Greedy)**
```
Runtime: 3616 ms
Memory Usage: 16.1 MB
```
```python
class Solution:
    def lastSubstring(self, s: str) -> str:
        if len(s) < 2:
            return s
        
        current = s[-1]
        for i in range(len(s) - 2, -1, -1):
            check = s[i:]       # "cache" s[i:] in check variable for reducing same slicing twice
            if check > current:
                current = check
        
        return current
```

**Solution 2: (Two Pointers)**
```
Runtime: 252 ms
Memory Usage: 16.3 MB
```
```python
class Solution:
    def lastSubstring(self, s: str) -> str:
        i, j, k, N = 0, 1, 0, len(s)
        while j+k < N:
            if s[i+k] == s[j+k]:
                k += 1
                continue
            elif s[i+k] > s[j+k]:
                j += k+1
            else:
                i = max(j, i+k+1)
                j = i+1
            k = 0
        return s[i:]
```

**Solution 3: (Two Pointers, left most largest substring)**

    a b a b
    ^i^j
      ^i^j
          ^j
ans   ^^^^^
k   0 0   1

    l e e t c o d e
    ^i^j
        ^j
          ^j
          ^i^j
              ^j
                ^j
                   ^j
ans       ^^^^^^^^^^
k   0
```
Runtime: 0 ms, Beats 100.00%
Memory: 23.26 MB, Beats 21.88%
```
```c++
class Solution {
public:
    string lastSubstring(string s) {
        int n = s.length(), i = 0, j = 1, k = 0;
        while (j + k < n) {
            if (s[i + k] == s[j + k]) {
                k += 1;
                continue;
            } else if (s[i + k] > s[j + k]) {
                j += k + 1;
            } else {
                i = max(i + k + 1, j);
                j = i + 1;
            }
            k = 0;
        }
        return s.substr(i);
    }
};
```
