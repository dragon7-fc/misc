3729. Count Distinct Subarrays Divisible by K in Sorted Array

You are given an integer array `nums` sorted in non-descending order and a positive integer `k`.

A **subarray** of `nums` is **good** if the sum of its elements is **divisible** by `k`.

Return an integer denoting the number of **distinct good** subarrays of `nums`.

Subarrays are **distinct** if their sequences of values are. For example, there are 3 **distinct** subarrays in `[1, 1, 1]`, namely `[1]`, `[1, 1]`, and `[1, 1, 1]`.

 

**Example 1:**
```
Input: nums = [1,2,3], k = 3

Output: 3

Explanation:

The good subarrays are [1, 2], [3], and [1, 2, 3]. For example, [1, 2, 3] is good because the sum of its elements is 1 + 2 + 3 = 6, and 6 % k = 6 % 3 = 0.
```

**Example 2:**
```
Input: nums = [2,2,2,2,2,2], k = 6

Output: 2

Explanation:

The good subarrays are [2, 2, 2] and [2, 2, 2, 2, 2, 2]. For example, [2, 2, 2] is good because the sum of its elements is 2 + 2 + 2 = 6, and 6 % k = 6 % 6 = 0.

Note that [2, 2, 2] is counted only once.
```
 

**Constraints:**

* `1 <= nums.length <= 10^5`
* `1 <= nums[i] <= 10^9`
* `nums` is sorted in non-descending order.
* `1 <= k <= 10^9`

# Submissions
---
**Solution 1: (Prefix + Dedupe)**

__Intuition__
If subarray don't need to dedup, it will be very easy.
Just use prefix sums modulo k.

How can we dedup?
We notice the array is sorted,
so duplication only happen for subarray with same element.

__Explanation__
Let pre be the running sum modulo k.
Two prefix positions with the same pre
give a subarray whose sum â‰¡ 0 (mod k).
Keeping a frequency map of seen pre values,
lets us accumulate the number of such subarrays in a single pass.

Remove over-counting of identical-value subarrays,
because we must count distinct sequences of values only.

Assume a form a single contiguous run of length l.
for every 1 <= ll < l.
and the subarray [a, a, ..., a] of length ll appears l - ll + 1 times,
but as a distinct value-sequence it should be counted once.

If ll * a % k == 0,
those occurrences were included in the prefix-sum total.
we therefore subtract the extra l - ll occurrences (keep one).

__Complexity__
Time O(n)
Space O(min(n, k))

```
Runtime: 122 ms, Beats 77.78%
Memory: 189.30 MB, Beats 77.78%
```
```c++
class Solution {
public:
    long long numGoodSubarrays(vector<int>& nums, int k) {
        unordered_map<int,long long> cnt;
        cnt[0] = 1;
        int pre = 0, n = nums.size();
        long long res = 0;
        for (int a : nums) {
            pre = (pre + a) % k;
            res += cnt[pre]++;
        }
        for (int i = 0; i < n; ) {
            int j = i;
            while (j < n && nums[j] == nums[i]) ++j;
            int l = j - i;
            for (int ll = 1; ll < l; ++ll)
                if ((1LL * ll * nums[i]) % k == 0)
                    res -= (l - ll);
            i = j;
        }
        return res;
    }
};
```
