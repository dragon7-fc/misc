2025. Maximum Number of Ways to Partition an Array

You are given a **0-indexed** integer array `nums` of length `n`. The number of ways to **partition** `nums` is the number of `pivot` indices that satisfy both conditions:

* `1 <= pivot < n`
* `nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]`

You are also given an integer `k`. You can choose to change the value of **one** element of nums to `k`, or to leave the array **unchanged**.

Return the **maximum** possible number of ways to partition nums to satisfy both conditions after changing **at most** one element.

 

**Example 1:**
```
Input: nums = [2,-1,2], k = 3
Output: 1
Explanation: One optimal approach is to change nums[0] to k. The array becomes [3,-1,2].
There is one way to partition the array:
- For pivot = 2, we have the partition [3,-1 | 2]: 3 + -1 == 2.
```

**Example 2:**
```
Input: nums = [0,0,0], k = 1
Output: 2
Explanation: The optimal approach is to leave the array unchanged.
There are two ways to partition the array:
- For pivot = 1, we have the partition [0 | 0,0]: 0 == 0 + 0.
- For pivot = 2, we have the partition [0,0 | 0]: 0 + 0 == 0.
```

**Example 3:**
```
Input: nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33
Output: 4
Explanation: One optimal approach is to change nums[2] to k. The array becomes [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14].
There are four ways to partition the array.
```

**Constraints:**

* `n == nums.length`
* `2 <= n <= 10^5`
* `-10^5 <= k, nums[i] <= 10^5`

# Submissions
---
**Solution 1: (Prefix Sum, Binary Search)**
```
Runtime: 3975 ms
Memory Usage: 76 MB
```
```python
class Solution:
    def waysToPartition(self, nums: List[int], k: int) -> int:
        n = len(nums)
        acc1 = list(accumulate(nums))
        d1 = defaultdict(list)
        for idx, num in enumerate(acc1):
            d1[num].append(idx)

        acc2 = list(accumulate(nums[::-1]))
        d2 = defaultdict(list)
        for idx, num in enumerate(acc2):
            d2[num].append(idx)

        ans, ans2 = 0, 0

        for i in range(n - 1):
            if acc1[-1] == 2*acc1[i]: ans2 += 1

        for i in range(0, n):
            cand = (acc1[-1] - nums[i] + k)/2
            lft = bisect.bisect(d1[cand], i-1)
            rgh = bisect.bisect(d2[cand], n - i - 2)
            ans = max(ans, lft + rgh)

        return max(ans, ans2)
```

**Solution 2: (Prefix Sum, Counter, Left and Right Differences)**

For each pivot point, figure out the the difference between left and right sums, and count each difference in a hash map right.

If we do not change anything, our answer will be the count of zero differences.

Now, what happens if we change num[i] to k?

All differences to the left of i will increase by nums[i] - k.
All differences starting from i will decrease by nums[i] - k.
Now, we go left-to-right, move differences from right to left, and track max partitions if we change the current number.

                                             sum
    ----------------------------------------------------------------------------------------------
    nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]
    -----------------------------------------    -------------------------------------------------
                     lsum                                          lsum
    -> sum - 2 * lsum = 0

                  sum - 2 * lsum
                  = nums[i] - k
      ------------xxxxxxxxxxx-------------
           lsum                 lsum
      ----------------------- ------------
                left             right

    nums = [2,-1,2], k = 3
    sum  3
    lsum    2  1
right
    -1   1
    1    1
```
Runtime: 292 ms, Beats 57.94%
Memory: 246.20 MB, Beats 75.70%
```
```c++
class Solution {
public:
    int waysToPartition(vector<int>& nums, int k) {
        unordered_map<long long, int> left, right;
        long long sum = accumulate(begin(nums), end(nums), 0ll);
        for (long long i = 0, lsum = 0; i < nums.size() - 1; ++i) {
            lsum += nums[i];
            ++right[sum - 2 * lsum];
        }
        int res = right[0];
        for (long long i = 0, lsum = 0; i < nums.size(); ++i) {
            res = max(res, left[nums[i] - k] + right[-nums[i] + k]);
            lsum += nums[i];
            ++left[sum - 2 * lsum];
            --right[sum - 2 * lsum];
        }
        return res;
    }
};
```
