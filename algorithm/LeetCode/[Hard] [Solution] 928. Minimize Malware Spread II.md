928. Minimize Malware Spread II

(This problem is the same as Minimize Malware Spread, with the differences bolded.)

In a network of nodes, each node `i` is directly connected to another node `j` if and only if `graph[i][j] = 1`.

Some nodes `initial` are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.

Suppose `M(initial)` is the final number of nodes infected with malware in the entire network, after the spread of malware stops.

We will remove one node from the `initial`list, **completely removing it and any connections from this node to any other node**.  Return the node that if removed, would minimize `M(initial)`.  If multiple nodes could be removed to minimize `M(initial)`, return such a node with the smallest index.

 

**Example 1:**
```
Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0
```

**Example 2:**
```
Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
Output: 1
```

**Example 3:**
```
Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
Output: 1
```

**Note:**

* `1 < graph.length = graph[0].length <= 300`
* `0 <= graph[i][j] == graph[j][i] <= 1`
* `graph[i][i] = 1`
* `1 <= initial.length < graph.length`
* `0 <= initial[i] < graph.length`

# Submissions
---
## Approach 1: Depth First Search
**Intuition and Algorithm**

Let `G` be the graph with all the nodes from `initial` removed.

For each node `v` not in `initial`, we want to know which nodes `u` from initial can reach `v` in the graph `G` [with `u` (and its edges) added to `G`]. Let's say these nodes `u` "infect" `v`.

Afterwards, we want to know which nodes `v` are uniquely infected by only one `u`. For each such pair, it contributes `1` to the answer for `u`.

Please see the inline comments for more details.

```python
class Solution(object):
    def minMalwareSpread(self, graph, initial):
        N = len(graph)
        clean = set(range(N)) - set(initial)
        def dfs(u, seen):
            for v, adj in enumerate(graph[u]):
                if adj and v in clean and v not in seen:
                    seen.add(v)
                    dfs(v, seen)

        # For each node u in initial, dfs to find
        # 'seen': all nodes not in initial that it can reach.
        infected_by = {v: [] for v in clean}
        for u in initial:
            seen = set()
            dfs(u, seen)

            # For each node v that was seen, u infects v.
            for v in seen:
                infected_by[v].append(u)

        # For each node u in initial, for every v not in initial
        # that is uniquely infected by u, add 1 to the contribution for u.
        contribution = collections.Counter()
        for v, neighbors in infected_by.iteritems():
            if len(neighbors) == 1:
                contribution[neighbors[0]] += 1

        # Take the best answer.
        best = (-1, min(initial))
        for u, score in contribution.iteritems():
            if score > best[0] or score == best[0] and u < best[1]:
                best = score, u
        return best[1]
```

**Complexity Analysis**

* Time Complexity: $O(N^2)$, where $N$ is the length of `graph`, as the `graph` is given in adjacent matrix form.

* Space Complexity: $O(N)$.

## Approach 2: Union-Find
**Intuition**

Let `G` be the graph with all the nodes in initial removed. For each component of `G`, either it neighbors `0`, `1`, or `>= 2` nodes from `initial`. The result only changes if there is exactly 1 neighbor from initial, so we need a way to count this.

**Algorithm**

It is clear that we will need to consider components of the graph. A "Disjoint Set Union" (DSU) data structure is ideal for this.

We will skip the explanation of how a DSU structure is implemented. Please refer to https://leetcode.com/problems/redundant-connection/solution/ for a tutorial on DSU.

As above, lets consider the components of G: the graph without any nodes from initial.

Then, for every edge uv in the original graph, where `u` is in `initial` and `v` is not, we can count that the component at `v` of `G` neighbors 1 more infected node.

Now, for each node `u` in `initial`, for each component of `G` it neighbors, if that component would only be infected by u ("uniquely infected"), then the size of that component contributes to the answer for removing `u`.

We take the best possible answer.

```python
class DSU:
    def __init__(self, N):
        self.p = range(N)
        self.sz = [1] * N

    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, x, y):
        xr = self.find(x)
        yr = self.find(y)
        self.p[xr] = yr
        self.sz[yr] += self.sz[xr]

    def size(self, x):
        return self.sz[self.find(x)]


class Solution(object):
    def minMalwareSpread(self, graph, initial):
        N = len(graph)
        initial_set = set(initial)
        clean = [x for x in range(N) if x not in initial_set]

        # clean[u] == 1 if its a node in the graph not in initial.
        dsu = DSU(N)
        for u in clean:
            for v in clean:
                if graph[u][v]:
                    dsu.union(u, v)

        # dsu now represents the components of the graph without
        # any nodes from initial.  Let's call this graph G.
        count = collections.Counter()
        node_to_compo = {}
        for u in initial:
            components = set()
            for v in clean:
                if graph[u][v]:
                    components.add(dsu.find(v))
            node_to_compo[u] = components

            for c in components:
                count[c] += 1

        # For each node u in initial, nodeToCompo.get(u)
        # now has every component from G that u neighbors.

        best = (-1, None) # score, node
        for u, components in node_to_compo.iteritems():
            score = 0
            for c in components:
                if count[c] == 1: #uniquely infected
                    score += dsu.size(c)
            if score > best[0] or score == best[0] and u < best[1]:
                best = (score, u)

        return best[1]
```

**Complexity Analysis**

* Time Complexity: $O(N^2)$, where $N$ is the length of graph, as the `graph` is given in adjacent matrix form.

* Space Complexity: $O(N)$.

# Submissions
---
**Solution 1: (Depth First Search)**
```
Runtime: 1396 ms
Memory Usage: 20.6 MB
```
```python
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        N = len(graph)
        clean = set(range(N)) - set(initial)
        def dfs(u, seen):
            for v, adj in enumerate(graph[u]):
                if adj and v in clean and v not in seen:
                    seen.add(v)
                    dfs(v, seen)

        # For each node u in initial, dfs to find
        # 'seen': all nodes not in initial that it can reach.
        infected_by = {v: [] for v in clean}
        for u in initial:
            seen = set()
            dfs(u, seen)

            # For each node v that was seen, u infects v.
            for v in seen:
                infected_by[v].append(u)

        # For each node u in initial, for every v not in initial
        # that is uniquely infected by u, add 1 to the contribution for u.
        contribution = collections.Counter()
        for v, neighbors in infected_by.items():
            if len(neighbors) == 1:
                contribution[neighbors[0]] += 1

        # Take the best answer.
        best = (-1, min(initial))
        for u, score in contribution.items():
            if score > best[0] or score == best[0] and u < best[1]:
                best = score, u
        return best[1]
```

**Solution 2: (Union-Find)**
```
Runtime: 1096 ms
Memory Usage: 15.1 MB
```
```python
class DSU:
    def __init__(self, N):
        self.p = [_ for _ in range(N)]
        self.sz = [1] * N

    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, x, y):
        xr = self.find(x)
        yr = self.find(y)
        self.p[xr] = yr
        self.sz[yr] += self.sz[xr]

    def size(self, x):
        return self.sz[self.find(x)]

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        N = len(graph)
        initial_set = set(initial)
        clean = [x for x in range(N) if x not in initial_set]

        # clean[u] == 1 if its a node in the graph not in initial.
        dsu = DSU(N)
        for u in clean:
            for v in clean:
                if graph[u][v]:
                    dsu.union(u, v)

        # dsu now represents the components of the graph without
        # any nodes from initial.  Let's call this graph G.
        count = collections.Counter()
        node_to_compo = {}
        for u in initial:
            components = set()
            for v in clean:
                if graph[u][v]:
                    components.add(dsu.find(v))
            node_to_compo[u] = components

            for c in components:
                count[c] += 1

        # For each node u in initial, nodeToCompo.get(u)
        # now has every component from G that u neighbors.

        best = (-1, None) # score, node
        for u, components in node_to_compo.items():
            score = 0
            for c in components:
                if count[c] == 1: #uniquely infected
                    score += dsu.size(c)
            if score > best[0] or score == best[0] and u < best[1]:
                best = (score, u)

        return best[1]
```