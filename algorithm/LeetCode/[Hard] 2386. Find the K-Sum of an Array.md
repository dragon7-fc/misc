2386. Find the K-Sum of an Array

You are given an integer array `nums` and a **positive** integer `k`. You can choose any **subsequence** of the array and sum all of its elements together.

We define the **K-Sum** of the array as the `k`th **largest** subsequence sum that can be obtained (**not** necessarily distinct).

Return the K-Sum of the array.

A **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.

**Note** that the empty subsequence is considered to have a sum of `0`.

 

**Example 1:**
```
Input: nums = [2,4,-2], k = 5
Output: 2
Explanation: All the possible subsequence sums that we can obtain are the following sorted in decreasing order:
- 6, 4, 4, 2, 2, 0, 0, -2.
The 5-Sum of the array is 2.
```

**Example 2:**
```
Input: nums = [1,-2,3,4,-10,12], k = 16
Output: 10
Explanation: The 16-Sum of the array is 10.
```

**Constraints:**

* `n == nums.length`
* `1 <= n <= 10^5`
* `-109 <= nums[i] <= 10^9`
* `1 <= k <= min(2000, 2n)`

# Submissions
---
**Solution 1: (Heap)**
```
Runtime: 1092 ms
Memory Usage: 28.5 MB
```
```python
class Solution:
    def kSum(self, nums: List[int], k: int) -> int:
        maxSum = sum([max(0, num) for num in nums])
        absNums = sorted([abs(num) for num in nums])
        maxHeap = [(-maxSum + absNums[0], 0)]
        ans = [maxSum]
        while len(ans) < k:
            nextSum, i = heapq.heappop(maxHeap)
            heapq.heappush(ans, -nextSum)
            if i + 1 < len(absNums):
                heapq.heappush(maxHeap, (nextSum - absNums[i] + absNums[i + 1], i + 1))
                heapq.heappush(maxHeap, (nextSum + absNums[i + 1], i + 1))
        return ans[0]
```

**Solution 2: (Heap, Decreasing Subsequence Sums)**

    nums = [2,4,-2], k = 5
            2,-2,4
               x
res     6
      [2,4,]
pq         [4,0]
             1    [2,1][4,1]
                    3    2 
                             [0,2][2,2]
                                       [-2,2][0,2]
             ^      ^    ^
           [,4,] [,-2,4]
                      [2,-2,4]

For this problem, we will start with the sum of all elements, and then subtract increasing subsequence sums (generated using the above approach).

For the above example, the initial sum is 10 ([1, 2, 3, 4]). The next sum is 9 ([2, 3, 4]), then 8 ([1, 3, 4]), and so on.

Of course, we need to use max heap instead of min heap.

4. Handling Negatives
The initial maximum sum should include all positive elements.

Excluding a positive element from the subsequence is not much different than including a negative element - both operations decrease the sum.

Therefore, we sort the array by absolute values, and also decrease the sum by abs(nums[i + 1]).

case1
          +        +
        nums[i] nums[i+1]
                   
          +                 
          ^
case2
          +        -
        nums[i] nums[i+1]
                   - 
          +        -          
          ^
case3
          -        +
        nums[i] nums[i+1]
          -        
                            
          ^
case4
          -        -
        nums[i] nums[i+1]
          -        - 
                   -          
          ^

step1: add all positive
step2: try to delete all from abs small

```
Runtime: 40 ms, Beats 87.08%
Memory: 68.13 MB, Beats 56.94%
```
```c++
class Solution {
public:
    long long kSum(vector<int>& nums, int k) {
        sort(begin(nums), end(nums), [](int a, int b){ return abs(a) < abs(b); });
        long long res = accumulate(begin(nums), end(nums), 0LL, [](long long sum, int n){ return sum + max(0, n); });
        priority_queue<pair<long long, int>> pq;
        pq.push({res - abs(nums[0]), 0});
        while(--k) {
            auto [sum, i] = pq.top(); pq.pop();
            if (i + 1 < nums.size()) {
                pq.push({sum - abs(nums[i + 1]), i + 1});
                pq.push({sum + abs(nums[i]) - abs(nums[i + 1]), i + 1});
            }
            res = sum;
        }
        return res;
    }
};
```
