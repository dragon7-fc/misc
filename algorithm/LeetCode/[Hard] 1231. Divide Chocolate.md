1231. Divide Chocolate

You have one chocolate bar that consists of some chunks. Each chunk has its own sweetness given by the array `sweetness`.

You want to share the chocolate with your `K` friends so you start cutting the chocolate bar into `K+1` pieces using `K` cuts, each piece consists of some consecutive chunks.

Being generous, you will eat the piece with the **minimum total sweetness** and give the other pieces to your friends.

Find the **maximum total sweetness** of the piece you can get by cutting the chocolate bar optimally.

 

**Example 1:**
```
Input: sweetness = [1,2,3,4,5,6,7,8,9], K = 5
Output: 6
Explanation: You can divide the chocolate to [1,2,3], [4,5], [6], [7], [8], [9]
```

**Example 2:**
```
Input: sweetness = [5,6,7,8,9,1,2,3,4], K = 8
Output: 1
Explanation: There is only one way to cut the bar into 9 pieces.
```

**Example 3:**
```
Input: sweetness = [1,2,2,1,2,2,1,2,2], K = 2
Output: 5
Explanation: You can divide the chocolate to [1,2,2], [1,2,2], [1,2,2]
```

**Constraints:**

* `0 <= K < sweetness.length <= 10^4`
* `1 <= sweetness[i] <= 10^5`

# Submissions
---
**Solution 1: (Binary Search, Greedy)**

**Explanation**
We want to maximize the minimum sweetness.
Binary search the result between 1 and 10^9.

Don'e explain binary search too much again and again.
Please find more related explanation in More.
Also will explain it more in details on youtube lee215.

* Time $O(Nlog(10^9))$
* Space $O(1)$

**More Good Binary Search Problems**
Here are some similar binary search problems.
Also find more explanations.
Good luck and have fun.

* 1231. Divide Chocolate
* 1011. Capacity To Ship Packages In N Days
* 875. Koko Eating Bananas
* 774. Minimize Max Distance to Gas Station
* 410. Split Array Largest Sum

```
Runtime: 264 ms
Memory Usage: 15.2 MB
```
```python
class Solution:
    def maximizeSweetness(self, sweetness: List[int], K: int) -> int:
        left, right = 1, sum(sweetness) // (K + 1)
        while left < right:
            mid = (left + right + 1) // 2
            cur = cuts = 0
            for a in sweetness:
                cur += a
                if cur >= mid:
                    cuts += 1
                    cur = 0
            if cuts > K:
                left = mid
            else:
                right = mid - 1
        return right
```

**Solution 2: (binary Search, upper bound)**

    sweetness = [1,2,3,4,5,6,7,8,9], k = 5
                 ----- --- - - - -

    1 2 3 4 5 6 7 8 9
    l       m       r
              l m   r
              lrm   
              r lx
ans         x x
              ^
```
Runtime: 3 ms, Beats 68.86%
Memory: 19.00 MB, Beats 97.60%
```
```c++
class Solution {
public:
    int maximizeSweetness(vector<int>& sweetness, int k) {
        int a = accumulate(begin(sweetness), end(sweetness), 0), b, ans;
        int left = 1, right = a / (k + 1), mid, ck;
        while (left <= right) {
            mid = left + (right - left) / 2;
            ck = 0;
            b = 0;
            for (auto &s: sweetness) {
                b += s;
                if (b >= mid) {
                    ck += 1;
                    b = 0;
                }
            }
            if (ck < k + 1) {
                right = mid - 1;
            } else {
                ans = mid;
                left = mid + 1;
            }
        }
        return ans;
    }
};
```
