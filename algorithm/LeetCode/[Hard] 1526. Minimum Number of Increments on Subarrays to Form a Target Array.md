1526. Minimum Number of Increments on Subarrays to Form a Target Array

Given an array of positive integers `target` and an array `initial` of same size with all zeros.

Return the minimum number of operations to form a `target` array from `initial` if you are allowed to do the following operation:

* Choose any subarray from `initial` and increment each value by one.

The answer is guaranteed to fit within the range of a 32-bit signed integer.
 

**Example 1:**
```
Input: target = [1,2,3,2,1]
Output: 3
Explanation: We need at least 3 operations to form the target array from the initial array.
[0,0,0,0,0] increment 1 from index 0 to 4 (inclusive).
[1,1,1,1,1] increment 1 from index 1 to 3 (inclusive).
[1,2,2,2,1] increment 1 at index 2.
[1,2,3,2,1] target array is formed.
```

**Example 2:**
```
Input: target = [3,1,1,2]
Output: 4
Explanation: (initial)[0,0,0,0] -> [1,1,1,1] -> [1,1,1,2] -> [2,1,1,2] -> [3,1,1,2] (target).
```

**Example 3:**
```
Input: target = [3,1,5,4,2]
Output: 7
Explanation: (initial)[0,0,0,0,0] -> [1,1,1,1,1] -> [2,1,1,1,1] -> [3,1,1,1,1] 
                                  -> [3,1,2,2,2] -> [3,1,3,3,2] -> [3,1,4,4,2] -> [3,1,5,4,2] (target).
```

**Example 4:**
```
Input: target = [1,1,1,1]
Output: 1
```

**Constraints:**

* `1 <= target.length <= 10^5`
* `1 <= target[i] <= 10^5`

# Submissions
---
**Solution 1: (Greedy)**

Whenever the current element a is bigger than the previous element, we need at lease a - pre operations to make this difference.

* We accumulate the total number of the operations,
* this result is a lower bound and it's feasible.

```
Runtime: 1140 ms
Memory Usage: 24.5 MB
```
```python
class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        res = pre = 0
        for a in target:
            res += max(a - pre, 0)
            pre = a
        return res
```

**Solution 2: (Greedy)**
```
Runtime: 320 ms
Memory Usage: 73.4 MB
```
```c++
class Solution {
public:
    int minNumberOperations(vector<int>& target) {
        int res = 0, pre = 0;
        for (int a: target) {
            res += max(a - pre, 0);
            pre = a;
        }
        return res;
    }
};
```

**Solution 3: (Mono Stack)**
```
Runtime: 23 ms, Beats 7.05%
Memory: 78.40 MB, Beats 15.37%
```
```c++
class Solution {
public:
    int minNumberOperations(vector<int>& target) {
        int ans = 0;
        stack<int> stk;
        for (auto &num: target) {
            if (stk.size() && stk.top() >= num) {
                ans += stk.top() - num;
                stk.pop();
                while (stk.size() && stk.top() >= num) {
                    stk.pop();
                }
            }
            stk.push(num);
        }
        ans += stk.top();
        return ans;
    }
};
```

**Solution 4: (Difference Array)**
```
Runtime: 0 ms, Beats 100.00%
Memory: 77.05 MB, Beats 28.91%
```
```c++
class Solution {
public:
    int minNumberOperations(vector<int>& target) {
        int n = target.size();
        int ans = target[0];
        for (int i = 1; i < n; ++i) {
            ans += max(target[i] - target[i - 1], 0);
        }
        return ans;
    }
};
```
