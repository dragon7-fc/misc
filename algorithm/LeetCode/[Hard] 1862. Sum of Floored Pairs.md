1862. Sum of Floored Pairs

Given an integer array `nums`, return the sum of `floor(nums[i] / nums[j])` for all pairs of indices `0 <= i, j < nums.length `in the array. Since the answer may be too large, return it modulo `10^9 + 7`.

The f`loor()` function returns the integer part of the division.

 

**Example 1:**
```
Input: nums = [2,5,9]
Output: 10
Explanation:
floor(2 / 5) = floor(2 / 9) = floor(5 / 9) = 0
floor(2 / 2) = floor(5 / 5) = floor(9 / 9) = 1
floor(5 / 2) = 2
floor(9 / 2) = 4
floor(9 / 5) = 1
We calculate the floor of the division for every pair of indices in the array then sum them up.
```

**Example 2:**
```
Input: nums = [7,7,7,7,7,7,7]
Output: 49
```

**Constraints:**

* `1 <= nums.length <= 10^5`
* `1 <= nums[i] <= 10^5`

# Submissions
---
**Solution 1: (Math, Prefix Sum)**
```
Runtime: 1828 ms
Memory Usage: 33.1 MB
```
```python
class Solution:
    def sumOfFlooredPairs(self, nums: List[int]) -> int:
        incs, counter=[0]*(max(nums)+1), Counter(nums)            # To store all the quotients increases; counter
        for num in counter:                                       # Loop over all the divisors
            for j in range(num, len(incs), num):                  # Loop over all the possible dividends where the quotient increases
                incs[j] += counter[num]                           # Increment the increases in quotients
        quots=list(accumulate(incs))                              # Accumulate the increases to get the sum of quotients
        return sum([quots[num] for num in nums]) % 1_000_000_007  # Sum up all the quotients for all the numbers in the list.
```

**Solution 2: (Math, Prefix Sum)**

nums = [2,5,9]
cnt
2   1
5   1
9   1
sieve
2   1
  4   1
  6   1
  8   1
5   1
  10  1
9   1

sieve
    v     v       v
0 1 2 3 4 5 6 7 8 9
0 0 1 1 2 3 4 4 5 6

nums = [7,7,7,7,7,7,7]
cnt
7   7
sieve
7   7
  14    7
  21    7

sieve
              v
0 1 2 3 4 5 6 7
0 0 0 0 0 0 0 7
```
Runtime: 40 ms, Beats 86.00%
Memory: 102.72 MB, Beats 95.00%
```
```c++
class Solution {
    long long cnt[100001] = {}, sieve[100001] = {};
public:
    int sumOfFlooredPairs(vector<int>& nums) {
        int mx = *max_element(begin(nums), end(nums));
        for (auto &num : nums) {
            cnt[num] += 1;
        }
        for (auto a = 1; a <= mx; a ++) {
            if (cnt[a]) {
                for (auto f = 1; a * f <= mx; f ++) {
                    sieve[a * f] += cnt[a];
                }
            }
        }
        partial_sum(begin(sieve), end(sieve), begin(sieve));
        return accumulate(begin(nums), end(nums), 0, [&](int sum, int a) { return (sum + sieve[a]) % 1000000007; });
    }
};
```
