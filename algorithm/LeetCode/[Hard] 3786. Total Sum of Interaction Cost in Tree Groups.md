3786. Total Sum of Interaction Cost in Tree Groups

You are given an integer `n` and an undirected tree with `n` nodes numbered from 0 to `n - 1`. This is represented by a 2D array `edges` of length `n - 1`, where `edges[i] = [ui, vi]` indicates an undirected edge between nodes `ui` and `vi`.

You are also given an integer array `group` of length `n`, where `group[i]` denotes the group label assigned to node `i`.

Two nodes `u` and `v` are considered part of the same group if `group[u] == group[v]`.

The **interaction cost** between `u` and `v` is defined as the number of edges on the unique path connecting them in the tree.

Return an integer denoting the **sum** of interaction costs over all **unordered** pairs `(u, v)` with `u != v` such that `group[u] == group[v]`.

 

**Example 1:**
```
Input: n = 3, edges = [[0,1],[1,2]], group = [1,1,1]

Output: 4

Explanation:
```
![3786_screenshot-2025-09-24-at-50538-pm.png](img/3786_screenshot-2025-09-24-at-50538-pm.png)
```
All nodes belong to group 1. The interaction costs between the pairs of nodes are:

Nodes (0, 1): 1
Nodes (1, 2): 1
Nodes (0, 2): 2
Thus, the total interaction cost is 1 + 1 + 2 = 4.
```

**Example 2:**
```
Input: n = 3, edges = [[0,1],[1,2]], group = [3,2,3]

Output: 2

Explanation:

Nodes 0 and 2 belong to group 3. The interaction cost between this pair is 2.
Node 1 belongs to a different group and forms no valid pair. Therefore, the total interaction cost is 2.
```

**Example 3:**
```
Input: n = 4, edges = [[0,1],[0,2],[0,3]], group = [1,1,4,4]

Output: 3

Explanation:
```
![3786_screenshot-2025-09-24-at-51312-pm.png](img/3786_screenshot-2025-09-24-at-51312-pm.png)
```
Nodes belonging to the same groups and their interaction costs are:

Group 1: Nodes (0, 1): 1
Group 4: Nodes (2, 3): 2
Thus, the total interaction cost is 1 + 2 = 3.
```

**Example 4:**
```
Input: n = 2, edges = [[0,1]], group = [9,8]

Output: 0

Explanation:

All nodes belong to different groups and there are no valid pairs. Therefore, the total interaction cost is 0.
```
 

**Constraints:**

* `1 <= n <= 10^5`
* `edges.length == n - 1`
* `edges[i] = [ui, vi]`
* `0 <= ui, vi <= n - 1`
* `group.length == n`
* `1 <= group[i] <= 20`
* The input is generated such that `edges` represents a valid tree.

# Submissions
---
**Solution 1: (DFS)**

__Approach__
Build the tree

Convert the edge list into an adjacency list for DFS traversal
Precompute group totals

Count how many nodes belong to each group (group labels are in 1..20)
DFS with subtree counting

Perform DFS from an arbitrary root (node 0)
For each node, maintain an array cnt[g] = number of nodes of group g in its subtree
Edge contribution calculation

When returning from a child subtree:
For each group g, compute:
c[g] × (tot[g] - c[g])
Add it to the global answer
Accumulate subtree counts

Merge child subtree group counts into the current node
This ensures each edge is processed exactly once, making the solution efficient.

__Complexity__
Time Complexity: O(n × 20)
Each node processes at most 20 group labels during DFS.

Space Complexity: O(n × 20)
Due to recursion stack and per-node group count arrays.

    n = 4, edges = [[0,1],[0,2],[0,3]], group = [1,1,4,4]

                 0 (1)
            /    |     \
1:         1
4:               1      1
ans       +1    +1     +1
          1 (1)  2 (4)  3 (4)
          1: 1   4: 1   4: 1 
tot
1: 2
4: 2

```
Runtime: 800 ms, Beats 41.67%
Memory: 421.48 MB, Beats 25.00%
```
```c++
class Solution {
    long long ans = 0;
    array<int, 21> solve(int u, int p, vector<vector<int>> &G, vector<int> &tot, vector<int> &grp) {
        array<int, 21> cur{};
        cur[grp[u]] = 1;
        for(int x: G[u]) {
            if(x == p) continue;
            auto c = solve(x, u, G, tot, grp);
            for(int i = 1; i <= 20; i++) {
                if(tot[i]) 
                    ans += 1L * c[i] * (tot[i] - c[i]);
                cur[i] += c[i];
            }
        }
        return cur;
    }
public:
    long long interactionCosts(int n, vector<vector<int>>& edges, vector<int>& group) {
        vector<vector<int>> G(n);
        for(auto x: edges) {
            G[x[0]].push_back(x[1]);
            G[x[1]].push_back(x[0]);
        }
        vector<int> tot(21, 0);
        for(int x: group) tot[x]++;
        solve(0, -1, G, tot, group);
        return ans;
    }
};
```
