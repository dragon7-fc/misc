3734. Lexicographically Smallest Palindromic Permutation Greater Than Target

You are given two strings `s` and `target`, each of length `n`, consisting of lowercase English letters.

Return the **lexicographically smallest** string that is both a **palindromic permutation** of `s` and strictly greater than `target`. If no such permutation exists, return an empty string.

 

**Example 1:**
```
Input: s = "baba", target = "abba"

Output: "baab"

Explanation:

The palindromic permutations of s (in lexicographical order) are "abba" and "baab".
The lexicographically smallest permutation that is strictly greater than target is "baab".
```

**Example 2:**
```
Input: s = "baba", target = "bbaa"

Output: ""

Explanation:

The palindromic permutations of s (in lexicographical order) are "abba" and "baab".
None of them is lexicographically strictly greater than target. Therefore, the answer is "".
```

**Example 3:**
```
Input: s = "abc", target = "abb"

Output: ""

Explanation:

s has no palindromic permutations. Therefore, the answer is "".
```

**Example 4:**
```
Input: s = "aac", target = "abb"

Output: "aca"

Explanation:

The only palindromic permutation of s is "aca".
"aca" is strictly greater than target. Therefore, the answer is "aca".
```

**Constraints:**

* `1 <= n == s.length == target.length <= 300`
* `s` and `target` consist of only lowercase English letters.

# Submissions
---
**Solution 1: (Backtracking)**

__Intuition__
The goal is to find the lexicographically smallest palindromic permutation of a given string s that is greater than a given target string of the same length.

A palindrome is symmetric, so once we decide on the first half of the palindrome (and possibly the middle character if the length is odd), the rest is automatically determined.

Therefore, instead of generating all permutations, we can construct only the first half using backtracking, ensuring that the resulting palindrome is both valid and lexicographically minimal but still greater than the target.

This problem builds on the logic of problem 3720 on LeetCode

__Approach__
Count frequencies of all characters in s.
1.1 A palindrome can exist only if at most one character has an odd count (that will be the middle character if the length is odd).

1.2 Half all counts since the palindrome is mirrored; we only need to construct the first half.

Backtracking to build the first half (func):
2.1 Maintain a recursive path (path) representing the first half.

2.2 At each recursion step, try adding characters from 'a' to 'z' that are still available (cnt[c] > 0).

2.3 Use a boolean big to indicate whether the current prefix is already lexicographically greater than the corresponding prefix in target.

2.4 If big == false, only consider characters >= target[i] at position i.

2.5 Once we use a character greater than target[i], we set big = true for all deeper recursion.

Construct the full palindrome:
3.1 Once path.size() == n/2, mirror it to create the second half.

3.2 If n is odd, insert the middle character mid between the halves.

3.3 Compare the constructed palindrome with target; if it’s greater, record it as the answer.

Early stopping:

As soon as one valid palindrome greater than target is found, the recursion stops (if (!ans.empty()) return true;).

__Complexity__
Time complexity:
The theoretical upper bound is
O(26^{n/2})
due to recursion, but in practice:

The recursion prunes heavily once a valid palindrome is found.

Each recursive level tries only a few valid characters.
Hence, it runs efficiently even for n≤300.

Space complexity: O(n)

```
Runtime: 7 ms, Beats 17.39%
Memory: 12.26 MB, Beats 13.04%
```
```c++
class Solution {
     string ans;

    bool func(vector<char>& path,vector<int>& cnt,string & target, bool big,char mid,int n){
        if(!ans.empty())return true;
        int half=n/2;
        if(path.size()==half){
            string left(path.begin(),path.end());
            string right=left;
            reverse(right.begin(),right.end());
            string pal="";
            if(n%2!=0)pal=left+mid+right;
            else pal=left+right;
            if(pal>target){
                ans=pal;
                return true;
            }
            return false;
        }
        int i=path.size();
        for(int c=0;c<26;c++){
            if(cnt[c]==0)continue;
            if(!big && c+'a'<target[i])continue;

            path.push_back(c+'a');
            cnt[c]--;
            bool newbig=big || (c+'a' >target[i]);
            if(func(path,cnt,target,newbig,mid,n))return true;
            path.pop_back();
            cnt[c]++;
        }
        return false;
    }
public:
    string lexPalindromicPermutation(string s, string target) {
        vector<int>cnt(26,0);
        for(char c:s)cnt[c-'a']++;
        ans="";
        int odd=0;
        char mid=0;
        for(int i=0;i<26;i++){
            if(cnt[i]%2){
            odd++;
            mid='a'+i ;   
            }
            cnt[i]/=2;
        }
        if(odd>1)return "";
        vector<char>path;
        func(path,cnt,target,false,mid,s.size());
        return ans;
    }
};
```
