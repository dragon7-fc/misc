3791. Number of Balanced Integers in a Range

You are given two integers `low` and `high`.

An integer is called **balanced** if it satisfies both of the following conditions:

* It contains **at least** two digits.
* The **sum of digits at even positions** is equal to the **sum of digits at odd positions** (the leftmost digit has position 1).

Return an integer representing the number of balanced integers in the range `[low, high]` (both inclusive).

 

**Example 1:**
```
Input: low = 1, high = 100

Output: 9

Explanation:

The 9 balanced numbers between 1 and 100 are 11, 22, 33, 44, 55, 66, 77, 88, and 99.
```

**Example 2:**
```
Input: low = 120, high = 129

Output: 1

Explanation:

Only 121 is balanced because the sum of digits at even and odd positions are both 2.
```

**Example 3:**
```
Input: low = 1234, high = 1234

Output: 0

Explanation:

1234 is not balanced because the sum of digits at odd positions (1 + 3 = 4) does not equal the sum at even positions (2 + 4 = 6).
```
 

**Constraints:**

* `1 <= low <= high <= 10^15`

# Submissions
---
**Solution 1: (Digit DP)**

// 16 * 2 * 2 * 200
// states = 128 * 100 transitions = 10
// states * transitions = 1.28 * 1e5

// total 15 digits
// 7 odd numbers --> 7 * 9 = 63
// 8 even numbers --> 8 * 9 = 72
// 63 + 72 = 135

```
Runtime: 31 ms, Beats -%
Memory: 9.01 MB, Beats 100.00%
```
```c++
class Solution {
    int OFFSET = 63;
    string L, R;
    int len;
 
    long long dp[16][2][2][135];
    long long solve (int idx, int lo, int hi, int diff) {
        if (idx == len) {
            return (diff == 0);
        }

        int k = diff + OFFSET;

        if (dp[idx][lo][hi][k] != -1) {
            return dp[idx][lo][hi][k];
        }

        int loLim = 0, hiLim = 9;
        if (lo == 1) {
            loLim = L[idx] - '0';
        }

        if (hi == 1) {
            hiLim = R[idx] - '0';
        }

        long long ans = 0;
        for (int i = loLim; i <= hiLim; i++) {
            int newLo = lo, newHi = hi;

            if (i != L[idx] - '0') {
                newLo = 0;
            }

            if (i != R[idx] - '0') {
                newHi = 0;
            }

            int newDiff = diff;
            if (idx % 2 == 0) {
                newDiff += i;
            } else {
                newDiff -= i;
            }

            ans += solve(idx + 1, newLo, newHi, newDiff);
        }

        return dp[idx][lo][hi][k] = ans;
    }
public:
    long long countBalanced(long long low, long long high) {
        L = to_string(low);
        R = to_string(high);
        len = R.size();
        int diff = len - L.size();
        while (diff--) {
            L = '0' + L;
        }

        memset(dp, -1, sizeof(dp));
        return solve(0, 1, 1, 0);
    }
};
```
