2472. Maximum Number of Non-overlapping Palindrome Substrings

You are given a string `s` and a positive integer `k`.

Select a set of **non-overlapping** substrings from the string `s` that satisfy the following conditions:

* The **length** of each substring is **at least** `k`.
* Each substring is a **palindrome**.

Return the **maximum** number of substrings in an optimal selection.

A **substring** is a contiguous sequence of characters within a string.

 

**Example 1:**
```
Input: s = "abaccdbbd", k = 3
Output: 2
Explanation: We can select the substrings underlined in s = "abaccdbbd". Both "aba" and "dbbd" are palindromes and have a length of at least k = 3.
It can be shown that we cannot find a selection with more than two valid substrings.
```

**Example 2:**
```
Input: s = "adbcda", k = 2
Output: 0
Explanation: There is no palindrome substring of length at least 2 in the string.
```

**Constraints:**

* `1 <= k <= s.length <= 2000`
* `s` consists of lowercase English letters.

# Submissions
---
**Solution 1: (Palindromic Substrings + Non-overlapping Intervals)**
```
Runtime: 113 ms
Memory: 14.4 MB
```
```python
class Solution:
    def maxPalindromes(self, s: str, k: int) -> int:
        N, intervals, last, ans = len(s), [], -inf, 0
        for center in range(2 * N - 1):
            left = center // 2
            right = left + center % 2
            while left >= 0 and right < N and s[left] == s[right]:
                if right + 1 - left >= k: 
                    intervals.append((left, right + 1))
                    break
                left -= 1
                right += 1
        for x, y in intervals:
            if x >= last:
                last = y
                ans += 1
            else:
                if y < last: last = y
        return ans
```

**Solution 2: (Palindromic Substrings + Non-overlapping Intervals)**
```
Runtime: 6 ms
Memory: 7.6 MB
```
```c++
class Solution {
public:
    int maxPalindromes(string s, int k) {
        int n = s.size(), last = INT_MIN, ans = 0;
        vector<vector<int>> intervals;
        for (int center = 0; center < 2 * n; center++) {
            int left = center / 2;
            int right = left + center % 2;
            while (left >= 0 && right < n && s[left] == s[right]) {
                if (right + 1 - left >= k) {
                    intervals.push_back({left, right + 1});
                    break;
                }
                left--; right++;
            }
        }
        for (vector<int>& v: intervals) {
            if (v[0] >= last) {
                last = v[1];
                ans++;
            }
            else
                if (v[1] < last)
                    last = v[1];
        }
        return ans;
    }
};
```

**Solution 3: (DP Bottom-Up)**

    dp[i] = max non-overlap palidrom substrings of s[0..i]

```
Runtime: 33 ms, Beats 73.49%
Memory: 9.28 MB, Beats 93.02%
```
```c++
class Solution {
public:
    int maxPalindromes(string s, int k) {
        int n = s.length(), i, j, ck;
        vector<int> dp(n);
        for (i = 0; i < n; i ++) {
            if (i) {
                dp[i] = max(dp[i], dp[i - 1]);
            }
            ck = 0;
            while (i - ck >= 0 && i + ck < n && s[i - ck] == s[i + ck]) {
                if (1 + 2 * ck >= k) {
                    dp[i + ck] = max(dp[i + ck], (i - ck - 1 >= 0 ? dp[i - ck - 1] : 0) + 1);
                }
                ck += 1;
            }
            if (i + 1 < n && s[i] == s[i + 1]) {
                j = i + 1;
                ck = 0;
                while (i - ck >= 0 && j + ck < n && s[i - ck] == s[j + ck]) {
                    if (2 + 2 * ck >= k) {
                        dp[j + ck] = max(dp[j + ck], (i - ck - 1 >= 0 ? dp[i - ck - 1] : 0) + 1);
                    }
                    ck += 1;
                }
            }
        }
        return dp[n - 1];
    }
};
```
