3772. Maximum Subgraph Score in a Tree

You are given an **undirected tree** with `n` nodes, numbered from 0 to `n - 1`. It is represented by a 2D integer array `edges` of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.

You are also given an integer array `good` of length `n`, where `good[i]` is `1` if the `i`th node is good, and `0` if it is bad.

Define the **score** of a **subgraph** as the number of good nodes minus the number of bad nodes in that subgraph.

For each node `i`, find the maximum possible score among all **connected subgraphs** that contain node `i`.

Return an array of n integers where the `i`th element is the **maximum** score for node `i`.

A **subgraph** is a graph whose vertices and edges are subsets of the original graph.

A **connected subgraph** is a subgraph in which every pair of its vertices is reachable from one another using only its edges.

 

**Example 1:**

![Tree Example 1](img/3772_tree1fixed.png)
```
Input: n = 3, edges = [[0,1],[1,2]], good = [1,0,1]

Output: [1,1,1]

Explanation:

Green nodes are good and red nodes are bad.
For each node, the best connected subgraph containing it is the whole tree, which has 2 good nodes and 1 bad node, resulting in a score of 1.
Other connected subgraphs containing a node may have the same score.
```

**Example 2:**

![Tree Example 2](img/3772_tree2.png)
```
Input: n = 5, edges = [[1,0],[1,2],[1,3],[3,4]], good = [0,1,0,1,1]

Output: [2,3,2,3,3]

Explanation:

Node 0: The best connected subgraph consists of nodes 0, 1, 3, 4, which has 3 good nodes and 1 bad node, resulting in a score of 3 - 1 = 2.
Nodes 1, 3, and 4: The best connected subgraph consists of nodes 1, 3, 4, which has 3 good nodes, resulting in a score of 3.
Node 2: The best connected subgraph consists of nodes 1, 2, 3, 4, which has 3 good nodes and 1 bad node, resulting in a score of 3 - 1 = 2.
```
**Example 3:**

![Tree Example 3](img/3772_tree3.png)
```
Input: n = 2, edges = [[0,1]], good = [0,0]

Output: [-1,-1]

Explanation:

For each node, including the other node only adds another bad node, so the best score for both nodes is -1.
```
 

**Constraints:**

* `2 <= n <= 10^5`
* `edges.length == n - 1`
* `edges[i] = [ai, bi]`
* `0 <= ai, bi < n`
* `good.length == n`
* `0 <= good[i] <= 1`
* The input is generated such that edges represents a valid tree.

# Submissions
---
**Solution 1: (2x DFS)**

__Intuition__
If we relabel the bad nodes from 0 to -1, the problem becomes about finding for each node the subgraph with the maximum sum containing it.

__Approach__
One approach is to root the tree arbitrarily and find for each node the best sum of contributions from each of its subtrees and its parent.

We can build the solution in two steps.

In the first step we can compute the best contribution from each subtree.

In the second step we can propagate best contributions from parents to children, while taking care to avoid adding the contribution from a child itself.

In the second step we also have to make sure to propagate contributions from further up in the tree.

Since we're trying to maximize the sum, it is optimal to add up all possible positive contributions and ignore negative ones.

So, for each node the answer will be it's own value plus all positive contributions from its children and parent.

__Complexity__
Time complexity: O(n)
Space complexity: O(n)

```
Runtime: 271 ms, Beats 87.03%
Memory: 383.36 MB, Beats 93.21%
```
```c++
class Solution {
public:
    vector<int> maxSubgraphScore(int n, vector<vector<int>>& edges, vector<int>& good) {
        for (int i = 0; i < n; ++i) {
            if (good[i] == 0) {
                good[i] = -1;
            }
        }
        vector<int> subtree_max(n);
        
        vector<vector<int>> adj(n);
        for (vector<int>& edge : edges) {
            adj[edge[0]].push_back(edge[1]);
            adj[edge[1]].push_back(edge[0]);
        }

        auto dfs1 = [&](auto& dfs1, int curr, int par) -> int {
            int sc = good[curr];
            for (int next : adj[curr]) {
                if (next != par) {
                    sc += max(dfs1(dfs1, next, curr), 0);
                }
            }
            return subtree_max[curr] = sc;
        };

        dfs1(dfs1, 0, -1);

        auto dfs2 = [&](auto& dfs2, int curr, int par, int from_par) -> void{
            if (from_par >= 0) {
                subtree_max[curr] += from_par;
            }
            int pos = from_par >= 0 ? from_par : 0;
            for (int next : adj[curr]) {
                if (next != par) {
                    if (subtree_max[next] > 0) {
                        pos += subtree_max[next];
                    }
                }
            }

            for (int next : adj[curr]) {
                if (next != par) {
                    int tmp = subtree_max[next];
                    if (subtree_max[next] > 0) {
                        pos -= subtree_max[next];
                    }
                    dfs2(dfs2, next, curr, pos + good[curr]);
                    if (tmp > 0) {
                        pos += tmp;
                    }
                }
            }
        };
        dfs2(dfs2, 0, -1, 0);

        return subtree_max;
    }
};
```
