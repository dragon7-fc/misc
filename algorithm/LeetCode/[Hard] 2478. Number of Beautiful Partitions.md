2478. Number of Beautiful Partitions

You are given a string `s` that consists of the digits `'1'` to `'9'` and two integers `k` and `minLength`.

A partition of `s` is called beautiful if:

* `s` is partitioned into `k` non-intersecting substrings.
* Each substring has a length of at least `minLength`.
* Each substring starts with a **prime** digit and ends with a **non-prime** digit. Prime digits are `'2'`, `'3'`, `'5'`, and `'7'`, and the rest of the digits are non-prime.

Return the number of **beautiful** partitions of `s`. Since the answer may be very large, return it **modulo** `10^9 + 7`.

A substring is a contiguous sequence of characters within a string.

 

**Example 1:**
```
Input: s = "23542185131", k = 3, minLength = 2
Output: 3
Explanation: There exists three ways to create a beautiful partition:
"2354 | 218 | 5131"
"2354 | 21851 | 31"
"2354218 | 51 | 31"
```

**Example 2:**
```
Input: s = "23542185131", k = 3, minLength = 3
Output: 1
Explanation: There exists one way to create a beautiful partition: "2354 | 218 | 5131".
```

**Example 3:**
```
Input: s = "3312958", k = 3, minLength = 1
Output: 1
Explanation: There exists one way to create a beautiful partition: "331 | 29 | 58".
```

**Constraints:**

* `1 <= k, minLength <= s.length <= 1000`
* `s` consists of the digits `'1'` to `'9'`.

# Submissions
---
**Solution 1: (DP with optimization)**
```
Runtime: 8652 ms
Memory: 29.6 MB
```
```python
class Solution:
    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:
        n = len(s)
        primes = ['2', '3', '5', '7']
        
        # pruning
        if k * minLength > n or s[0] not in primes or s[-1] in primes:
            return 0
        
        # posible starting indexes of a new partition
        ids = [0]
        for i in range(n-1):
            if s[i] not in primes and s[i+1] in primes:
                ids.append(i+1)
        m = len(ids)

        @cache
        # dp(i, kk) means number of ways to partition s[ids[i]:n] into kk partitions
        def dp(i, kk):
            
            # kk==1: last remaining partition, needs to have length >= l
            if kk == 1:
                return 1 if ids[i]+minLength-1 <= n-1 else 0
            res = 0
            
            # iterate possible starting index of next partition
            for j in range(i+1, m-kk+2):
                if ids[j]-ids[i] >= minLength:
                    res += dp(j, kk-1)
            
            return res % (10**9+7)
        
        return dp(0, k)
```

**Solution 2: (DP Bottom-Up, O(n^2 * k))**
```
Runtime: 1738 ms, Beats 10.35%
Memory: 71.32 MB, Beats 24.14%
```
```c++
class Solution {
public:
    int beautifulPartitions(string s, int k, int minLength) {
        int n = s.size(), i, ck, MOD = 1e9 + 7;
        vector<vector<long long>> dp(n + 1, vector<long long>(k + 1));
        vector<vector<int>> pre(10);
        dp[0][0] = 1;
        for (i = 0; i < n; i ++) {
            if (s[i] == '2' || s[i] == '3' || s[i] == '5' || s[i] == '7') {
                pre[s[i] - '0'].push_back(i);
            } else {
                for (auto &p: {2, 3, 5, 7}) {
                    for (auto j: pre[p]) {
                        if (i - j < minLength - 1) {
                            break;
                        }
                        for (ck = 0; ck < k; ck ++) {
                            dp[i + 1][ck + 1] += dp[j][ck];
                            dp[i + 1][ck + 1] %= MOD;
                        }
                    }
                }
            }
        }
        return dp[n][k];
    }
};
```

**Solution 3: (DP Bottom-Up, O(n^2 * k))**
```
Runtime: 1762 ms, Beats 10.35%
Memory: 71.07 MB, Beats 31.03%
```
```c++
class Solution {
public:
    int beautifulPartitions(string s, int k, int minLength) {
        int n = s.size(), i, j, ck, MOD = 1e9 + 7;
        vector<vector<long long>> dp(n + 1, vector<long long>(k + 1));
        dp[0][0] = 1;
        for (j = 0; j < n; j ++) {
            if (s[j] != '2' && s[j] != '3' && s[j] != '5' && s[j] != '7') {
                for (i = 0; i <= j - minLength + 1; i ++) {
                    if (s[i] == '2' || s[i] == '3' || s[i] == '5' || s[i] == '7') {
                        for (ck = 0; ck < k; ck ++) {
                            dp[j + 1][ck + 1] += dp[i][ck];
                            dp[j + 1][ck + 1] %= MOD;
                        }
                    }
                }
            }
        }
        return dp[n][k];
    }
};
```
**Solution 4: (DP Bottom-Up, Prefix Sum, O(n * k))**

                       v              v         v  
s = "2    3     5    4    2    1    8    5    1    3    1", k = 3, minLength = 2
dp                                                       
                                                        -
                                                   ------
                                              -----------
                                         ----------------
0    1    1     1    1    1    1    1    1    1    1    1
                                         ------    ------
                                         ----------------
1         3     3    3    2    2    2    1    1
                                    ^
     --------------------------------   -------   --------
                                    ^
2         3     3    3    1    1    1
                     v               
     -----------------    ---------------------   --------
     -----------------    -----------   ------------------

```
Runtime: 103 ms, Beats 60.46%
Memory: 71.09 MB, Beats 30.23%
```
```c++
class Solution {
    string primes = "2357";
    bool isPrime(char c) {
        return primes.find(c) != string::npos;
    }
public:
    int beautifulPartitions(string s, int k, int minLength) {
        int n = s.size(), mod = 1e9 + 7;
        if (!isPrime(s[0]) || isPrime(s[n - 1])) {
            return false;
        }
        vector<vector<long>> dp(n, vector<long>(k + 1));
        for (int i = 0; i < n; i ++) {
            dp[i][0] = 1;
        }
        for (int i = n - minLength - 1; i >= minLength - 1; i--) {
            for (int j = 1; j < k; j ++) {
                dp[i][j] = dp[i + 1][j];
                // can cut here
                if (!isPrime(s[i]) && isPrime(s[i + 1])) {
                    dp[i][j] = (dp[i][j] + dp[i + minLength][j - 1]) % mod;
                }
            }
        }

        return dp[minLength - 1][k - 1];
    }
};
```
