3777. Minimum Deletions to Make Alternating Substring

You are given a string `s` of length `n` consisting only of the characters `'A'` and `'B'`.

You are also given a 2D integer array `queries` of length `q`, where each `queries[i]` is one of the following:

* `[1, j]`: Flip the character at index `j` of s i.e. `'A'` changes to `'B'` (and vice versa). This operation mutates s and affects subsequent queries.
* `[2, l, r]`: Compute the minimum number of character deletions required to make the substring `s[l..r]` alternating. This operation does not modify `s`; the length of `s` remains `n`.

A **substring** is **alternating** if no two **adjacent** characters are equal. A substring of length 1 is always alternating.

Return an integer array `answer`, where `answer[i]` is the result of the `i`th query of type `[2, l, r]`.

 

**Example 1:**
```
Input: s = "ABA", queries = [[2,1,2],[1,1],[2,0,2]]

Output: [0,2]

Explanation:

i	queries[i]	j	l	r	s before query	s[l..r]	Result	Answer
0	[2, 1, 2]	-	1	2	"ABA"	"BA"	Already alternating	0
1	[1, 1]	1	-	-	"ABA"	-	Flip s[1] from 'B' to 'A'	-
2	[2, 0, 2]	-	0	2	"AAA"	"AAA"	Delete any two 'A's to get "A"	2
Thus, the answer is [0, 2].
```

**Example 2:**
```
Input: s = "ABB", queries = [[2,0,2],[1,2],[2,0,2]]

Output: [1,0]

Explanation:

i	queries[i]	j	l	r	s before query	s[l..r]	Result	Answer
0	[2, 0, 2]	-	0	2	"ABB"	"ABB"	Delete one 'B' to get "AB"	1
1	[1, 2]	2	-	-	"ABB"	-	Flip s[2] from 'B' to 'A'	-
2	[2, 0, 2]	-	0	2	"ABA"	"ABA"	Already alternating	0
Thus, the answer is [1, 0].
```

**Example 3:**
```
Input: s = "BABA", queries = [[2,0,3],[1,1],[2,1,3]]

Output: [0,1]

Explanation:

i	queries[i]	j	l	r	s before query	s[l..r]	Result	Answer
0	[2, 0, 3]	-	0	3	"BABA"	"BABA"	Already alternating	0
1	[1, 1]	1	-	-	"BABA"	-	Flip s[1] from 'A' to 'B'	-
2	[2, 1, 3]	-	1	3	"BBBA"	"BBA"	Delete one 'B' to get "BA"	1
Thus, the answer is [0, 1].
```
 

**Constraints:**

* `1 <= n == s.length <= 10^5`
* `s[i]` is either `'A'` or `'B'`.
* `1 <= q == queries.length <= 10^5`
* `queries[i].length == 2 or 3`
* `queries[i] == [1, j]` or,
* `queries[i] == [2, l, r]`
* `0 <= j <= n - 1`
* `0 <= l <= r <= n - 1`

# Submissions
---
**Solution 1: (Fenwick Tree, BIT)**

__Intuition__
The solution uses a Fenwick Tree to efficiently count "violations",
which are adjacent identical characters ('AA' or 'BB').
The total number of violations is the minimum number of deletions needed.

__Explanation__
Initilization
Transform s to a 0-1 array.
If A[i] == A[i - 1],
then it needs one operation to remove A[i]

We use a Fenwick Tree.
It stores the count of violations at each position.
This allows for fast updates and queries.

Query [2, l, r] Range Sum
This is a range sum query.
We calculate bit.query(r) - bit.query(l)
to find the number of violations
within the substring s[l..r]

Query [1, i] Flip
Flipping the character at s[i] only affects its neighbors.
We update the Fenwick tree at positions i and i+1 accordingly:
add 1 if a new violation is created,
or -1 if one is removed.

__Complexity__
Initialization: Time O(nlogn), Space O(n)
Query 1: Time O(logn) Space O(1)
Query 2: Time O(logn) Space O(1)

```
Runtime: 55 ms, Beats 90.00%
Memory: 294.64 MB, Beats 15.00%
```
```c++
class FenwickTree {
public:
    vector<int> tree;
    FenwickTree(int size) : tree(size + 1, 0) {}

    void add(int i, int delta) {
        while (i < tree.size()) {
            tree[i] += delta;
            i += i & -i;
        }
    }

    int query(int i) {
        int s = 0;
        while (i > 0) {
            s += tree[i];
            i -= i & -i;
        }
        return s;
    }
};

class Solution {
public:
    vector<int> minDeletions(string s, vector<vector<int>>& queries) {
        int n = s.length();
        vector<int> A(n);
        for (int i = 0; i < n; ++i) {
            A[i] = s[i] - 'A';
        }

        FenwickTree bit(n);
        for (int i = 0; i < n - 1; ++i) {
            if (A[i] == A[i + 1]) {
                bit.add(i + 1, 1);
            }
        }

        vector<int> res;
        for (const auto& q : queries) {
            if (q[0] == 1) {
                int i = q[1];
                A[i] ^= 1;
                if (i > 0) {
                    bit.add(i, A[i] == A[i - 1] ? 1 : -1);
                }
                if (i < n - 1) {
                    bit.add(i + 1, A[i] == A[i + 1] ? 1 : -1);
                }
            } else {
                res.push_back(bit.query(q[2]) - bit.query(q[1]));
            }
        }
        return res;
    }
};
```
