3710. Maximum Partition Factor

You are given a 2D integer array `points`, where `points[i] = [xi, yi]` represents the coordinates of the ith point on the Cartesian plane.

The **Manhattan distance** between two points `points[i] = [xi, yi]` and `points[j] = [xj, yj]` is `|xi - xj| + |yi - yj|`.

Split the `n` points into **exactly two non-empty** groups. The **partition factor** of a split is the **minimum** Manhattan distance among all unordered pairs of points that lie in the same group.

Return the **maximum** possible **partition factor** over all valid splits.

Note: A group of size 1 contributes no intra-group pairs. When `n = 2` (both groups size 1), there are no intra-group pairs, so define the partition factor as 0.

 

**Example 1:**
```
Input: points = [[0,0],[0,2],[2,0],[2,2]]

Output: 4

Explanation:

We split the points into two groups: {[0, 0], [2, 2]} and {[0, 2], [2, 0]}.

In the first group, the only pair has Manhattan distance |0 - 2| + |0 - 2| = 4.

In the second group, the only pair also has Manhattan distance |0 - 2| + |2 - 0| = 4.

The partition factor of this split is min(4, 4) = 4, which is maximal.
```

**Example 2:**
```
Input: points = [[0,0],[0,1],[10,0]]

Output: 11

Explanation:

We split the points into two groups: {[0, 1], [10, 0]} and {[0, 0]}.

In the first group, the only pair has Manhattan distance |0 - 10| + |1 - 0| = 11.

The second group is a singleton, so it contributes no pairs.

The partition factor of this split is 11, which is maximal.
```
 

**Constraints:**

* `2 <= points.length <= 500`
* `points[i] = [xi, yi]`
* `-10^8 <= xi, yi <= 10^8`

# Submissions
---
**Solution 1: (Union Find, Binary Search)**

__Intuition__
The first strike should happen when you see maximum of minimum then binary search on asnwer should be checked like its a general thumb rule .

Now, for the DSU part its part of complementary graph theory and could be easily considered like you want to group into two parts and club rest together then consider it like if (i,j) are two persons and complement like if i is in 1st group then enemy j must not be in 1st group so j+n and if j in 1st then i+n in second .

__Approach__
Check for every valid d using binary search on min and max manhattan distance then , check if i and j belong to other group after partitioning . thus , if i and i+n belong to same group even after partitioning then its a contradiction then return false. Else True.

If true then check for larger d else low=mid-1;

here i am referring d to as the manhattan distance that i am choosing using binary search.

ITS commonly referred to as 2-SAT trick.

__Complexity__
Time complexity:O(n^2 logC)
where n=points.size()
C= max possible manhattan distance between two points.
Space complexity:O(n)

```
Runtime: 310 ms, Beats 80.81%
Memory: 52.31 MB, Beats 69.57%
```
```c++
class DSU{
    vector<int> rank,parent,size;
    public:
        DSU(int n){
            rank.resize(n+1,0);
            parent.resize(n+1);
            size.resize(n+1,0);
            for(int i=0;i<=n;i++)parent[i]=i;
        }
    int findUpar(int node){
        if(node==parent[node])return node;
        return parent[node]=findUpar(parent[node]);
    }

    void unionByRank(int u,int v){
        int ulp_u=findUpar(u);
        int ulp_v=findUpar(v);
        if(ulp_u==ulp_v)return;
        if(rank[ulp_u]<rank[ulp_v])parent[ulp_u]=ulp_v;
        else if(rank[ulp_v]<rank[ulp_u])parent[ulp_v]=ulp_u;
        else {
            parent[ulp_v]=ulp_u;
            rank[ulp_u]++;
        }
    }
};

class Solution {
    int manhattan(vector<int>& a, vector<int>& b){
        return abs(a[0]-b[0])+abs(a[1]-b[1]);
    }

    bool valid(vector<vector<int>>& points , int val){
        int n=points.size();
        DSU d(2*n);
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                if(manhattan(points[i],points[j])<val){
                    d.unionByRank(i,j+n);
                    d.unionByRank(i+n,j);
                }
            }
        }
        for(int i=0;i<n;i++){
            if(d.findUpar(i)==d.findUpar(i+n))return false;
        }
        return true;
    }
public:
    int maxPartitionFactor(vector<vector<int>>& points) {
        int n=points.size();
        if(n==2)return 0;
        int low=0,high=0;
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                high=max(high,manhattan(points[i],points[j]));
            }
        }

        int ans=0;
        while(low<=high){
            int mid=low+(high-low)/2;
            if(valid(points,mid)){
                ans=mid;
                low=mid+1;
            }
            else high=mid-1;
        }
        return ans;
    }
};
```
