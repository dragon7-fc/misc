3213. Construct String with Minimum Cost

You are given a string `target`, an array of strings `words`, and an integer array `costs`, both arrays of the same length.

Imagine an empty string `s`.

You can perform the following operation any number of times (including **zero**):

* Choose an index `i` in the range `[0, words.length - 1]`.
* Append `words[i]` to `s`.
* The cost of operation is `costs[i]`.

Return the **minimum** cost to make `s` equal to `target`. If it's not possible, return `-1`.

 

**Example 1:**
```
Input: target = "abcdef", words = ["abdef","abc","d","def","ef"], costs = [100,1,1,10,5]

Output: 7

Explanation:

The minimum cost can be achieved by performing the following operations:

Select index 1 and append "abc" to s at a cost of 1, resulting in s = "abc".
Select index 2 and append "d" to s at a cost of 1, resulting in s = "abcd".
Select index 4 and append "ef" to s at a cost of 5, resulting in s = "abcdef".
```

**Example 2:**
```
Input: target = "aaaa", words = ["z","zz","zzz"], costs = [1,10,100]

Output: -1

Explanation:

It is impossible to make s equal to target, so we return -1.
```
 

**Constraints:**

* `1 <= target.length <= 5 * 10^4`
* `1 <= words.length == costs.length <= 5 * 10^4`
* `1 <= words[i].length <= target.length`
* The total sum of `words[i].length` is less than or equal to `5 * 10^4`.
* `target` and `words[i]` consist only of lowercase English letters.
* `1 <= costs[i] <= 10^4`

# Submissions
---
**Solution 1: (Trie, DP Bottom-Up)**
```
Runtime: 1851 ms
Memory: 485.85 MB
```
```c++
class TrieNode {
public:
    unordered_map<char, TrieNode*> children;
    int cost;
    TrieNode() : cost(INT_MAX) {}
};

class Trie {
public:
    TrieNode* root;
    Trie() {
        root = new TrieNode();
    }
    void insert(string& word, int cost) {
        TrieNode* node = root;
        for (char c : word) {
            if (!node->children.count(c)) {
                node->children[c] = new TrieNode();
            }
            node = node->children[c];
        }
        node->cost = min(node->cost, cost);
    }
};

class Solution {
public:
    int minimumCost(string target, vector<string>& words, vector<int>& costs) {
        Trie trie;
        for (int i = 0; i < words.size(); i++) {
            trie.insert(words[i], costs[i]);
        }

        int n = target.size();
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;

        for (int i = 0; i < n; i++) {
            if (dp[i] == INT_MAX) continue;
            TrieNode* node = trie.root;
            for (int j = i; j < n; j++) {
                if (!node->children.count(target[j])) break;
                node = node->children[target[j]];
                if (node->cost != INT_MAX) {
                    dp[j + 1] = min(dp[j + 1], dp[i] + node->cost);
                }
            }
        }

        return dp[n] == INT_MAX ? -1 : dp[n];
    }
};
```
