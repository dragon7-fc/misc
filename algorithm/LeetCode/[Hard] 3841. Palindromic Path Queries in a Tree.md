3841. Palindromic Path Queries in a Tree

You are given an undirected tree with `n` nodes labeled 0 to `n - 1`. This is represented by a 2D array `edges` of length `n - 1`, where `edges[i] = [ui, vi]` indicates an undirected edge between nodes `ui` and `vi`.

You are also given a string `s` of length `n` consisting of lowercase English letters, where `s[i]` represents the character assigned to node `i`.

You are also given a string array `queries`, where each `queries[i]` is either:

* `"update ui c"`: Change the character at node `ui` to `c`. Formally, update `s[ui] = c`.
* `"query ui vi"`: Determine whether the string formed by the characters on the unique path from `ui` to `vi` (inclusive) can be rearranged into a palindrome.

Return a boolean array answer, where `answer[j]` is `true` if the `j`th query of type `"query ui vi"` can be rearranged into a **palindrome**, and `false` otherwise.

 

**Example 1:**
```
Input: n = 3, edges = [[0,1],[1,2]], s = "aac", queries = ["query 0 2","update 1 b","query 0 2"]

Output: [true,false]

Explanation:

"query 0 2": Path 0 → 1 → 2 gives "aac", which can be rearranged to form "aca", a palindrome. Thus, answer[0] = true.
"update 1 b": Update node 1 to 'b', now s = "abc".
"query 0 2": Path characters are "abc", which cannot be rearranged to form a palindrome. Thus, answer[1] = false.
Thus, answer = [true, false].
```

**Example 2:**
```
Input: n = 4, edges = [[0,1],[0,2],[0,3]], s = "abca", queries = ["query 1 2","update 0 b","query 2 3","update 3 a","query 1 3"]

Output: [false,false,true]

Explanation:

"query 1 2": Path 1 → 0 → 2 gives "bac", which cannot be rearranged to form a palindrome. Thus, answer[0] = false.
"update 0 b": Update node 0 to 'b', now s = "bbca".
"query 2 3": Path 2 → 0 → 3 gives "cba", which cannot be rearranged to form a palindrome. Thus, answer[1] = false.
"update 3 a": Update node 3 to 'a', s = "bbca".
"query 1 3": Path 1 → 0 → 3 gives "bba", which can be rearranged to form "bab", a palindrome. Thus, answer[2] = true.
Thus, answer = [false, false, true].
```
 

**Constraints:**

* `1 <= n == s.length <= 5 * 10^4`
* `edges.length == n - 1`
* `edges[i] = [ui, vi]`
* `0 <= ui, vi <= n - 1`
* `s` consists of lowercase English letters.
* The input is generated such that `edges` represents a valid tree.
* `1 <= queries.length <= 5 * 10^4`
* `queries[i] = "update ui c" or`
* `queries[i] = "query ui vi"`
* `0 <= ui, vi <= n - 1`
* `c` is a lowercase English letter.

# Submissions
---
**Solution 1: (LCA + Fenwick + Parity Encoding)**

Intuition
A path in a tree forms a palindrome iff the multiset of characters along the path has at most one character with odd frequency.
This can be encoded using a bitmask parity representation: each character corresponds to one bit, toggled whenever it appears.
Thus, checking whether a path label can form a palindrome reduces to checking whether the XOR mask of that path has at most one bit set.

Approach
Tree preprocessing

Build the adjacency list from edges.
Run a DFS from node 0 to compute:
entry/exit Euler times (tin, tout),
node depths,
binary lifting parent table for LCA queries.
Fenwick Tree (BIT) with XOR

Maintain XOR parity masks over Euler intervals.
For each node u with label c, toggle its mask on [tin[u], tout[u]].
This allows prefix XOR queries giving parity information from root to any node.
Lowest Common Ancestor

Use binary lifting (O(log n)) to compute lca(u,v).
Handling queries

Update:
Compute delta = old_mask ^ new_mask and XOR-update the Fenwick tree over the subtree interval.
Path query (u,v):
Compute w = lca(u,v).
Path mask:
m = bit_sum(tin[u]) ^ bit_sum(tin[v]) ^ mask(label[w])
The path is palindromic iff:
m == 0  or  (m & (m-1)) == 0
(i.e., ≤ 1 bit set).
Complexity
Time complexity:

Preprocessing DFS + binary lifting: O(n log n)
Each update/query: O(log n)
Total: O((n + q) log n)
Space complexity:

Parent table + Fenwick tree + DFS metadata: O(n log n)

```
Runtime: 314 ms, Beats 81.82%
Memory: 331.58 MB, Beats 63.64%
```
```c++
class Solution {
    static const int LOG = 17;
    
    // ---------- DFS ----------
    void dfs(
        int u, int p,
        vector<vector<int>>& g,
        vector<vector<int>>& parent,
        vector<int>& depth,
        vector<int>& tin,
        vector<int>& tout,
        int& timer
    ) {
        tin[u] = timer++;
        parent[0][u] = p;

        for (int v : g[u]) {
            if (v == p) continue;
            depth[v] = depth[u] + 1;
            dfs(v, u, g, parent, depth, tin, tout, timer);
        }

        tout[u] = timer - 1;
    }

    // ---------- LCA ----------
    int lca(int u, int v,
            vector<vector<int>>& parent,
            vector<int>& depth) {

        if (depth[u] < depth[v])
            swap(u, v);

        int d = depth[u] - depth[v];
        for (int k = 0; k < LOG; k++)
            if (d & (1 << k))
                u = parent[k][u];

        if (u == v) return u;

        for (int k = LOG - 1; k >= 0; k--)
            if (parent[k][u] != parent[k][v]) {
                u = parent[k][u];
                v = parent[k][v];
            }

        return parent[0][u];
    }

    int mask(char c) {
        return 1 << (c - 'a');
    }

    // ---------- Fenwick ----------
    struct Fenwick {
        int n;
        vector<int> bit;

        Fenwick(int n) : n(n), bit(n+1) {}

        void add(int i, int val) {
            for (++i; i <= n; i += i & -i)
                bit[i] ^= val;
        }

        int sum(int i) {
            int r = 0;
            for (++i; i > 0; i -= i & -i)
                r ^= bit[i];
            return r;
        }
    };
public:
    vector<bool> palindromePath(int n, vector<vector<int>>& edges, string s, vector<string>& queries) {
        // ---------- Build tree ----------
        vector<vector<int>> g(n);
        for (auto &e : edges) {
            g[e[0]].push_back(e[1]);
            g[e[1]].push_back(e[0]);
        }

        vector<vector<int>> parent(LOG, vector<int>(n, -1));
        vector<int> depth(n), tin(n), tout(n);
        int timer = 0;

        dfs(0, -1, g, parent, depth, tin, tout, timer);

        // ---------- Binary lifting ----------
        for (int k = 1; k < LOG; k++)
            for (int i = 0; i < n; i++) {
                int p = parent[k-1][i];
                if (p != -1)
                    parent[k][i] = parent[k-1][p];
            }

        // ---------- Fenwick ----------
        Fenwick fenwick(n);

        for (int i = 0; i < n; i++) {
            int m = mask(s[i]);
            fenwick.add(tin[i], m);
            fenwick.add(tout[i] + 1, m);
        }

        vector<bool> ans;

        for (auto &q : queries) {

            stringstream ss(q);
            string t;
            ss >> t;

            if (t == "update") {

                int u; char c;
                ss >> u >> c;

                int delta = mask(s[u]) ^ mask(c);
                s[u] = c;

                fenwick.add(tin[u], delta);
                fenwick.add(tout[u] + 1, delta);

            } else {

                int u, v;
                ss >> u >> v;

                int w = lca(u, v, parent, depth);

                int m = fenwick.sum(tin[u])
                        ^ fenwick.sum(tin[v])
                        ^ mask(s[w]);

                ans.push_back(m == 0 || (m & (m - 1)) == 0);
            }
        }

        return ans;
    }
};
```
