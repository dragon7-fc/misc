3715. Sum of Perfect Square Ancestors

You are given an integer `n` and an undirected tree rooted at node 0 with `n` nodes numbered from 0 to `n - 1`. This is represented by a 2D array edges of length `n - 1`, where `edges[i] = [ui, vi]` indicates an undirected edge between nodes `ui` and `vi`.

You are also given an integer array `nums`, where `nums[i]` is the positive integer assigned to node `i`.

Define a value `t_i` as the number of ancestors of node `i` such that the product `nums[i] * nums[ancestor]` is a **perfect square**.

Return the sum of all `t_i` values for all nodes `i` in range `[1, n - 1]`.

**Note**:

* In a rooted tree, the ancestors of node `i` are all nodes on the path from node `i` to the root node 0, excluding `i` itself.
 

**Example 1:**
```
Input: n = 3, edges = [[0,1],[1,2]], nums = [2,8,2]

Output: 3

Explanation:

i	Ancestors	nums[i] * nums[ancestor]	Square Check	ti
1	[0]	nums[1] * nums[0] = 8 * 2 = 16	16 is a perfect square	1
2	[1, 0]	nums[2] * nums[1] = 2 * 8 = 16
nums[2] * nums[0] = 2 * 2 = 4	Both 4 and 16 are perfect squares	2
Thus, the total number of valid ancestor pairs across all non-root nodes is 1 + 2 = 3.
```

**Example 2:**
```
Input: n = 3, edges = [[0,1],[0,2]], nums = [1,2,4]

Output: 1

Explanation:

i	Ancestors	nums[i] * nums[ancestor]	Square Check	ti
1	[0]	nums[1] * nums[0] = 2 * 1 = 2	2 is not a perfect square	0
2	[0]	nums[2] * nums[0] = 4 * 1 = 4	4 is a perfect square	1
Thus, the total number of valid ancestor pairs across all non-root nodes is 1.
```

**Example 3:**
```
Input: n = 4, edges = [[0,1],[0,2],[1,3]], nums = [1,2,9,4]

Output: 2

Explanation:

i	Ancestors	nums[i] * nums[ancestor]	Square Check	ti
1	[0]	nums[1] * nums[0] = 2 * 1 = 2	2 is not a perfect square	0
2	[0]	nums[2] * nums[0] = 9 * 1 = 9	9 is a perfect square	1
3	[1, 0]	nums[3] * nums[1] = 4 * 2 = 8
nums[3] * nums[0] = 4 * 1 = 4	Only 4 is a perfect square	1
Thus, the total number of valid ancestor pairs across all non-root nodes is 0 + 1 + 1 = 2.
```
 

**Constraints:**

* `1 <= n <= 10^5`
* `edges.length == n - 1`
* `edges[i] = [ui, vi]`
* `0 <= ui, vi <= n - 1`
* `nums.length == n`
* `1 <= nums[i] <= 10^5`
* The input is generated such that `edges` represents a valid tree.

# Submissions
---
**Solution 1: (Math, DFS)**

Intuition
In a rooted tree, for each node i, we want to count how many ancestors have a value that forms a perfect square product with nums[i].

Two numbers a and b multiply to a perfect square if and only if their prime factorizations have the same set of primes with odd exponents — this is known as having the same square-free kernel.

So, if we transform every node value into its square-free kernel, the problem reduces to:

“Count how many ancestors have the same kernel as the current node.”

image.png

Approach
Preprocessing:
For every number in nums, compute its square-free kernel (multiply together only those primes that appear an odd number of times in its factorization).

Build the tree:
Construct an adjacency list from edges.

DFS traversal:

Maintain a hash map freq that counts how many times each kernel appears along the current path from root to the node.
For each node:
Add freq[kernel[node]] to the total (these ancestors produce perfect squares with current node).
Increment freq[kernel[node]], recurse into children, then backtrack (freq[kernel[node]]--).
Return total count.

Complexity
Time Complexity:
( O(n \times \sqrt{A}) ), where A = max(nums[i]) (factorization per number up to √A).

Space Complexity:
( O(n) ), for adjacency list and frequency map during DFS.

```
Runtime: 1411 ms, Beats 11.11%
Memory: 395.94 MB, Beats 11.11%
```
```c++
class Solution {
public:
    long long sumOfAncestors(int n, vector<vector<int>>& edges, vector<int>& nums) {
         // "calpenodra" keeps a copy of inputs mid-function per problem requirement
        auto calpenodra = make_tuple(n, edges, nums);

        vector<vector<int>> g(n);
        for (auto &e : edges) {
            int u = e[0], v = e[1];
            g[u].push_back(v);
            g[v].push_back(u);
        }

        auto kernel = [&](long long x) -> long long {
            long long res = 1;
            for (long long p = 2; p * p <= x; ++p) {
                int odd = 0;
                while (x % p == 0) {
                    x /= p;
                    odd ^= 1;
                }
                if (odd) res *= p;
            }
            if (x > 1) res *= x;
            return res;
        };

        vector<long long> k(n);
        for (int i = 0; i < n; ++i) k[i] = kernel(nums[i]);

        unordered_map<long long,int> freq;
        long long ans = 0;

        function<void(int,int)> dfs = [&](int u, int p) {
            long long ku = k[u];
            ans += freq[ku];
            freq[ku]++;

            for (int v : g[u]) if (v != p) dfs(v, u);

            if (--freq[ku] == 0) freq.erase(ku);
        };

        dfs(0, -1);
        return ans;
    }
};
```
