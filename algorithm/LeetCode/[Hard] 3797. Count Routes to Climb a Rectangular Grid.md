3797. Count Routes to Climb a Rectangular Grid

You are given a string array `grid` of size `n`, where each string grid[i] has length `m`. The character `grid[i][j]` is one of the following symbols:

* `'.'`: The cell is available.
* `'#'`: The cell is blocked.

You want to count the number of different routes to climb `grid`. Each route must start from any cell in the bottom row (row `n - 1`) and end in the top row (row `0`).

However, there are some constraints on the route.

* You can only move from one available cell to **another** available cell.
* The Euclidean distance of each move is **at most** `d`, where `d` is an integer parameter given to you. The Euclidean distance between two cells `(r1, c1)`, `(r2, c2)` is `sqrt((r1 - r2)2 + (c1 - c2)2)`.
* Each move either stays on the same row or moves to the row directly above (from row `r` to `r - 1`).
* You cannot stay on the same row for two consecutive turns. If you stay on the same row in a move (and this move is not the last move), your next move must go to the row above.

Return an integer denoting the number of such routes. Since the answer may be very large, return it **modulo** `10^9 + 7`.

 

**Example 1:**
```
Input: grid = ["..","#."], d = 1

Output: 2

Explanation:

We label the cells we visit in the routes sequentially, starting from 1. The two routes are:

.2
#1
32
#1
We can move from the cell (1, 1) to the cell (0, 1) because the Euclidean distance is sqrt((1 - 0)2 + (1 - 1)2) = sqrt(1) <= d.

However, we cannot move from the cell (1, 1) to the cell (0, 0) because the Euclidean distance is sqrt((1 - 0)2 + (1 - 0)2) = sqrt(2) > d.
```

**Example 2:**
```
Input: grid = ["..","#."], d = 2

Output: 4

Explanation:

Two of the routes are given in example 1. The other two routes are:

2.
#1
23
#1
Note that we can move from (1, 1) to (0, 0) because the Euclidean distance is sqrt(2) <= d.
```

**Example 3:**
```
Input: grid = ["#"], d = 750

Output: 0

Explanation:

We cannot choose any cell as the starting cell. Therefore, there are no routes.
```

**Example 4:**
```
Input: grid = [".."], d = 1

Output: 4

Explanation:

The possible routes are:

.1
1.
12
21
```

**Constraints:**

* `1 <= n == grid.length <= 750`
* `1 <= m == grid[i].length <= 750`
* `grid[i][j] is '.' or '#'`.
* `1 <= d <= 750`

# Submissions
---
**Solution 1: (DP Bottom-Up, Sliding Window)**

__Intuition__
The problem is a Dynamic Programming task on a 2D grid with Euclidean distance constraints.

__Explanation__
dp[j] stores the number of paths ending at column j in the current row.

For each row, we first perform an "Up-Move" transition and then a "Same-Row" transition:
Up-Move: From row i+1 to i. The max horizontal distance is sqrt(d * d - 1).
Same-Row Move: Within row i. The max horizontal distance is d.

f(dp, d, r) uses a sliding window optimization to handle horizontal range sums efficiently.

__Complexity__
Time O(nm)
Space O(m)

```
Runtime: 156 ms, Beats 100.00%
Memory: 229.74 MB, Beats 73.68%
```
```c++
class Solution {
public:
    int numberOfRoutes(vector<string>& grid, int d) {
        int n = grid.size(), m = grid[0].size();
        long long mod = 1e9 + 7;

        auto f = [&](const vector<long long>& dp, int dist, const string& r) {
            vector<long long> dp2(m);
            long long window = 0;
            for (int k = 0; k <= min(m - 1, dist); ++k)
                window += dp[k];
            dp2[0] = window;
            for (int j = 1; j < m; ++j) {
                window = dp2[j - 1];
                if (j - dist - 1 >= 0) window -= dp[j - dist - 1];
                if (j + dist < m) window += dp[j + dist];
                dp2[j] = window;
            }
            for (int j = 0; j < m; ++j) {
                dp2[j] = (r[j] == '#') ? 0 : dp2[j] % mod;
            }
            return dp2;
        };

        vector<long long> dp;
        for (int i = n - 1; i >= 0; --i) {
            const string& r = grid[i];
            if (dp.empty()) {
                dp = f(vector<long long>(m, 1), 0, r);
            } else {
                int d2 = sqrt(d * d - 1);
                dp = f(dp, d2, r);
            }
            dp = f(dp, d, r);
        }
        long long res = 0;
        for (long long v : dp)
            res = (res + v) % mod;
        return res;
    }
};
```
