3845. Maximum Subarray XOR with Bounded Range

You are given a non-negative integer array `nums` and an integer `k`.

You must select a **subarray** of `nums` such that the difference between its **maximum** and **minimum** elements is at most `k`. The value of this subarray is the bitwise `XOR` of all elements in the subarray.

Return an integer denoting the **maximum** possible value of the selected subarray.

 

**Example 1:**
```
Input: nums = [5,4,5,6], k = 2

Output: 7

Explanation:

Select the subarray [5, 4, 5, 6].
The difference between its maximum and minimum elements is 6 - 4 = 2 <= k.
The value is 4 XOR 5 XOR 6 = 7.
```

**Example 2:**
```
Input: nums = [5,4,5,6], k = 1

Output: 6

Explanation:

Select the subarray [5, 4, 5, 6].
The difference between its maximum and minimum elements is 6 - 6 = 0 <= k.
The value is 6.
```

**Constraints:**

* `1 <= nums.length <= 4 * 10^4`
* `0 <= nums[i] < 2^15`
* `0 <= k < 2^15`

# Submissions
---
**Solution 1: (Binary Trie, Bit Manipulation)**


        x x x ... x
            -------
              xor = right_xor ^ left_xor 
        ----
        left_xor
        ------------
          right_xor

```
Runtime: 372 ms, Beats 27.53%
Memory: 178.56 MB, Beats, 21.52%
```
```c++
struct TrieNode {
    TrieNode* child[2];
    int count;
    
    TrieNode() {
        child[0] = child[1] = nullptr;
        count = 0;
    }
};

class Trie {
private:
    TrieNode* root;
    
public:
    Trie() {
        root = new TrieNode();
    }
    
    void insert(int x) {
        TrieNode* node = root;
        
        for(int i = 16; i >= 0; i--) {
            int bit = (x >> i) & 1;
            
            if(!node->child[bit])
                node->child[bit] = new TrieNode();
        
            node = node->child[bit];
            node->count++;
        }
    }
    
    void remove(int x) {
        TrieNode* node = root;
        
        for(int i = 16; i >= 0; i--) {
            int bit = (x >> i) & 1;
            node = node->child[bit];
            node->count--;
        }
    }
    
    int maxXor(int x) {
        TrieNode* node = root;
        int res = 0;
        
        for(int i = 16; i >= 0; i--) {
            int bit = (x >> i) & 1, desired = 1 - bit;
            
            if(node->child[desired] && node->child[desired]->count > 0) {
                res |= (1 << i);
                node = node->child[desired];
            } 
            
            else 
                node = node->child[bit];
        }
        
        return res;
    }
};

class Solution {
public:
    int maxXor(vector<int>& nums, int k) {
        int n = nums.size(), l = 0, res = 0;
        vector<int> pre(n + 1);

        for(int i = 0; i < n; ++i)
            pre[i + 1] = pre[i] ^ nums[i];

        multiset<int> ms;
        
        Trie trie;
        trie.insert(pre[0]);

        for(int r = 0; r < n; ++r) {
            ms.insert(nums[r]);
            
            while(!ms.empty() && *prev(end(ms)) - *begin(ms) > k) {
                ms.erase(ms.find(nums[l]));
                trie.remove(pre[l++]);
            }

            res = max(res, trie.maxXor(pre[r + 1]));
            trie.insert(pre[r + 1]);
        }

        return res;
    }
};
```
