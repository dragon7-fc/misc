1383. Maximum Performance of a Team

There are `n` engineers numbered from `1` to `n` and two arrays: `speed` and `efficiency`, where `speed[i]` and `efficiency[i]` represent the speed and efficiency for the `i`-th engineer respectively. Return the maximum performance of a team composed of at most `k` engineers, since the answer can be a huge number, return this modulo `10^9 + 7`.

The performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers. 

 

**Example 1:**
```
Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2
Output: 60
Explanation: 
We have the maximum performance of the team by selecting engineer 2 (with speed=10 and efficiency=4) and engineer 5 (with speed=5 and efficiency=7). That is, performance = (10 + 5) * min(4, 7) = 60.
```

**Example 2:**
```
Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3
Output: 68
Explanation:
This is the same example as the first but k = 3. We can select engineer 1, engineer 2 and engineer 5 to get the maximum performance of the team. That is, performance = (2 + 10 + 5) * min(5, 4, 7) = 68.
```

**Example 3:**
```
Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4
Output: 72
```

**Constraints:**

* `1 <= n <= 10^5`
* `speed.length == n`
* `efficiency.length == n`
* `1 <= speed[i] <= 10^5`
* `1 <= efficiency[i] <= 10^8`
* `1 <= k <= n`

# Submissions
---
**Solution 1: (Heap)**

```
Runtime: 348 ms
Memory Usage: 30.5 MB
```
```python
class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        modulo = 10 ** 9 + 7

        # build tuples of (efficiency, speed)
        candidates = zip(efficiency, speed)
        # sort the candidates by their efficiencies
        candidates = sorted(candidates, key=lambda t:t[0], reverse=True)

        speed_heap = []
        speed_sum, perf = 0, 0
        for curr_efficiency, curr_speed in candidates:
            # maintain a heap for the fastest (k-1) speeds
            if len(speed_heap) > k-1:
                speed_sum -= heapq.heappop(speed_heap)
            heapq.heappush(speed_heap, curr_speed)

            # calculate the maximum performance with the current member as the least efficient one in the team
            speed_sum += curr_speed
            perf = max(perf, speed_sum * curr_efficiency)

        return perf % modulo
```

**Solution 2: (Heap, Sort, sort by efficiency and greey over max speed sum)**
```
Runtime: 11 ms, Beats 99.09%
Memory: 39.39 MB, Beats 96.06%
```
```c++
class Solution {
public:
    int maxPerformance(int n, vector<int>& speed, vector<int>& efficiency, int k) {
        int i, MOD = 1e9 + 7;
        long long a = 0, ans = 0;
        vector<array<int,2>> dp(n);
        priority_queue<int, vector<int>, greater<>> pq;
        for (i = 0; i < n; i ++) {
            dp[i] = {efficiency[i], speed[i]};
        }
        sort(dp.begin(), dp.end());
        for (i = n-1; i >= 0; i --) {
            a += dp[i][1];
            pq.push(dp[i][1]);
            ans = max(ans, a * dp[i][0]);
            if (pq.size() == k) {
                auto b = pq.top();
                a -= b;
                pq.pop();
            }
        }
        return ans % MOD;
    }
};
```
