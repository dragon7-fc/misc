3762. Minimum Operations to Equalize Subarrays

You are given an integer array `nums` and an integer `k`.

In one operation, you can **increase** or **decrease** any element of nums by exactly `k`.

You are also given a 2D integer array `queries`, where each `queries[i] = [li, ri]`.

For each query, find the **minimum** number of operations required to make all elements in the subarray `nums[li..ri]` equal. If it is impossible, the answer for that query is `-1`.

Return an array `ans`, where `ans[i]` is the answer for the `i`th query.

 

**Example 1:**
```
Input: nums = [1,4,7], k = 3, queries = [[0,1],[0,2]]

Output: [1,2]

Explanation:

One optimal set of operations:

i	[li, ri]	nums[li..ri]	Possibility	Operations	Final
nums[li..ri]	ans[i]
0	[0, 1]	[1, 4]	Yes	nums[0] + k = 1 + 3 = 4 = nums[1]	[4, 4]	1
1	[0, 2]	[1, 4, 7]	Yes	nums[0] + k = 1 + 3 = 4 = nums[1]

			nums[2] - k = 7 - 3 = 4 = nums[1]	[4, 4, 4]	2
Thus, ans = [1, 2].
```

**Example 2:**
```
Input: nums = [1,2,4], k = 2, queries = [[0,2],[0,0],[1,2]]

Output: [-1,0,1]

Explanation:

One optimal set of operations:

i	[li, ri]	nums[li..ri]	Possibility	Operations	Final
nums[li..ri]	ans[i]
0	[0, 2]	[1, 2, 4]	No	-	[1, 2, 4]	-1
1	[0, 0]	[1]	Yes	Already equal	[1]	0
2	[1, 2]	[2, 4]	Yes	nums[1] + k = 2 + 2 = 4 = nums[2]	[4, 4]	1
Thus, ans = [-1, 0, 1].
```
 

**Constraints:**

* `1 <= n == nums.length <= 4 × 10^4`
* `1 <= nums[i] <= 10^9`
* `1 <= k <= 10^9`
* `1 <= queries.length <= 4 × 10^4`
* `queries[i] = [li, ri]`
* `0 <= li <= ri <= n - 1`

# Submissions
---
**Solution 1: (Segment Tree)**

__Intuition__
You want to make all elements in a subarray equal by applying:

k or - k
This means:

✔ Only numbers with the same remainder mod k can ever become equal.

Example:
k = 3
1, 4, 7 → all ≡ 1 mod 3 → CAN be equalized
2, 5, 8 → all ≡ 2 mod 3 → CAN be equalized
1, 2 → different mod → NEVER equalizable

This is the first big insight.

Next:

✔ Once they are equalizable, what final value should they be equalized to?

We are allowed to do:

x → x + mk → some target T

Meaning cost = |x - T| / k

To minimize sum of |x - T|,
the best T is ALWAYS the median.

This is classic:
sum of absolute differences minimized at median.

So the real problem becomes:

"Find the median of the subarray, then compute cost = sum(|nums[i] - median| / k)."

The problem is simply:

Check if all numbers in subarray have same mod k

Find the median of the subarray

Compute the sum of costs

⭐ The HARD PART (Why naive TLE)

Naively, for each query:

extract nums[L..R]

sort it

find median

compute cost

Sorting for every query = TLE:

40,000 queries × 40,000 sort = DEAD

We need median without sorting,
and sum(|x - median|) without scanning entire subarray per query.

This is exactly why we use:

✔ Range Minimum/Maximum Segment Tree

To quickly check if all nums[L..R] have the same remainder mod k.

✔ Merge Sort Tree

A segment tree where each node holds sorted values.

This lets you do:

count(nums ≤ x in range [L,R])

sum(nums ≤ x in range [L,R])

All in O(log² n)

⭐ Why do we need count(nums ≤ x in [L,R]) ?

To find the median, you need:

the smallest value m such that count ≤ m >= (length+1)/2

We binary search over all potential values
and ask Merge-Sort Tree:

count of values <= mid

This gives us the median without sorting the subarray.

Why do we need sum(nums ≤ median)?

To compute total cost:

cost = Σ |nums[i] - median|

This equals:

cost = mediancnt_small - sum_small
+ sum_large - mediancnt_large

These 4 numbers are computed fast using merge-sort-tree prefix sums.

__Approach__
✔ Precompute:

rema[i] = nums[i] % k

scaled[i] = nums[i] / k
(works because final operation count = difference / k)

✔ Build data structures:

Segment tree over remainders
→ to check if all items in query have same remainder

Merge-sort tree over scaled array
→ each node stores a sorted list & prefix sums

✔ For each query [L,R]:

Step 1: Mod Check

If all rema[L..R] are not equal → answer = -1

Step 2: Get Median

Binary search over unique scaled values:

find value M such that count(scaled[i] ≤ M in [L,R]) >= (len+1)//2

Step 3: Compute cost

Using prefix sums:

cost = |scaled[i] - M| sum

```
Runtime: 1630 ms, Beats 5.55%
Memory: 541.26 MB, Beats 5.55%
```
```c++
class Solution {
    struct RemTree {
        int n;
        vector<int> lo, hi;
        RemTree(const vector<int>& a){
            n=a.size();
            lo.resize(4 * n);
            hi.resize(4 * n);
            build(1, 0, n - 1, a);
        }
        void build(int idx, int l, int r, const vector<int> &a) {
            if (l == r) {
                lo[idx] = hi[idx] = a[l];
                return;
            }
            int m = (l + r) / 2;
            build(idx * 2, l, m, a);
            build(idx * 2 + 1, m + 1, r, a);
            lo[idx] = min(lo[idx * 2], lo[idx * 2 + 1]);
            hi[idx] = max(hi[idx * 2], hi[idx * 2 + 1]);
        }
        pair<int,int> getVal(int idx, int l, int r, int L, int R){
            if (R < l || r < L ) {
                return {INT_MAX, INT_MIN};
            }
            if (L <= l && r <= R) {
                return {lo[idx], hi[idx]};
            }
            int m = (l + r) / 2;
            auto a = getVal(idx * 2, l, m , L, R);
            auto b = getVal(idx * 2 + 1, m + 1, r, L, R);
            return {min(a.first, b.first), max(a.second, b.second)};
        }
    };

    struct MST {
        int n;
        vector<vector<long long>> v, p;
        MST(const vector<long long> &a) {
            n = a.size();
            v.resize(4 * n);
            p.resize(4 * n);
            build(1, 0, n - 1, a);
        }
        void build(int idx, int l, int r, const vector<long long> &a){
            if (l == r) {
                v[idx] = {a[l]};
                p[idx] = {a[l]};
                return;
            }
            int m = (l + r) / 2;
            build(idx * 2, l, m, a);
            build(idx * 2 + 1, m + 1, r, a);
            auto &L = v[idx * 2], &R = v[idx * 2 + 1];
            v[idx].resize(L.size() + R.size());
            merge(L.begin(), L.end(), R.begin(), R.end(), v[idx].begin());
            p[idx].resize(v[idx].size());
            long long s = 0;
            for (int i=0; i < (int)v[idx].size(); i ++) {
                s += v[idx][i];
                p[idx][i] = s;
            }
        }
        pair<long long, long long> le(int idx, int l, int r, int L, int R, long long x){
            if (R < l || r < L) {
                return {0, 0};
            }
            if (L <= l && r <= R) {
                auto &A = v[idx]; auto &P = p[idx];
                int pos = upper_bound(A.begin(), A.end(), x) - A.begin();
                long long s = pos? P[pos-1] : 0;
                return {pos, s};
            }
            int m = (l + r) / 2;
            auto a = le(idx * 2, l, m, L, R, x);
            auto b = le(idx * 2 + 1, m + 1, r, L, R, x);
            return {a.first + b.first, a.second + b.second};
        }
        long long sum(int idx, int l, int r, int L, int R){
            if (R < l || r < L) {
                return 0;
            }
            if (L <= l && r <= R) {
                return p[idx].back();
            }
            int m =(l + r) / 2;
            return sum(idx * 2, l, m, L, R) + sum(idx * 2 + 1, m + 1, r, L, R);
        }
    };
public:
    vector<long long> minOperations(vector<int>& nums, int k, vector<vector<int>>& queries) {
        int n = nums.size();
        vector<int> rem(n);
        vector<long long> sc(n);
        for (int i = 0; i < n; i ++){
            rem[i] = nums[i] % k;
            sc[i] = nums[i] / (long long)k;
        }

        RemTree rt(rem);
        MST mt(sc);

        vector<long long> uniq = sc;
        sort(uniq.begin(), uniq.end());
        uniq.erase(unique(uniq.begin(), uniq.end()), uniq.end());

        vector<long long> res;
        res.reserve(queries.size());

        for (auto &q: queries){
            int L = q[0], R = q[1];
            auto g = rt.getVal(1, 0, n - 1, L, R);
            if (g.first != g.second) {
                res.push_back(-1);
                continue;
            }

            int len = R - L + 1, need = (len + 1) / 2;
            long long tot = mt.sum(1, 0, n - 1, L, R);

            int lo = 0, hi = uniq.size() - 1, best = hi;
            while (lo <= hi){
                int mid = (lo + hi) / 2;
                auto t = mt.le(1, 0, n - 1, L, R, uniq[mid]);
                if (t.first >= need) {
                    best = mid;
                    hi = mid - 1;
                } else {
                    lo = mid+1;
                }
            }

            long long med = uniq[best];
            auto le = mt. le(1, 0, n - 1, L, R, med);
            long long cL = le.first, sL = le.second;
            long long cR = len - cL, sR = tot - sL;

            res.push_back(med * cL - sL + sR - med * cR);
        }
        return res;
    }
};
```
