3762. Minimum Operations to Equalize Subarrays

You are given an integer array `nums` and an integer `k`.

In one operation, you can **increase** or **decrease** any element of nums by exactly `k`.

You are also given a 2D integer array `queries`, where each `queries[i] = [li, ri]`.

For each query, find the **minimum** number of operations required to make all elements in the subarray `nums[li..ri]` equal. If it is impossible, the answer for that query is `-1`.

Return an array `ans`, where `ans[i]` is the answer for the `i`th query.

 

**Example 1:**
```
Input: nums = [1,4,7], k = 3, queries = [[0,1],[0,2]]

Output: [1,2]

Explanation:

One optimal set of operations:

i	[li, ri]	nums[li..ri]	Possibility	Operations	Final
nums[li..ri]	ans[i]
0	[0, 1]	[1, 4]	Yes	nums[0] + k = 1 + 3 = 4 = nums[1]	[4, 4]	1
1	[0, 2]	[1, 4, 7]	Yes	nums[0] + k = 1 + 3 = 4 = nums[1]

			nums[2] - k = 7 - 3 = 4 = nums[1]	[4, 4, 4]	2
Thus, ans = [1, 2].
```

**Example 2:**
```
Input: nums = [1,2,4], k = 2, queries = [[0,2],[0,0],[1,2]]

Output: [-1,0,1]

Explanation:

One optimal set of operations:

i	[li, ri]	nums[li..ri]	Possibility	Operations	Final
nums[li..ri]	ans[i]
0	[0, 2]	[1, 2, 4]	No	-	[1, 2, 4]	-1
1	[0, 0]	[1]	Yes	Already equal	[1]	0
2	[1, 2]	[2, 4]	Yes	nums[1] + k = 2 + 2 = 4 = nums[2]	[4, 4]	1
Thus, ans = [-1, 0, 1].
```
 

**Constraints:**

* `1 <= n == nums.length <= 4 × 10^4`
* `1 <= nums[i] <= 10^9`
* `1 <= k <= 10^9`
* `1 <= queries.length <= 4 × 10^4`
* `queries[i] = [li, ri]`
* `0 <= li <= ri <= n - 1`

# Submissions
---
**Solution 1: (Segment Tree)**
```
Runtime: 1630 ms, Beats 5.55%
Memory: 541.26 MB, Beats 5.55%
```
```c++
class Solution {
    struct RemTree {
        int n;
        vector<int> lo, hi;
        RemTree(const vector<int>& a){
            n=a.size();
            lo.resize(4*n);
            hi.resize(4*n);
            build(1,0,n-1,a);
        }
        void build(int idx,int l,int r,const vector<int>&a){
            if(l==r){lo[idx]=hi[idx]=a[l];return;}
            int m=(l+r)/2;
            build(idx*2,l,m,a);
            build(idx*2+1,m+1,r,a);
            lo[idx]=min(lo[idx*2],lo[idx*2+1]);
            hi[idx]=max(hi[idx*2],hi[idx*2+1]);
        }
        pair<int,int> getVal(int idx,int l,int r,int L,int R){
            if(R<l||r<L)return {INT_MAX,INT_MIN};
            if(L<=l&&r<=R)return {lo[idx],hi[idx]};
            int m=(l+r)/2;
            auto a=getVal(idx*2,l,m,L,R);
            auto b=getVal(idx*2+1,m+1,r,L,R);
            return {min(a.first,b.first),max(a.second,b.second)};
        }
    };

    struct MST {
        int n;
        vector<vector<long long>> v,p;
        MST(const vector<long long>&a){
            n=a.size();
            v.resize(4*n);
            p.resize(4*n);
            build(1,0,n-1,a);
        }
        void build(int idx,int l,int r,const vector<long long>&a){
            if(l==r){
                v[idx]={a[l]};
                p[idx]={a[l]};
                return;
            }
            int m=(l+r)/2;
            build(idx*2,l,m,a);
            build(idx*2+1,m+1,r,a);
            auto &L=v[idx*2], &R=v[idx*2+1];
            v[idx].resize(L.size()+R.size());
            merge(L.begin(),L.end(),R.begin(),R.end(),v[idx].begin());
            p[idx].resize(v[idx].size());
            long long s=0;
            for(int i=0;i<(int)v[idx].size();i++){
                s+=v[idx][i];
                p[idx][i]=s;
            }
        }
        pair<long long,long long> le(int idx,int l,int r,int L,int R,long long x){
            if(R<l||r<L)return {0,0};
            if(L<=l&&r<=R){
                auto &A=v[idx]; auto &P=p[idx];
                int pos=upper_bound(A.begin(),A.end(),x)-A.begin();
                long long s=pos?P[pos-1]:0;
                return {pos,s};
            }
            int m=(l+r)/2;
            auto a=le(idx*2,l,m,L,R,x);
            auto b=le(idx*2+1,m+1,r,L,R,x);
            return {a.first+b.first,a.second+b.second};
        }
        long long sum(int idx,int l,int r,int L,int R){
            if(R<l||r<L)return 0;
            if(L<=l&&r<=R)return p[idx].back();
            int m=(l+r)/2;
            return sum(idx*2,l,m,L,R)+sum(idx*2+1,m+1,r,L,R);
        }
    };
public:
    vector<long long> minOperations(vector<int>& nums, int k, vector<vector<int>>& queries) {
        int n=nums.size();
        vector<int> rem(n);
        vector<long long> sc(n);
        for(int i=0;i<n;i++){
            rem[i]=nums[i]%k;
            sc[i]=nums[i]/(long long)k;
        }

        RemTree rt(rem);
        MST mt(sc);

        vector<long long> uniq=sc;
        sort(uniq.begin(),uniq.end());
        uniq.erase(unique(uniq.begin(),uniq.end()),uniq.end());

        vector<long long> res;
        res.reserve(queries.size());

        for(auto &q:queries){
            int L=q[0],R=q[1];
            auto g=rt.getVal(1,0,n-1,L,R);
            if(g.first!=g.second){
                res.push_back(-1);
                continue;
            }

            int len=R-L+1,need=(len+1)/2;
            long long tot=mt.sum(1,0,n-1,L,R);

            int lo=0,hi=uniq.size()-1,best=hi;
            while(lo<=hi){
                int mid=(lo+hi)/2;
                auto t=mt.le(1,0,n-1,L,R,uniq[mid]);
                if(t.first>=need){
                    best=mid;
                    hi=mid-1;
                } else lo=mid+1;
            }

            long long med=uniq[best];
            auto le=mt.le(1,0,n-1,L,R,med);
            long long cL=le.first, sL=le.second;
            long long cR=len-cL, sR=tot-sL;

            res.push_back(med*cL - sL + sR - med*cR);
        }
        return res;
    }
};
```
