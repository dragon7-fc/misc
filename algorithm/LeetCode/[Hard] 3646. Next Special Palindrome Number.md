3646. Next Special Palindrome Number

You are given an integer `n`.

A number is called **special** if:

* It is a **palindrome**.
* Every digit `k` in the number appears exactly `k` times.

Return the **smallest** special number strictly greater than `n`.

 

*Example 1:*
```
Input: n = 2

Output: 22

Explanation:

22 is the smallest special number greater than 2, as it is a palindrome and the digit 2 appears exactly 2 times.
```

**Example 2:**
```
Input: n = 33

Output: 212

Explanation:

212 is the smallest special number greater than 33, as it is a palindrome and the digits 1 and 2 appear exactly 1 and 2 times respectively.
```
 

**Constraints:**

`0 <= n <= 10^15`

# Submissions
---
**Solution 1: (Prefix Sum)**

__Intuition__
We precompute all special palindromes (numbers that are palindromic and satisfy certain digit-count constraints) and then simply find the smallest one greater than the given n.
The constraints in generating these numbers are:
The sum of digits must be <= 18.
At most one digit can have an odd count (so it can be the middle digit in a palindrome).
__Approach__
Maintain a static vector specials so the precomputation runs only once.
If specials is empty, call init to generate all valid palindromes:
Iterate over all non-empty digit subsets (bitmask from 1 to (1<<9)-1).
For each subset, check the sum-of-digits and odd-count constraints.
Build the half and optional middle digit mid for the palindrome.
Generate all permutations of half and form the full palindrome string (left + mid + reverse(left)).
Convert to long long and store.
After generation, sort and deduplicate specials.
To answer the query, use upper_bound to find the smallest special palindrome strictly greater than n.
__Complexity__
Time complexity: O(2^9 * P * log P) + O(M log M) where P is permutations generated (small in practice).
Space complexity: O(M) for storing generated palindromes.

```
Runtime: 3 ms, Beats 90.44%
Memory: 10.98 MB, Beats 82.67%
```
```c++
typedef long long ll;

class Solution {
    void init(vector<long long> &v) {
        vector<char> half;
        string mid;
        for (int mask = 1; mask < (1<<9); ++mask) {
            int sum = 0, oddCnt = 0;
            for (int d = 1; d <= 9; ++d) if (mask & (1<<(d-1))) {
                sum += d;
                if (d % 2) ++oddCnt;
            }
            if (sum > 18 || oddCnt > 1) continue;
            half.clear(); mid.clear();
            for (int d = 1; d <= 9; ++d) if (mask & (1<<(d-1))) {
                int cnt = d;
                if (cnt % 2) {
                    mid = string(1, '0'+d);
                }
                int h = cnt / 2;
                while (h--) half.push_back('0' + d);
            }
            sort(half.begin(), half.end());
            do {
                string left(half.begin(), half.end());
                string right = left;
                reverse(right.begin(), right.end());
                string s = left + mid + right;
                if (!s.empty()) {
                    long long x = stoll(s);
                    v.push_back(x);
                }
            } while (next_permutation(half.begin(), half.end()));
        }
        sort(v.begin(), v.end());
        v.erase(unique(v.begin(), v.end()), v.end());
    }
public:
    long long specialPalindrome(long long n) {
        static vector<long long> specials;
        if (specials.empty()) init(specials);
        auto it = upper_bound(specials.begin(), specials.end(), n);
        return *it;
    }
};
```
