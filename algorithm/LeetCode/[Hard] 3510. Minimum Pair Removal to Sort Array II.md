3510. Minimum Pair Removal to Sort Array II

Given an array `nums`, you can perform the following operation any number of times:

* Select the **adjacent** pair with the minimum sum in `nums`. If multiple such pairs exist, choose the leftmost one.
* Replace the pair with their sum.

Return the **minimum** number of operations needed to make the array **non-decreasing**.

An array is said to be **non-decreasing** if each element is greater than or equal to its previous element (if it exists).

 

**Example 1:**
```
Input: nums = [5,2,3,1]

Output: 2

Explanation:

The pair (3,1) has the minimum sum of 4. After replacement, nums = [5,2,4].
The pair (2,4) has the minimum sum of 6. After replacement, nums = [5,6].
The array nums became non-decreasing in two operations.
```

**Example 2:**
```
Input: nums = [1,2,2]

Output: 0

Explanation:

The array nums is already sorted.
```
 

**Constraints:**

* `1 <= nums.length <= 10^5`
* `-10^9 <= nums[i] <= 10^9`

# Submissions
---
**Solution 1: (Set, simulation, maintain previous and next element index)**

             p  i  j     q
                p  i  j  q
             0  1  2  3
    nums = [ 5, 2, 3, 1]
a            5  2  3  1
                   4
                6
nxt          1  2  3  4
                   4
                4
pre         -1  0  1  2
s:          cnt
x 7: 0         x
x 5: 1
x 4: 2 <i      x
x 6: 1 <i
11: 0
             2 -> 1 -> 0
ans               1    2

```
Runtime: 893 ms, Beats 100.00%
Memory: 314.63 MB, Beats 100.00%
```
```c++
using ll = long long;

class Solution {
public:
    int minimumPairRemoval(vector<int>& nums) {
        int n = nums.size();
        vector<ll> a(n);
        for (int i = 0; i < n; i++) a[i] = nums[i];
        
        // maintain adjacent pairs {sum, index}
        set<pair<ll, int>> s;

        // double-linked list
        vector<int> nxt(n);
        vector<int> pre(n);
        for (int i = 0; i < n; i++) nxt[i] = i + 1;
        for (int i = 0; i < n; i++) pre[i] = i - 1;

        // insert all pairs into set
        int cnt = 0;
        for (int i = 0; i < n - 1; i++) {
            if (a[i] > a[i + 1]) cnt++;
            s.insert({a[i] + a[i + 1], i});
        }
        
        // simulate the process
        int ans = 0;
        while (cnt > 0) {
            int i = s.begin()->second;
            int j = nxt[i];
            int p = pre[i];
            int q = nxt[j];

            // pair {i, j}
            if (a[i] > a[j]) cnt--;
            if (p >= 0) {
                // pair {p, i}
                if (a[p] > a[i] && a[p] <= a[i] + a[j]) {
                    cnt--;
                }
                else if (a[p] <= a[i] && a[p] > a[i] + a[j]) {
                    cnt++;
                }
            }
            if (q < n) {
                // pair {j, q}
                if (a[q] >= a[j] && a[q] < a[i] + a[j]) {
                    cnt++;
                }
                else if (a[q] < a[j] && a[q] >= a[i] + a[j]) {
                    cnt--;
                }
            }

            // remove outdated pairs & add new pairs
            s.erase(s.begin());
            if (p >= 0) {
                s.erase({a[p] + a[i], p});
                s.insert({a[p] + a[i] + a[j], p});
            }
            if (q < n) {
                s.erase({a[j] + a[q], j});
                s.insert({a[i] + a[j] + a[q], i});
                pre[q] = i;
            }
            nxt[i] = q;
            a[i] = a[i] + a[j];
            ans++;
        }
        
        return ans;
    }
};
```

**Solution 2: (Priority Queue + Lazy Deletion, O(n log n))**
```
Runtime: 960 ms, Beats 16.46%
Memory: 257.06 MB, Beats 61.39%
```
```c++
typedef long long ll;

const int MAX_N = 100005;

struct Node {
    ll value;
    int left;
};

using ListIt = std::list<Node>::iterator;

struct Pair {
    ListIt first;
    ListIt second;
    ll cost;
    size_t firstLeft;
    size_t secondLeft;

    Pair() {}
    Pair(ListIt fi, ListIt se, ll cost)
        : first(fi),
          second(se),
          firstLeft(fi->left),
          secondLeft(se->left),
          cost(cost) {}
};

struct ComparePair {
    bool operator()(const Pair& a, const Pair& b) {
        if (a.cost != b.cost) {
            return a.cost > b.cost;
        }
        return a.firstLeft > b.firstLeft;
    }
};

class Solution {
public:
    int minimumPairRemoval(vector<int>& nums) {
        std::list<Node> list;
        std::bitset<MAX_N> merged;
        std::priority_queue<Pair, std::vector<Pair>, ComparePair> pq;

        int decreaseCount = 0;
        int count = 0;

        list.push_back({nums[0], 0});

        for (size_t i = 1; i < nums.size(); ++i) {
            list.push_back({nums[i], (int)i});

            auto curr = std::prev(list.end());
            auto prev = std::prev(curr);

            pq.push({prev, curr, prev->value + curr->value});

            if (nums[i - 1] > nums[i]) {
                decreaseCount++;
            }
        }

        while (decreaseCount > 0 && !pq.empty()) {
            auto top = pq.top();
            pq.pop();

            if (merged[top.firstLeft] || merged[top.secondLeft]) {
                continue;
            }

            auto first = top.first;
            auto second = top.second;
            auto cost = top.cost;

            if (first->value + second->value != cost) {
                continue;
            }

            count++;

            if (first->value > second->value) {
                decreaseCount--;
            }

            ListIt prev =
                (first == list.begin()) ? list.end() : std::prev(first);
            ListIt next = std::next(second);

            if (prev != list.end()) {
                if (prev->value > first->value && prev->value <= cost) {
                    decreaseCount--;
                }
                if (prev->value <= first->value && prev->value > cost) {
                    decreaseCount++;
                }
                pq.push({prev, first, prev->value + cost});
            }

            if (next != list.end()) {
                if (second->value > next->value && cost <= next->value) {
                    decreaseCount--;
                }
                if (second->value <= next->value && cost > next->value) {
                    decreaseCount++;
                }
                pq.push({first, next, cost + next->value});
            }

            first->value = cost;
            merged[second->left] = 1;
            list.erase(second);
        }

        return count;
    }
};
```
