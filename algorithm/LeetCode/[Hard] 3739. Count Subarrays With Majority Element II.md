3739. Count Subarrays With Majority Element II

You are given an integer array `nums` and an integer `target`.

Return the number of **subarrays** of `nums` in which `target` is the majority element.

The **majority** element of a subarray is the element that appears **strictly more than half** of the times in that subarray.

 

**Example 1:**
```
Input: nums = [1,2,2,3], target = 2

Output: 5

Explanation:

Valid subarrays with target = 2 as the majority element:

nums[1..1] = [2]
nums[2..2] = [2]
nums[1..2] = [2,2]
nums[0..2] = [1,2,2]
nums[1..3] = [2,2,3]
So there are 5 such subarrays.
```

**Example 2:**
```
Input: nums = [1,1,1,1], target = 1

Output: 10

Explanation:

All 10 subarrays have 1 as the majority element.
```

**Example 3:**
```
Input: nums = [1,2,3], target = 4

Output: 0

Explanation:

target = 4 does not appear in nums at all. Therefore, there cannot be any subarray where 4 is the majority element. Hence the answer is 0.
```
 

**Constraints:**

* `1 <= nums.length <= 10^5`
* `1 <= nums[i] <= 10^9`
* `1 <= target <= 10^9`

# Submissions
---
**Solution 1: (Prefix Sum, Counter)**

__Intuition__
We track a prefix balance pre
that increases by +1 when a == target,
and decreases by -1 otherwise.

__Explanation__
A subarray has target as majority
if its balance increase is positive,
meaning target appears more than half.

count[x] stores how many prefixes have balance x.
acc[x] is the prefix sum of count.

Each step adds acc[pre - 1] to
count all earlier prefixes with smaller balance
these correspond to valid subarrays where target dominates.

__Complexity__
Time O(n)
Space O(n)

             0  1  2  3  4  5  6
    nums = [ 1, 2, 2, 3],         target = 2
               ^^
                  ^^
               ^^^^^
            ^^^^^^^^
               ^^^^^^^^
pre      5
balance            ...  -1  0  1 ...
count                       1
acc                         1
ans     0
-------------------------------
pre          4
count                    1  1
acc                   0  1  1
                      +
ans     0
-------------------------------
pre             5
count                    1  2
acc                   0  1  3
                         +
ans      1
-------------------------------
pre                6
count                    1  2  1
acc                   0  1  3  4
                            +
ans      4
-------------------------------
pre                   5
count                    1  3  1
acc                   0  1  4  4
                         +
ans      5

```
Runtime: 7 ms, Beats 93.75%
Memory: 113.09 MB, Beats 37.50%
```
```c++
class Solution {
public:
    long long countMajoritySubarrays(vector<int>& nums, int target) {
        int n = nums.size(), pre = n + 1;
        vector<long long> count(2 * n + 2), acc(2 * n + 2);
        long long res = 0;
        count[pre] = acc[pre] = 1;
        for (int a : nums) {
            pre += (a == target ? 1 : -1);
            acc[pre] = ++count[pre] + acc[pre - 1];
            res += acc[pre - 1];
        }
        return res;
    }
};
```

**Solution 2: (BIT)**
```
Runtime: 28 ms, Beats 84.40%
Memory: 98.86 MB, Beats 84.54%
```
```c++
class Solution {
    int query(vector<int>& bit, int i) {
        int ans = 0;
        while (i) {
            ans += bit[i];
            i -= i & -i;
        }
        return ans;
    }
    void update(vector<int>& bit, int i) {
        while (i < bit.size()) {
            bit[i] += 1;
            i += i & -i;
        }
    }
public:
    long long countMajoritySubarrays(vector<int>& nums, int target) {
        int n = nums.size();
        long long ans = 0;
        vector<int> pre(n + 1), bit(n * 2 + 1);
        for (int i = 0; i < n; i++) {
            pre[i + 1] = pre[i] + (nums[i] == target ? 1 : -1);
        }
        for (int i = 0; i <= n; i++) {
            pre[i] += n;
            ans += query(bit, pre[i]);
            update(bit, pre[i] + 1);
        }
        return ans;
    }
};
```
