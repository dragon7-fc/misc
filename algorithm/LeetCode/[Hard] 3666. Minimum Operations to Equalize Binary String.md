3666. Minimum Operations to Equalize Binary String

You are given a binary string `s`, and an integer `k`.

In one operation, you must choose **exactly** `k` different indices and flip each `'0'` to `'1'` and each `'1'` to `'0'`.

Return the **minimum** number of operations required to make all characters in the string equal to `'1'`. If it is not possible, return -1.

 

**Example 1:**
```
Input: s = "110", k = 1

Output: 1

Explanation:

There is one '0' in s.
Since k = 1, we can flip it directly in one operation.
```

**Example 2:**
```
Input: s = "0101", k = 3

Output: 2

Explanation:

One optimal set of operations choosing k = 3 indices in each operation is:

Operation 1: Flip indices [0, 1, 3]. s changes from "0101" to "1000".
Operation 2: Flip indices [1, 2, 3]. s changes from "1000" to "1111".
Thus, the minimum number of operations is 2.
```

**Example 3:**
```
Input: s = "101", k = 2

Output: -1

Explanation:

Since k = 2 and s has only one '0', it is impossible to flip exactly k indices to make all '1'. Hence, the answer is -1.
```
 

**Constraints:**

* `1 <= s.length <= 10^5`
* `s[i]` is either `'0'` or `'1'`.
* `1 <= k <= s.length`

# Submissions
---
**Solution 1: (Model Solution)**

__Intuition__
We are given a binary string and allowed to flip exactly k characters in each operation.
The state of the system can be described by how many '0's remain in the string.
From a given count of zeros z, after one operation the number of zeros changes deterministically depending on how many zeros are flipped.
This suggests a shortest path problem on states 0..n where n is the string length.

__Approach__
We model the problem as a graph:

Each node = number of zeros currently in the string.
An edge connects z → z' if we can move by flipping exactly k positions.
The transition is:

Choose i zeros to flip (where ilo ≤ i ≤ ihi),
then the new number of zeros is z' = z + k - 2*i.
We perform BFS starting from the initial zero count.
We maintain a queue, distance array, and sets to efficiently find reachable states that match the correct parity.
Once we reach state 0, we return the distance.

__Complexity__
Time complexity:
Each state (0..n) is visited at most once.
Each state transition considers values of i but with efficient set usage this becomes roughly O(n log n).
Space complexity:
We store O(n) for distances and sets → O(n).

```
Runtime: 619 ms, Beats 30.77%
Memory: 165.04 MB, Beats 7.69%
```
```c++
class Solution {
public:
    int minOperations(string s, int k) {
        int n = s.size(), z0 = 0;
        for (char c:s) {
            if (c == '0') {
                z0 += 1;
            }
        }
        if (z0 == 0) {
            return 0;
        }
        vector<int> dist(n + 1, -1);
        set<int> rem[2];
        for (int v = 0; v <= n; v ++) {
            rem[v&1].insert(v);
        }
        queue<int> q;
        dist[z0] = 0;
        rem[z0 & 1].erase(z0);
        q.push(z0);
        auto push = [&](int v,int d){
            dist[v] = d;
            rem[v & 1].erase(v);
            q.push(v);
        };
        while (!q.empty()){
            int z = q.front();
            q.pop();
            int d = dist[z];
            int ilo = max(0, k - (n - z));
            int ihi = min(k, z);
            int L = z + k - 2 * ihi;
            int R = z + k - 2 * ilo;
            if (L < 0) {
                L = 0;
            }
            if (R > n) {
                R = n;
            }
            int parity = (z + k) & 1;
            auto it = rem[parity].lower_bound(L);
            while (it != rem[parity].end() && *it <= R){
                int v = *it;
                ++it;                          // advance before erase
                push(v, d + 1);
                if (v == 0) {
                    return d+1;
                }
            }
        }
        return -1;

    }
};
```
