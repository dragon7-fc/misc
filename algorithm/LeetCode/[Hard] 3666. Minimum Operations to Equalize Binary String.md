3666. Minimum Operations to Equalize Binary String

You are given a binary string `s`, and an integer `k`.

In one operation, you must choose **exactly** `k` different indices and flip each `'0'` to `'1'` and each `'1'` to `'0'`.

Return the **minimum** number of operations required to make all characters in the string equal to `'1'`. If it is not possible, return -1.

 

**Example 1:**
```
Input: s = "110", k = 1

Output: 1

Explanation:

There is one '0' in s.
Since k = 1, we can flip it directly in one operation.
```

**Example 2:**
```
Input: s = "0101", k = 3

Output: 2

Explanation:

One optimal set of operations choosing k = 3 indices in each operation is:

Operation 1: Flip indices [0, 1, 3]. s changes from "0101" to "1000".
Operation 2: Flip indices [1, 2, 3]. s changes from "1000" to "1111".
Thus, the minimum number of operations is 2.
```

**Example 3:**
```
Input: s = "101", k = 2

Output: -1

Explanation:

Since k = 2 and s has only one '0', it is impossible to flip exactly k indices to make all '1'. Hence, the answer is -1.
```
 

**Constraints:**

* `1 <= s.length <= 10^5`
* `s[i]` is either `'0'` or `'1'`.
* `1 <= k <= s.length`

# Submissions
---
**Solution 1: (Model Solution)**

__Intuition__
We are given a binary string and allowed to flip exactly k characters in each operation.
The state of the system can be described by how many '0's remain in the string.
From a given count of zeros z, after one operation the number of zeros changes deterministically depending on how many zeros are flipped.
This suggests a shortest path problem on states 0..n where n is the string length.

__Approach__
We model the problem as a graph:

Each node = number of zeros currently in the string.
An edge connects z → z' if we can move by flipping exactly k positions.
The transition is:

Choose i zeros to flip (where ilo ≤ i ≤ ihi),
then the new number of zeros is z' = z + k - 2*i.
We perform BFS starting from the initial zero count.
We maintain a queue, distance array, and sets to efficiently find reachable states that match the correct parity.
Once we reach state 0, we return the distance.

__Complexity__
Time complexity:
Each state (0..n) is visited at most once.
Each state transition considers values of i but with efficient set usage this becomes roughly O(n log n).
Space complexity:
We store O(n) for distances and sets → O(n).

```
Runtime: 619 ms, Beats 30.77%
Memory: 165.04 MB, Beats 7.69%
```
```c++
class Solution {
public:
    int minOperations(string s, int k) {
        int n=s.size();
        int z0=0;
        for(char c:s) if(c=='0') ++z0;
        if(z0==0) return 0;

        vector<int> dist(n+1,-1);
        set<int> rem[2];
        for(int v=0;v<=n;++v) rem[v&1].insert(v);

        queue<int> q;
        dist[z0]=0;
        rem[z0&1].erase(z0);
        q.push(z0);

        auto push=[&](int v,int d){
            dist[v]=d;
            rem[v&1].erase(v);
            q.push(v);
        };

        while(!q.empty()){
            int z=q.front(); q.pop();
            int d=dist[z];

            int ilo=max(0, k-(n-z));
            int ihi=min(k, z);
            int L = z + k - 2*ihi;
            int R = z + k - 2*ilo;
            if(L<0) L=0;
            if(R>n) R=n;

            int parity=(z+k)&1;
            auto it=rem[parity].lower_bound(L);
            while(it!=rem[parity].end() && *it<=R){
                int v=*it;
                ++it;                          // advance before erase
                push(v,d+1);
                if(v==0) return d+1;
            }
        }
        return -1;
    }
};
```
