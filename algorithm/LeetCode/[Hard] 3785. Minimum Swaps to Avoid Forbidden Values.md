3785. Minimum Swaps to Avoid Forbidden Values

You are given two integer arrays, `nums` and `forbidden`, each of length `n`.

You may perform the following operation any number of times (including zero):

* Choose two distinct indices `i` and `j`, and swap `nums[i]` with `nums[j]`.

Return the **minimum** number of swaps required such that, for every index `i`, the value of `nums[i]` is not equal to `forbidden[i]`. If no amount of swaps can ensure that every index avoids its forbidden value, return `-1`.

 

**Example 1:**
```
Input: nums = [1,2,3], forbidden = [3,2,1]

Output: 1

Explanation:

One optimal set of swaps:

Select indices i = 0 and j = 1 in nums and swap them, resulting in nums = [2, 1, 3].
After this swap, for every index i, nums[i] is not equal to forbidden[i].
```

**Example 2:**
```
Input: nums = [4,6,6,5], forbidden = [4,6,5,5]

Output: 2

Explanation:

One optimal set of swaps:
Select indices i = 0 and j = 2 in nums and swap them, resulting in nums = [6, 6, 4, 5].
Select indices i = 1 and j = 3 in nums and swap them, resulting in nums = [6, 5, 4, 6].
After these swaps, for every index i, nums[i] is not equal to forbidden[i].
```

**Example 3:**
```
Input: nums = [7,7], forbidden = [8,7]

Output: -1

Explanation:

It is not possible to make nums[i] different from forbidden[i] for all indices.
```

**Example 4:**
```
Input: nums = [1,2], forbidden = [2,1]

Output: 0

Explanation:

No swaps are required because nums[i] is already different from forbidden[i] for all indices, so the answer is 0.
```
 

**Constraints:**

* `1 <= n == nums.length == forbidden.length <= 10^5`
* `1 <= nums[i], forbidden[i] <= 10^9`

# Submissions
---
**Solution 1: (Greedy)**

Intuition
The problem asks for the minimum swaps to ensure no value nums[i] sits at a forbidden index forbidden[i].

My first thought is that this is a Greedy problem. We want to maximize the efficiency of our swaps.

Best Case: Swap two "bad" indices (where nums[i] == forbidden[i]) with each other. If we pick the right pair, one swap fixes two conflicts.
Worst Case: We can't pair them up, so we just swap a "bad" index with a "good" one elsewhere. One swap fixes one conflict.
However, before we start swapping, we must check if a solution is even possible using the Pigeonhole Principle. If we have more instances of a number X than there are allowed spots for it, we must return -1 immediately.

Approach
Feasibility Check: First, we verify if a valid arrangement exists. For every distinct number num in the array:

Count how many times it appears in nums (cnt).
Count how many times it is blocked in forbidden (blocked).
The total available slots for num is n - blocked.
If cnt > n - blocked, it is impossible to place all instances of num validly. Return -1.
Identify Conflicts: We iterate through the array to find indices where nums[i] == forbidden[i]. These are our "conflicts."

We track totalConflicts: The total count of such bad indices.
We track maxFreq: The maximum frequency of any single value among these conflicts. This is crucial because we cannot swap a value with itself (e.g., swapping a bad 5 with another bad 5 solves nothing).
Greedy Logic: We want to pair up conflicts to perform "Best Case" swaps.

To form a valid pair that fixes 2 conflicts, the two numbers must be different.
If one number dominates the conflicts (maxFreq is high), it limits the number of pairs we can form. We can only pair the "minority" numbers with the "majority" number.
Max Pairs Formula: pairs = min(totalConflicts / 2, totalConflicts - maxFreq).
totalConflicts / 2 covers the case where values are well-distributed.
totalConflicts - maxFreq covers the case where one value dominates (we pair all non-majority values).
Result: Each pair saves us 1 extra move. Result = totalConflicts - pairs.

Complexity
Time complexity: O(n)
Space complexity: O(n)

    nums = [4,6,6,5], forbidden = [4,6,5,5]

n               4
                  4 5 6
numsCnt           1 1 2
forbiddenCnt      1 2 1
badCnts           1 1 1
totalConflicts  3  
maxFreq         1
pairs           1

```
Runtime: 361 ms, Beats 31.25%
Memory: 308.34 MB, Beats 31.25%
```
```c++
class Solution {
public:
    int minSwaps(vector<int>& nums, vector<int>& forbidden) {
        int n = nums.size();

        // Maps for feasibility check
        unordered_map<int, int> numsCnt;
        unordered_map<int, int> forbiddenCnt;

        for(int i = 0 ; i < n ;i++){
            numsCnt[nums[i]]++;
            forbiddenCnt[forbidden[i]]++;
        }

        // 1. Feasibility Check (Pigeonhole Principle)
        for(auto const& [num, cnt] : numsCnt){
            // If the count of a number exceeds available valid spots
            if(cnt > n - forbiddenCnt[num])
                return -1;
        }

        // 2. Count Conflicts and Find Majority Bad Element
        int totalConflicts = 0;
        int maxFreq = 0;
        unordered_map<int, int> badCnts;

        for(int i = 0 ; i < n ; i++){
            if(nums[i] == forbidden[i]){
                totalConflicts++;
                badCnts[nums[i]]++;
                maxFreq = max(maxFreq, badCnts[nums[i]]);
            }
        }

        if(totalConflicts == 0) return 0;

        // 3. Calculate Swaps
        // We try to pair up conflicts (1 swap fixes 2). 
        // We are limited by either total pairs possible OR the "majority" element constraint.
        int pairs = min(totalConflicts / 2, totalConflicts - maxFreq);

        // Total swaps = (Pairs * 1) + (Remaining * 1) 
        // This simplifies to: TotalConflicts - Pairs
        return totalConflicts - pairs;
    }
};
```
