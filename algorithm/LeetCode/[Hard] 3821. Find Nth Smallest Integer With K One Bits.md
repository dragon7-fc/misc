3821. Find Nth Smallest Integer With K One Bits

You are given two positive integers `n` and `k`.

Return an integer denoting the `n`th smallest positive integer that has **exactly** `k` ones in its binary representation. It is guaranteed that the answer is **strictly** less than `2^50`.

 

**Example 1:**
```
Input: n = 4, k = 2

Output: 9

Explanation:

The 4 smallest positive integers that have exactly k = 2 ones in their binary representations are:

3 = 112
5 = 1012
6 = 1102
9 = 10012
```

**Example 2:**
```
Input: n = 3, k = 1

Output: 4

Explanation:

The 3 smallest positive integers that have exactly k = 1 one in their binary representations are:

1 = 12
2 = 102
4 = 1002
```

**Constraints:**

* `1 <= n <= 2^50`
* `1 <= k <= 50`
* The answer is strictly less than `2^50`.

# Submissions
---
**Solution 1: (Combination + Bit)**

__Intuition__
The goal is to find the n-th smallest positive integer
with exactly k bits set to 1.
Since the answer is less than 2^50,
we determine each bit from position 49 down to 0.

Combinatorial Precomputation
We use Pascal's triangle to fill a 2D array comb.
Each comb[i][j] stores the value of comb(i, j),
which represents how many ways
we can choose j bits from i available positions.

Greedy Bit Construction
For each bit position i from 49 to 0:
We check c = comb[i][k],
the number of integers that could be formed
if the i-th bit is kept as 0.

If n > c,
the n-th number must have the i-th bit set to 1.
We then subtract n -= c and k -= 1

Termination The loop ends when k = 0,
meaning all required 1 bits are placed.

Returns the final res the n-th smallest integer.

__Complexity__
Time O(50 * 50)
Space O(50 * 50)

```
Runtime: 4 ms, Beats 50.10%
Memory: 10.02 MB, Beats 29.08%
```
```c++
class Solution {
public:
    long long nthSmallest(long long n, int k) {
        long long comb[51][51] = {0};
        for (int i = 0; i <= 50; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];
            }
        }
        long long res = 0, c = 0;
        for (int i = 49; i >= 0; i--) {
            c = comb[i][k];
            if (n > c) {
                res |= 1LL << i;
                n -= c;
                if (--k == 0)
                    break;
            }
        }
        return res;
    }
};
```
