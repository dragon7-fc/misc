2281. Sum of Total Strength of Wizards

As the ruler of a kingdom, you have an army of wizards at your command.

You are given a **0-indexed** integer array `strength`, where `strength[i]` denotes the strength of the `i`th wizard. For a **contiguous** group of wizards (i.e. the wizards' strengths form a **subarray** of `strength`), the **total strength** is defined as the product of the following two values:

* The strength of the **weakest** wizard in the group.
* The **total** of all the individual strengths of the wizards in the group.

Return the **sum** of the total strengths of **all** contiguous groups of wizards. Since the answer may be very large, return it **modulo** `10^9 + 7`.

A **subarray** is a contiguous **non-empty** sequence of elements within an array.

 

**Example 1:**
```
Input: strength = [1,3,1,2]
Output: 44
Explanation: The following are all the contiguous groups of wizards:
- [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1
- [3] from [1,3,1,2] has a total strength of min([3]) * sum([3]) = 3 * 3 = 9
- [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1
- [2] from [1,3,1,2] has a total strength of min([2]) * sum([2]) = 2 * 2 = 4
- [1,3] from [1,3,1,2] has a total strength of min([1,3]) * sum([1,3]) = 1 * 4 = 4
- [3,1] from [1,3,1,2] has a total strength of min([3,1]) * sum([3,1]) = 1 * 4 = 4
- [1,2] from [1,3,1,2] has a total strength of min([1,2]) * sum([1,2]) = 1 * 3 = 3
- [1,3,1] from [1,3,1,2] has a total strength of min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5
- [3,1,2] from [1,3,1,2] has a total strength of min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6
- [1,3,1,2] from [1,3,1,2] has a total strength of min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7
The sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.
```

**Example 2:**
```
Input: strength = [5,4,6]
Output: 213
Explanation: The following are all the contiguous groups of wizards: 
- [5] from [5,4,6] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25
- [4] from [5,4,6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16
- [6] from [5,4,6] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36
- [5,4] from [5,4,6] has a total strength of min([5,4]) * sum([5,4]) = 4 * 9 = 36
- [4,6] from [5,4,6] has a total strength of min([4,6]) * sum([4,6]) = 4 * 10 = 40
- [5,4,6] from [5,4,6] has a total strength of min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60
The sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213.
```

**Constraints:**

* `1 <= strength.length <= 10^5`
* `1 <= strength[i] <= 10^9`

# Submissions
---
**Solution 1: (Stack)**
```
Runtime: 2010 ms
Memory Usage: 33.9 MB
```
```python
class Solution:
    def totalStrength(self, strength: List[int]) -> int:
        mod = 10 ** 9 + 7
        n = len(strength)
        
        # next small on the right
        right = [n] * n
        stack = []
        for i in range(n):
            while stack and strength[stack[-1]] > strength[i]:
                right[stack.pop()] = i
            stack.append(i)

        # next small on the left
        left = [-1] * n
        stack = []
        for i in range(n-1, -1, -1):
            while stack and strength[stack[-1]] >= strength[i]:
                left[stack.pop()] = i
            stack.append(i)

        # for each A[i] as minimum, calculate sum
        res = 0
        acc = list(accumulate(accumulate(strength), initial = 0))
        for i in range(n):
            l, r = left[i], right[i]
            lacc = acc[i] - acc[max(l, 0)]
            racc = acc[r] - acc[i]
            ln, rn = i - l, r - i
            res += strength[i] * (racc * ln - lacc * rn) % mod
        return res % mod
```

**Solution 2: (Stack, left and right)**

                    v
             3      x
             2            x
             1   x     x
                    -
                 ----
                    ----
                 -------
                    -------
                 ----------
    strength = [ 1, 3, 1, 2]
    prefix     [ 0, 1, 4, 5, 7]
    prefix_sum [ 0, 1, 5,10,12, 0]
    left       [-1, 0,-1, 2]
    right      [ 2, 2, 4, 4]


       ...             ... 
                  x
    x               
                             x
    ^left         ^i         ^right
     [left+1  ..  i]                = prefix[i + 1] - prefix[left + 1]
     [left+1 ..    i+1]             = prefix[i + 2] - prefix[left + 1]
     ...               
     [left+1 ..       right-1]      = prefix[right] - prefix[left + 1]
      [left+2 ..  i]                = prefix[i + 1] - prefix[left + 2]
      [left+2 ..   i+1]             = prefix[i + 2] - prefix[left + 2]
      ...
      [left+2 ..      right-1]      = prefix[right] - prefix[left + 2]
                  [i]               = prefix[i + 1] - prefix[i]
                  [i i+1]           = prefix[i + 2] - prefix[i]
      ...
                  [i..right-1]      = prefix[right] - prefix[i]
                                      -------------
                  +                   (prefix[i + 1] + prefix[i + 2] + ... + prefix[right]) * (i - left)
                                                      ----------
                  -                                   (prefix[left + 1] + prefix[left + 2] + ... + prefix[i]) * (right - i)
```
Runtime: 37 ms, Beats 77.05%
Memory: 110.25 MB, Beats 11.48%
```
```c++
class Solution {
public:
    int totalStrength(vector<int>& strength) {
        int n = strength.size(), i, MOD = 1e9 + 7;
        vector<long long> prefix(n + 1);
        for (i = 0; i < n; i ++) {
            prefix[i + 1] = (prefix[i] + strength[i]) % MOD;
        }
        vector<long long> prefix_sum(n + 2);
        for (i = 0; i <= n; i ++) {
            prefix_sum[i + 1] = (prefix_sum[i] + prefix[i]) % MOD;
        }
        vector<int> left(n);
        vector<int> stk;
        for (i = 0; i < n; i ++) {
            while (!stk.empty() && strength[stk.back()] >= strength[i]) {
                stk.pop_back();
            }
            left[i] = stk.empty() ? -1 : stk.back();
            stk.push_back(i);
        }
        vector<int> right(n);
        stk.clear();
        for (i = n - 1; i >= 0; i --) {
            while (!stk.empty() && strength[stk.back()] > strength[i]) {
                stk.pop_back();
            }
            right[i] = stk.empty() ? n : stk.back();
            stk.push_back(i);
        }

        long long ans = 0;
        for (i = 0; i < n; i ++) {
            ans = (ans + (((((prefix_sum[right[i] + 1] - prefix_sum[i + 1]) * (i - left[i]) - (prefix_sum[i + 1] - prefix_sum[left[i] + 1]) * (right[i] - i)) % MOD + MOD) % MOD) * strength[i])) % MOD;
        }
        return ans;

    }
};
```
