3321. Find X-Sum of All K-Long Subarrays II

You are given an array `nums` of `n` integers and two integers `k` and `x`.

The **x-sum** of an array is calculated by the following procedure:

* Count the occurrences of all elements in the array.
* Keep only the occurrences of the top `x` most frequent elements. If two elements have the same number of occurrences, the element with the **bigger** value is considered more frequent.
* Calculate the sum of the resulting array.

**Note** that if an array has less than `x` distinct elements, its **x-sum** is the sum of the array.

Return an integer array answer of length `n - k + 1` where `answer[i]` is the **x-sum** of the **subarray** `nums[i..i + k - 1]`.

 

**Example 1:**
```
Input: nums = [1,1,2,2,3,4,2,3], k = 6, x = 2

Output: [6,10,12]

Explanation:

For subarray [1, 1, 2, 2, 3, 4], only elements 1 and 2 will be kept in the resulting array. Hence, answer[0] = 1 + 1 + 2 + 2.
For subarray [1, 2, 2, 3, 4, 2], only elements 2 and 4 will be kept in the resulting array. Hence, answer[1] = 2 + 2 + 2 + 4. Note that 4 is kept in the array since it is bigger than 3 and 1 which occur the same number of times.
For subarray [2, 2, 3, 4, 2, 3], only elements 2 and 3 are kept in the resulting array. Hence, answer[2] = 2 + 2 + 2 + 3 + 3.
```

**Example 2:**
```
Input: nums = [3,8,7,8,7,5], k = 2, x = 2

Output: [11,15,15,15,12]

Explanation:

Since k == x, answer[i] is equal to the sum of the subarray nums[i..i + k - 1].
```
 

**Constraints:**

* `nums.length == n`
* `1 <= n <= 10^5`
* `1 <= nums[i] <= 10^9`
* `1 <= x <= k <= nums.length`

# Submissions
---
**Solution 1: (Sliding Window, top and bottom set)**
```
Runtime: 880 ms
Memory: 293.61 MB
```
```c++
class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        vector<long long> res;
        unordered_map<int, int> cnt;
        set<pair<long long, int>, greater<pair<long long, int>>> top, bot;
        long long running_sum = 0;
        for (int i = 0; i < nums.size(); ++i) {
            long long count = cnt[nums[i]];
            if (count) {
                if (auto it = bot.find({count, nums[i]}); it != end(bot))
                    bot.erase(it);
                else {
                    top.erase({count, nums[i]});
                    running_sum -= count * nums[i];               
                }
            }
            cnt[nums[i]] = count + 1;
            top.insert({count + 1, nums[i]});
            running_sum += (count + 1) * nums[i];  
            if (top.size() > x) {
                auto it_top = prev(end(top));
                running_sum -= it_top->first * it_top->second;
                bot.insert({it_top->first, it_top->second});
                top.erase(it_top);
            }
            if (i >= k) {
                int count = cnt[nums[i - k]];
                if (auto it = bot.find({count, nums[i - k]}); it != end(bot))
                    bot.erase(it);
                else {
                    it = top.find({count, nums[i - k]});
                    running_sum -= it->first * it->second; 
                    top.erase(it);
                }
                if (count > 1)
                    bot.insert({count - 1, nums[i - k]});
                --cnt[nums[i - k]];
                if (top.size() < x)
                    if (auto it = begin(bot); it != end(bot)) {
                        running_sum += it->first * it->second;
                        top.insert({it->first, it->second});
                        bot.erase(it);
                    }
            }
            if (i + 1 >= k)
                res.push_back(running_sum);
        }
        return res;
    }
};
```

**Solution 2: (Sliding Window, top and bottom set)**
```
Runtime: 874 ms, Beats 64.06%
Memory: 345.13 MB, Beats 10.94%
```
```c++
class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size(), i, j = 0;
        unordered_map<int, int> cnt;
        set<pair<int, int>> bottom, top;
        long long a = 0;
        vector<long long> ans(n - k + 1);
        for (i = 0; i < n; i++) {
            if (cnt[nums[i]]) {
                if (bottom.count({cnt[nums[i]], nums[i]})) {
                    bottom.erase({cnt[nums[i]], nums[i]});
                } else {
                    a -= 1LL * nums[i] * cnt[nums[i]];
                    top.erase({cnt[nums[i]], nums[i]});
                }
            }
            cnt[nums[i]] += 1;
            bottom.insert({cnt[nums[i]], nums[i]});
            while (top.size() < x && bottom.size()) {
                auto [ck, b] = *bottom.rbegin();
                a += 1LL * ck * b;
                bottom.erase(prev(bottom.end()));
                top.insert({ck, b}); 
            }
            while (top.size() && bottom.size() && *top.begin() < *bottom.rbegin()) {
                bottom.insert(*top.begin());
                a -= 1LL * top.begin()->first * top.begin()->second;
                top.erase(top.begin());
                top.insert(*bottom.rbegin());
                a += 1LL * bottom.rbegin()->first * bottom.rbegin()->second;
                bottom.erase(prev(bottom.end()));
            }
            if (i >= k - 1) {
                ans[i - k + 1] = a;
                if (bottom.count({cnt[nums[i - k + 1]], nums[i - k + 1]})) {
                    bottom.erase({cnt[nums[i - k + 1]], nums[i - k + 1]});
                } else {
                    a -= 1LL * nums[i - k + 1] * cnt[nums[i - k + 1]];
                    top.erase({cnt[nums[i - k + 1]], nums[i - k + 1]});
                }
                cnt[nums[i - k + 1]] -= 1;
                if (cnt[nums[i - k + 1]]) {
                    bottom.insert({cnt[nums[i - k + 1]], nums[i - k + 1]});
                }
            }
        }
        return ans;
    }
};
```
