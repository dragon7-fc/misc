3699. Number of ZigZag Arrays I

You are given three integers `n`, `l`, and `r`.

A **ZigZag** array of length `n` is defined as follows:

* Each element lies in the range `[l, r]`.
* No **two adjacent** elements are equal.
* No **three** consecutive elements form a **strictly increasing** or **strictly decreasing** sequence.

Return the total number of valid **ZigZag** arrays.

Since the answer may be large, return it modulo `10^9 + 7`.

A **sequence** is said to be **strictly increasing** if each element is strictly greater than its previous one (if exists).

A **sequence** is said to be **strictly decreasing** if each element is strictly smaller than its previous one (if exists).

 

**Example 1:**
```
Input: n = 3, l = 4, r = 5

Output: 2

Explanation:

There are only 2 valid ZigZag arrays of length n = 3 using values in the range [4, 5]:

[4, 5, 4]
[5, 4, 5]
```

**Example 2:**
```
Input: n = 3, l = 1, r = 3

Output: 10

Explanation:

There are 10 valid ZigZag arrays of length n = 3 using values in the range [1, 3]:

[1, 2, 1], [1, 3, 1], [1, 3, 2]
[2, 1, 2], [2, 1, 3], [2, 3, 1], [2, 3, 2]
[3, 1, 2], [3, 1, 3], [3, 2, 3]
All arrays meet the ZigZag conditions.
```
 

**Constraints:**

* `3 <= n <= 2000`
* `1 <= l < r <= 2000`

# Submissions
---
**Solution 1: (DP, Prefix Sum)**

Intuition
DP

Explanation
State:

dp[v] = number of zigzag arrays ending at value v.

Transition:

Odd step → dp[v] = sum(dp[u]) for u < v.

Even step → dp[v] = sum(dp[u]) for u > v.

Use prefix sums in left-to-right or right-to-left order to update efficiently.

Result:

res = 2 * sum(dp) % MOD (factor 2 accounts for up/down symmetry).

Complexity
With rolling array + prefix sum trick:
Time O(n(r - l))
Space O(n)

```
Runtime: 211 ms, Beats 98.92%
Memory: 11.62 MB, Beats 95.84%
```
```c++
class Solution {
public:
    int zigZagArrays(int n, int l, int r) {
        int MOD = 1e9 + 7;
        r -= l;
        vector<int> dp(r + 1, 1);
        for (int i = 1; i < n; i++) {
            int pre = 0, pre2;
            if (i & 1) {
                for (int v = 0; v <= r; v++) {
                    pre2 = pre + dp[v];
                    dp[v] = pre;
                    pre = pre2 % MOD;
                }
            } else {
                for (int v = r; v >= 0; v--) {
                    pre2 = pre + dp[v];
                    dp[v] = pre;
                    pre = pre2 % MOD;
                }
            }
        }
        int res = 0;
        for (int v : dp)
            res = (res + v) % MOD;
        return res * 2 % MOD;
    }
};
```
