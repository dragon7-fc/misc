3748. Count Stable Subarrays

You are given an integer array `nums`.

A **subarray** of `nums` is called **stable** if it contains no inversions, i.e., there is no pair of indices `i < j` such that `nums[i] > nums[j]`.

You are also given a 2D integer array queries of length `q`, where each `queries[i] = [li, ri]` represents a query. For each query `[li, ri]`, compute the number of **stable** subarrays that lie entirely within the segment `nums[li..ri]`.

Return an integer array ans of length `q`, where `ans[i]` is the answer to the `i`th query.

**Note:**

* A single element subarray is considered stable.
 

**Example 1:**
```
Input: nums = [3,1,2], queries = [[0,1],[1,2],[0,2]]

Output: [2,3,4]

Explanation:

For queries[0] = [0, 1], the subarray is [nums[0], nums[1]] = [3, 1].
The stable subarrays are [3] and [1]. The total number of stable subarrays is 2.
For queries[1] = [1, 2], the subarray is [nums[1], nums[2]] = [1, 2].
The stable subarrays are [1], [2], and [1, 2]. The total number of stable subarrays is 3.
For queries[2] = [0, 2], the subarray is [nums[0], nums[1], nums[2]] = [3, 1, 2].
The stable subarrays are [3], [1], [2], and [1, 2]. The total number of stable subarrays is 4.
Thus, ans = [2, 3, 4].
```

**Example 2:**
```
Input: nums = [2,2], queries = [[0,1],[0,0]]

Output: [3,1]

Explanation:

For queries[0] = [0, 1], the subarray is [nums[0], nums[1]] = [2, 2].
The stable subarrays are [2], [2], and [2, 2]. The total number of stable subarrays is 3.
For queries[1] = [0, 0], the subarray is [nums[0]] = [2].
The stable subarray is [2]. The total number of stable subarrays is 1.
Thus, ans = [3, 1].
```
 

**Constraints:**

* `1 <= nums.length <= 10^5`
* `1 <= nums[i] <= 10^5`
* `1 <= queries.length <= 10^5`
* `queries[i] = [li, ri]`
* `0 <= li <= ri <= nums.length - 1`

# Submissions
---
**Solution 1: (Prefix Sum)**

__Intuition__
When there is an inversion (nums[i] < nums[i - 1], e.g, [5, 6, __4__]), no subarray before nums[i] itself (e.g, [4]) can include nums[i]. It ends any contiguous non-decreasing streak.

So for each query [L, R], we want to find a way to simply sum up the streaks from L to R. These regions are monotone runs. We can handle this with a prefix sum, as every continuing subarray just adds the new streak length, naturally left-bounding the valid number of starting points to this end.

e.g, if nums = [1, 2, 3, 4, 5], there are exactly [1, 2, 3, 4, 5] subarrays ending at each index at for each index. And for [2, 4, 6, 1, 2, 3], there are exactly [1, 2, 3, 1, 2, 3]subarrays ending at each index for each index. It simply resets.

__Approach__
We use prefix sums to sum up streaks from [L, R] by calculating prefix[R] - prefix[L - 1]

However, we may overcount due to some existing streak at L. We only want streaks from [L, R], any contribution before L should be excluded.

We simply need the next inversion point from L, for example, if L lands on nums[1] = 4 for [3, 4, 5, 1], the next inversion would be at nums[3] = 1 because 1 < 5. So we can just iterate over nums in reverse and pull these inversions, akin to bottom up DP. In this case inversion[1] = 3, so we know we have a stable array from [1, 3)

Now for B = inversion[L], we can count the subarrays from L to B, and then the subarrays from B to R. For some array of length size, (size * (size + 1)) / 2 is the amount of subarrays.

However, if B passes R, then there is just one contiguous streak from L to R, so we can calculate the size of this array R - L + 1 directly.

After all this, we just need to make sure to long longour values to avoid overflow.

__Complexity__
Time complexity: O(n + q)
Space complexity: O(n + q)
q for answer

```
Runtime: 11 ms, Beats 100.00%
Memory: 259.97 MB, Beats 100.00%
```
```c++
class Solution {
public:
    vector<long long> countStableSubarrays(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int q = queries.size();

        vector<long long> prefix(n);
        prefix[0] = 1;

        int streak = 1;
        for (int i = 1; i < n; i++) {
            if (nums[i] >= nums[i - 1])
                streak++;
            else
                streak = 1;
            
            prefix[i] = prefix[i - 1] + streak; 
        }

        vector<int> inversion(n);
        inversion[n - 1] = n;

        for (int i = n - 2; i >= 0; i--) 
            if (nums[i] > nums[i + 1])
                inversion[i] = i + 1;
            else 
                inversion[i] = inversion[i + 1];

        vector<long long> ans(q);
        for (int i = 0; i < q; i++) {
            int l = queries[i][0], r = queries[i][1];

            int b = inversion[l];
            if (b > r) {
                int sizeLR = r - l + 1;
                ans[i] = (sizeLR * (long long)(sizeLR + 1)) / 2;
            } else {
                int sizeLB = b - l; 
                long long countBR = prefix[r] - prefix[b - 1];

                ans[i] = ((sizeLB * (long long)(sizeLB + 1)) / 2) + countBR;
            }
        }

        return ans;
    }
};
```
