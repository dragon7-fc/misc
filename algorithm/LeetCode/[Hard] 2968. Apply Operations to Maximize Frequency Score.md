2968. Apply Operations to Maximize Frequency Score

You are given a **0-indexed** integer array `nums` and an integer `k`.

You can perform the following operation on the array at most `k` times:

* Choose any index `i` from the array and **increase** or **decrease** `nums[i]` by `1`.

The score of the final array is the **firequency** of the most frequent element in the array.

Return the **maximum** score you can achieve.

The frequency of an element is the number of occurences of that element in the array.

 

**Example 1:**
```
Input: nums = [1,2,6,4], k = 3
Output: 3
Explanation: We can do the following operations on the array:
- Choose i = 0, and increase the value of nums[0] by 1. The resulting array is [2,2,6,4].
- Choose i = 3, and decrease the value of nums[3] by 1. The resulting array is [2,2,6,3].
- Choose i = 3, and decrease the value of nums[3] by 1. The resulting array is [2,2,6,2].
The element 2 is the most frequent in the final array so our score is 3.
It can be shown that we cannot achieve a better score.
```

**Example 2:**
```
Input: nums = [1,4,4,2,4], k = 0
Output: 3
Explanation: We cannot apply any operations so our score will be the frequency of the most frequent element in the original array, which is 3.
```

**Constraints:**

* `1 <= nums.length <= 10^5`
* `1 <= nums[i] <= 10^9`
* `0 <= k <= 10^14`

# Submissions
---
**Solution 1: (Sliding Window)**
```
Runtime: 141 ms
Memory: 85.6 MB
```
```c++
class Solution {
public:
    int maxFrequencyScore(vector<int>& nums, long long k) {
        int i = 0, n = nums.size();
        sort(nums.begin(), nums.end());
        for (int j = 0; j < n; ++j) {
            k -= nums[j] - nums[(i + j) / 2];
            if (k < 0) {
                k += nums[(i + j + 1) / 2] - nums[i++];
            }
        }
        return n - i;
    }
};
```

**Solution 2: (Binary Search)**


    d              x
    c           x  x
    b        x  x  x
    a     x  x  x  x
       0  1  2  3  4
       xxxxxxxx-----  large
       xx------       small 
       xxxxx------    large
       xx---          small

    nums = [1, 2, 6, 4], k = 3
           [1, 2, 4, 6]
            1  2  3  4
            ^l ^m    ^r
    pre    [0  1  3  7  13]
            xxxxx---           large
            xx---             small
    ans        2
            1  2  3  4 
                  ^lm^r
    ans           2
    pre    [0  1  3  7  13]
               xxxxx-------   large
               xx---          small
```
Runtime: 43 ms, Beats 53.39%
Memory: 96.85 MB, Beats 31.22%
```
```c++
class Solution {
public:
    int maxFrequencyScore(vector<int>& nums, long long k) {
        int n = nums.size(), i, left = 1, right = n, mid, ans;
        long long large, small;
        vector<long long> pre(n + 1);
        sort(nums.begin(), nums.end());
        for (i = 0; i < n; i ++) {
            pre[i + 1] = pre[i] + nums[i];
        }
        bool flag;
        while (left <= right) {
            mid = left + (right - left) / 2;
            flag = false;
            for (i = 0; i < n - mid + 1; i ++) {
                large = pre[i + mid] - pre[i + (mid + 1) / 2];
                small = pre[i + mid / 2] - pre[i];
                if (large - small <= k) {
                    ans = mid;
                    left = mid + 1;
                    flag = true;
                    break;
                }
            }
            if (!flag) {
                right = mid - 1;
            }
        }
        return ans;
    }
};
```

**Solution 3: (Sliding Window)**


            vl     vr
            --------
              ^m
              -----^r  | k
            ^l-        |
               ^m
               -----^r | k
             ^l-       |

    nums = [1, 2, 6, 4], k = 3
           [1, 2, 4, 6]
            ^i    ^j
    k   2   2  1 -1
               ^i    ^j
                  0  -2
                  ^i ^j
                     0
                  -----
ans                  2                     
                  
```
Runtime: 35 ms, Beats 76.47%
Memory: 89.86 MB, Beats 84.62%
```
```c++
class Solution {
public:
    int maxFrequencyScore(vector<int>& nums, long long k) {
        int n = nums.size(), i = 0, j;
        sort(nums.begin(), nums.end());
        for (j = 0; j < n; j ++) {
            k -= nums[j] - nums[(i + j) / 2];
            if (k < 0) {
                k += nums[(i + j + 1) / 2] - nums[i];
                i += 1;
            }
        }
        return n - i;
    }
};
```
