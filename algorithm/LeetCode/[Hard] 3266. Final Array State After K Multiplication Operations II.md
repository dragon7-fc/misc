3266. Final Array State After K Multiplication Operations II

You are given an integer array `nums`, an integer `k`, and an integer `multiplier`.

You need to perform `k` operations on `nums`. In each operation:

* Find the **minimum** value `x` in `nums`. If there are multiple occurrences of the minimum value, select the one that appears **first**.
* Replace the selected minimum value `x` with `x * multiplier`.
* After the `k` operations, apply **modulo** `109 + 7` to every value in `nums`.

Return an integer array denoting the final state of `nums` after performing all `k` operations and then applying the modulo.

 

**Example 1:**
```
Input: nums = [2,1,3,5,6], k = 5, multiplier = 2

Output: [8,4,6,5,6]

Explanation:

Operation	Result
After operation 1	[2, 2, 3, 5, 6]
After operation 2	[4, 2, 3, 5, 6]
After operation 3	[4, 4, 3, 5, 6]
After operation 4	[4, 4, 6, 5, 6]
After operation 5	[8, 4, 6, 5, 6]
After applying modulo	[8, 4, 6, 5, 6]
```

**Example 2:**
```
Input: nums = [100000,2000], k = 2, multiplier = 1000000

Output: [999999307,999999993]

Explanation:

Operation	Result
After operation 1	[100000, 2000000000]
After operation 2	[100000000000, 2000000000]
After applying modulo	[999999307, 999999993]
```

**Constraints:**

`1 <= nums.length <= 10^4`
`1 <= nums[i] <= 10^9`
`1 <= k <= 10^9`
`1 <= multiplier <= 10^6`

# Submissions
---
**Solution 1: (Math, Detect Cycle and simulate remainder | Python3)**
```
Runtime: 456 ms
Memory: 19.71 MB
```
```python
class Solution:
    def getFinalState(self, nums: List[int], k: int, multiplier: int) -> List[int]:
        if multiplier == 1:
            return nums
        MOD = 1_000_000_000 + 7
        n = len(nums)
        h = [(x,i) for i,x in enumerate(nums)]
        heapify(h)
        mx = max(nums)
        while k:
            x, i = heappop(h)
            nums[i] = x*multiplier
            heappush(h,(nums[i],i))
            k -= 1
            if x > mx:
                break
        full_cycles, rem = divmod(k,n)
        y = pow(multiplier, full_cycles, MOD)
        for _ in range(rem):
            x, i = heappop(h)
            nums[i] = x*multiplier
        return [(x*y)%MOD for x in nums]
```

**Solution 2: (Greedy)**
```
Runtime: 181 ms, Beats 24.07%
Memory: 76.19 MB, Beats 29.63%
```
```c++
const long long mod = 1000000007;
class Solution {
    long long power_mod(long long base, long long exp, long long mod) {
        long long result = 1;
        
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp = exp / 2;
        }
        // this function multiplies a number by itself n times in O(logn)
        return result;
    }
public:
    vector<int> getFinalState(vector<int>& nums, int k, int multiplier) {
        if (multiplier == 1) {
            return nums; // do not miss this!!
        }
        priority_queue <pair<long long,long long>, vector<pair<long long,long long>>, greater<>> pq;
        int n = nums.size();
        for (int i = 0; i < n; i++) pq.push({nums[i],i});
        unordered_map<int,int> m,m1;
        // m for storing number of operations at each index
        //m1 to know if all elements have got an operation
        while (1){
            if ((int)m1.size() == n || k == 0) {
                break; // no more operations or state achieved
            }
            long long x = pq.top().first, y = pq.top().second;
            pq.pop();
            x *= multiplier; pq.push({x,y});
            m1[y]++; k--;
        }
        vector<long long> v(n); // to avoid integer overflow
        // This vector will store the elements after ideal state is achieved
        while (!pq.empty()){
            long long x = pq.top().first, y = pq.top().second;
            v[y] = x;
            pq.pop();
        }
        int rep = k/n, md = k%n;
        for (int i = 0; i < n; i++) pq.push({v[i],i});
        // I had to push it again because I did not declare v initially due to contest pressure. Better to do that.
        while (!pq.empty()){
            int x = pq.top().second;
            m[x] = rep;
            if (md > 0)m[x]++,md--;
            // index x has been assigned its number of operations
            pq.pop();
        }
        // Now just compute every value while calling power_mod funtion
        for (int i = 0; i < n; i++){
            long long mlt = power_mod(multiplier, m[i], mod);
            v[i] = ((v[i]%mod)*(mlt%mod))%mod;
            nums[i] = v[i];
        }
        return nums;
    }
};
```
