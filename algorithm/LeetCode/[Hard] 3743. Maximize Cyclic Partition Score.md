3743. Maximize Cyclic Partition Score

You are given a cyclic array `nums` and an integer `k`.

Partition `nums` into at most `k` **subarrays**. As `nums` is cyclic, these subarrays may wrap around from the end of the array back to the beginning.

The **range** of a subarray is the difference between its **maximum** and **minimum** values. The **score** of a partition is the sum of subarray **ranges**.

Return the **maximum** possible score among all cyclic partitions.

 

**Example 1:**
```
Input: nums = [1,2,3,3], k = 2

Output: 3

Explanation:

Partition nums into [2, 3] and [3, 1] (wrapped around).
The range of [2, 3] is max(2, 3) - min(2, 3) = 3 - 2 = 1.
The range of [3, 1] is max(3, 1) - min(3, 1) = 3 - 1 = 2.
The score is 1 + 2 = 3.
```

**Example 2:**
```
Input: nums = [1,2,3,3], k = 1

Output: 2

Explanation:

Partition nums into [1, 2, 3, 3].
The range of [1, 2, 3, 3] is max(1, 2, 3, 3) - min(1, 2, 3, 3) = 3 - 1 = 2.
The score is 2.
```

**Example 3:**
```
Input: nums = [1,2,3,3], k = 4

Output: 3

Explanation:

Identical to Example 1, we partition nums into [2, 3] and [3, 1]. Note that nums may be partitioned into fewer than k subarrays.
```
 

**Constraints:**

* `1 <= nums.length <= 1000`
* `1 <= nums[i] <= 10^9`
* `1 <= k <= nums.length`

# Submissions
---
**Solution 1: (DP, O(N×K))**

Step 1: Handle cyclic nature using the smallest element
int j = 0;
for (int i = 0; i < nums.length; i++) {
if (nums[i] < nums[j]) j = i;
}

The array is cyclic, so we can start anywhere.
Starting from the minimum element simplifies the structure —
because when you rotate at the smallest number,
the ranges (max-min) in one direction tend to “grow” monotonically.

Step 2: Build two linearized versions
int[] a = new int[n];
for (int i = 0; i < n; i++) {
a[i] = nums[(j + i) % n];
}

int[] b = new int[n];
for (int i = 0; i < n; i++) {
b[i] = nums[(j + 1 + i) % n];
}
reverse(b);

a: rotated array starting from the minimum element

b: rotated in the opposite direction and reversed

This covers both cyclic traversal directions (clockwise and counterclockwise).

Then, we’ll compute the maximum score for each direction and take the best of both.

Step 3: DP definition (function f(a, k))

dp[i][j] = maximum score obtainable using i partitions for first j elements of a.

We’ll build this efficiently using prefix-based recurrence instead of checking every split point.

Step 4: Initialize base case (1 partition)
long mn = Long.MAX_VALUE;
long mx = Long.MIN_VALUE;

for (int j = 0; j < n; j++) {
mn = Math.min(mn, a[j]);
mx = Math.max(mx, a[j]);
dp[1][j + 1] = mx - mn;
}

If we only have 1 subarray,
the best range for first j+1 elements is simply (max - min) of those elements.

This becomes the base row for the DP table.

Step 5: Transition (main DP logic)
for (int i = 2; i <= k; i++) {
long x = Long.MIN_VALUE, y = Long.MIN_VALUE;
for (int j = i - 1; j < n; j++) {
x = Math.max(x, dp[i - 1][j] - a[j]);
y = Math.max(y, dp[i - 1][j] + a[j]);
dp[i][j + 1] = Math.max(dp[i][j], Math.max(x + a[j], y - a[j]));
}
res = Math.max(res, dp[i][n]);
}

This is the optimized recurrence that makes it O(n × k).
Let’s understand it intuitively:

Meaning of the formula:

For each i (number of partitions), we traverse the array once (over j).

The terms x and y act as running best prefixes, derived from algebraic rearrangements of max-min over contiguous segments.

What do x and y represent?

They maintain:

x = max(dp[i-1][j] - a[j])

y = max(dp[i-1][j] + a[j])

These capture the best possible “anchor point” for extending the next subarray range dynamically.

So rather than recomputing max - min for every possible split,
we dynamically update the running prefix maximums as we move forward.

Then:

x + a[j] corresponds to using a[j] as the current maximum

y - a[j] corresponds to using a[j] as the current minimum

Effect:

You get the same result as checking all previous split points (O(n²)),
but by carrying forward prefix maxima, you make it O(n) per DP layer.

Hence, overall complexity → O(n × k)

Step 6: Final result

After filling the DP:

return Math.max(f(a, k), f(b, k));

You compute both directions (a and reversed b) and return the better one.

This ensures maximum cyclic coverage, regardless of traversal direction.

Example walkthrough
Input
nums = [1, 3, 4]
k = 2

1️ Minimum element = 1 (index 0)

a = [1, 3, 4]
b = [3, 4, 1] reversed → [1, 4, 3]

2️ f(a, 2)

Base: dp[1][j] = ranges = [0, 2, 3]

Extend to 2 partitions using x/y tracking
→ best = 3 ✅

3️ f(b, 2)
→ also 3 ✅

Final answer = 3

```
Runtime: 151 ms, Beats 81.82%
Memory: 214.84 MB, Beats 9.09%
```
```c++
class Solution {
    long long f(vector<int>& a, int k) {
        int n = a.size();
        vector<vector<long long>> dp(k + 1, vector<long long>(n + 1, LLONG_MIN));

        long long mn = LLONG_MAX, mx = LLONG_MIN;

        // Base case: 1 partition
        for (int j = 0; j < n; j++) {
            mn = min<long long>(mn, a[j]);
            mx = max<long long>(mx, a[j]);
            dp[1][j + 1] = mx - mn;
        }

        long long res = dp[1][n];

        // DP for partitions 2..k
        for (int i = 2; i <= k; i++) {
            long long x = LLONG_MIN, y = LLONG_MIN;
            for (int j = i - 1; j < n; j++) {
                x = max(x, dp[i - 1][j] - a[j]);
                y = max(y, dp[i - 1][j] + a[j]);
                dp[i][j + 1] = max(dp[i][j], max(x + a[j], y - a[j]));
            }
            res = max(res, dp[i][n]);
        }

        return res;
    }
public:
    long long maximumScore(vector<int>& nums, int k) {
        int n = nums.size();

        // Step 1: Find index of minimum element (for rotation)
        int j = 0;
        for (int i = 1; i < n; i++)
            if (nums[i] < nums[j]) j = i;

        // Step 2: Build array 'a' (rotated starting from min)
        vector<int> a(n);
        for (int i = 0; i < n; i++)
            a[i] = nums[(j + i) % n];

        // Step 3: Build array 'b' (rotated + reversed)
        vector<int> b(n);
        for (int i = 0; i < n; i++)
            b[i] = nums[(j + 1 + i) % n];
        reverse(b.begin(), b.end());

        // Step 4: Compute max score for both directions
        return max(f(a, k), f(b, k));
    }
};
```
