3130. Find All Possible Stable Binary Arrays II

You are given 3 positive integers `zero`, `one`, and `limit`.

A **binary array** `arr` is called **stable** if:

* The number of occurrences of `0` in `arr` is exactly `zero`.
* The number of occurrences of `1` in `arr` is exactly `one`.
* Each **subarray** of `arr` with a size greater than `limit` must contain both `0` and `1`.

Return the total number of **stable** binary arrays.

Since the answer may be very large, return it **modulo** `10^9 + 7`.

 

**Example 1:**
```
Input: zero = 1, one = 1, limit = 2

Output: 2

Explanation:

The two possible stable binary arrays are [1,0] and [0,1].
```

**Example 2:**
```
Input: zero = 1, one = 2, limit = 1

Output: 1

Explanation:

The only possible stable binary array is [1,0,1].
```

**Example 3:**
```
Input: zero = 3, one = 3, limit = 2

Output: 14

Explanation:

All the possible stable binary arrays are [0,0,1,0,1,1], [0,0,1,1,0,1], [0,1,0,0,1,1], [0,1,0,1,0,1], [0,1,0,1,1,0], [0,1,1,0,0,1], [0,1,1,0,1,0], [1,0,0,1,0,1], [1,0,0,1,1,0], [1,0,1,0,0,1], [1,0,1,0,1,0], [1,0,1,1,0,0], [1,1,0,0,1,0], and [1,1,0,1,0,0].
```
 

**Constraints:**

* `1 <= zero, one, limit <= 1000`

# Submissions
---
**Solution 1: (DP Bottom-Up)**
```
Runtime: 64 ms
Memory: 16.29 MB
```
```c++
class Solution {
public:
    int numberOfStableArrays(int zero, int one, int limit) {
        int dp[zero+1][one+1][2];
        int mod = 1000000007;
        for (int i = 0; i <= zero; i++) {
            for (int j = 0; j <= one; j++) {
                dp[i][j][0] = dp[i][j][1] = 0;
                if (i == 0 || j == 0) {
                    if (0 < i && i <= limit) dp[i][j][0] = 1;
                    if (0 < j && j <= limit) dp[i][j][1] = 1;
                    continue;
                }
                if (i-1 >= 0) dp[i][j][0] = (dp[i-1][j][0] + dp[i-1][j][1]) % mod;
                if (i-1-limit >= 0) dp[i][j][0] = (dp[i][j][0] + mod - dp[i-1-limit][j][1]) % mod;
                if (j-1 >= 0) dp[i][j][1] = (dp[i][j-1][0] + dp[i][j-1][1]) % mod;
                if (j-1-limit >= 0) dp[i][j][1] = (dp[i][j][1] + mod - dp[i][j-1-limit][0]) % mod;
            }
        }

        return (dp[zero][one][0] + dp[zero][one][1]) % mod;
    }
};
```

**Solution 2: (DP Bottom-Up, TC: O(zero * one * limit))**


dp[x][y][z = 0/1]
= number of stable arrays with exactly x ones, y zeros, and the last element is z. (0 or 1).

dp[i][j][1] = dp[i][j-1][0] + ... + dp[i][j - limit][0]
        ...011...1
            ------
             limit
        ...011..0   dp[i][j-1][0]
...
        ...0        dp[i][j - limit][0]

    zero = 1, one = 2, limit = 1
                       vj (= 0)
        0    1    2    3  
0       0:1  0:1  0:   0: 
        1:1  1:   1:   1:  
1       0:   0:1  0:1  0: 
        1:1  1:1  1:   1: 
2       0:   0:1  0:1  0:1
        1:1  1:1  1:1  1: 
3       0:   0:   0:   0: 
        1:   1:1  1:1  1:1
^i(= 1)

```c++
class Solution {
public:
    int numberOfStableArrays(int zero, int one, int limit) {
        const int MOD = 1e9 + 7;
        vector<vector<vector<long long>>> dp(one + 1, vector<vector<long long>>(zero + 1, vector<long long>(2, 0)));
        
        for (int i = 0; i <= one; i++) {
            dp[i][0][1] = i <= limit ? 1 : 0; 
        }
        for (int i = 0; i <= zero; i++) {
            dp[0][i][0] = i <= limit ? 1 : 0; 
        }
       
        for (int i = 1; i <= one; i++) {
            for (int j = 1; j <= zero; j++) {
                for (int k = 1; k <= limit && i - k >= 0; k++) {
                    dp[i][j][1] += dp[i - k][j][0];
                    dp[i][j][1] %= MOD;
                }
                for (int k = 1; k <= limit && j - k >= 0; k++) {
                    dp[i][j][0] += dp[i][j - k][1];
                    dp[i][j][0] %= MOD;
                }
            }
        }
        return (dp[one][zero][0] + dp[one][zero][1]) % MOD;
    }
};
```

**Solution 3: (DP Bottom-Up, Prefix Sum, O(zero * one))**
```
Runtime: 1648 ms, Beats 17.24%
Memory: 624.24 MB, Beats 6.90%
```
```c++
class Solution {
public:
    int numberOfStableArrays(int zero, int one, int limit) {
        const int MOD = 1e9 + 7;
        int i, j;
        vector<vector<long long>> prefix_dp_one(one + 1, vector<long long>(zero + 1, 0));
        vector<vector<long long>> prefix_dp_zero(one + 1, vector<long long>(zero + 1, 0));
        vector<vector<vector<long long>>> dp(one + 1, vector<vector<long long>>(zero + 1, vector<long long>(2, 0)));
        for (i = 0; i <= one; i++) {
            dp[i][0][1] = i <= limit ? 1 : 0; 
            prefix_dp_one[i][0] = dp[i][0][1];
        }
        for (i = 0; i <= zero; i++) {
            dp[0][i][0] = i <= limit ? 1 : 0; 
            prefix_dp_zero[0][i] = dp[0][i][0];
        }
        for (i = 1; i <= one; i++) {
            for (j = 1; j <= zero; j++) {
                dp[i][j][1] = prefix_dp_zero[i - 1][j] % MOD;
                dp[i][j][0] = prefix_dp_one[i][j - 1] % MOD;
                if (i - limit - 1 >= 0) {
                    dp[i][j][1] = (dp[i][j][1] - prefix_dp_zero[i - limit - 1][j] + MOD) % MOD;
                }
                if (j - limit - 1 >= 0) {
                    dp[i][j][0] = (dp[i][j][0] - prefix_dp_one[i][j - limit - 1] + MOD) % MOD;
                }
                prefix_dp_zero[i][j] = (prefix_dp_zero[i - 1][j] + dp[i][j][0]) % MOD;
                prefix_dp_one[i][j] = (prefix_dp_one[i][j - 1] + dp[i][j][1]) % MOD;
            }
        }
        return (dp[one][zero][0] + dp[one][zero][1]) % MOD;
    }
};
```
