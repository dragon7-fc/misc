3455. Shortest Matching Substring

You are given a string `s` and a pattern string `p`, where p contains exactly two `'*'` characters.

The `'*'` in `p` matches any sequence of zero or more characters.

Return the length of the shortest **substring** in `s` that matches `p`. If there is no such substring, return `-1`.

**Note**: The empty substring is considered valid.
 

**Example 1:**
```
Input: s = "abaacbaecebce", p = "ba*c*ce"

Output: 8

Explanation:

The shortest matching substring of p in s is "baecebce".
```

**Example 2:**
```
Input: s = "baccbaadbc", p = "cc*baa*adb"

Output: -1

Explanation:

There is no matching substring in s.
```

**Example 3:**
```
Input: s = "a", p = "**"

Output: 0

Explanation:

The empty substring is the shortest matching substring.
```

**Example 4:**
```
Input: s = "madlogic", p = "*adlogi*"

Output: 6

Explanation:

The shortest matching substring of p in s is "adlogi".
```
 

**Constraints:**

* `1 <= s.length <= 10^5`
* `2 <= p.length <= 10^5`
* `s` contains only lowercase English letters.
* `p` contains only lowercase English letters and exactly two `'*'`.

# Submissions
---
**Solution 1: (KMP)**
```
Runtime: 76 ms, Beats -%
Memory: 138.69 MB, Beats -%
```
```c++
class Solution {
    vector<int> kmp(string s,int m){
        int n = s.length();
        vector<int> lps(n+1,0);
        for(int i=1;i<n;i++){
            int prev = lps[i-1];
            while(prev>0&&s[i]!=s[prev]){
                prev = lps[prev-1];
            }
            lps[i] = prev+(s[i]==s[prev]);
        }
        return lps;
    }
public:
    int shortestMatchingSubstring(string s, string p) {
        int n = s.length();
        int m = p.length();
        if(m==2){
            return 0;
        }
        vector<int> v;
        for(int i=0;i<m;i++){
            if(p[i]=='*'){
                v.push_back(i);
            }
        }
        string a,b,c;
        a = p.substr(0,v[0]);
        b = p.substr(v[0]+1,v[1]-v[0]-1);
        c = p.substr(v[1]+1,m-(v[1])-1);
        // cout<<a<<" "<<b<<" "<<c<<endl;
        int na = a.size();
        int nb = b.size();
        int nc = c.size();
        vector<int> v1 = kmp(a+'#'+s,na);
        vector<int> v2 = kmp(b+'#'+s,nb);
        vector<int> v3 = kmp(c+'#'+s,nc);
        
        
        v1 = vector<int>(v1.begin()+na+1,v1.end());
        v2 = vector<int>(v2.begin()+nb+1,v2.end());
        v3 = vector<int>(v3.begin()+nc+1,v3.end());
        int res = INT_MAX;
        int i=0,j=0,k=0;
        while(i+nb+nc<v1.size()){
            while(i<v1.size()&&v1[i]!=na){
                i++;
            }
            if(i>=v1.size()) break;
            while(j<v2.size()&&(j<i+nb||v2[j]!=nb)){
                j++;
            }
            if(j>=v2.size()) break;
            while(k<v3.size()&&(k<j+nc||v3[k]!=nc)){
                k++;
            }
            if(k>=v3.size()) break;
            res = min(res,k-i+na);
            i++;
        }
        return res==INT_MAX?-1:res;
    }
};
```

**Solution 2: (KMP, Two Pointers)**
```
Runtime: 108 ms, Beats 75.73%
Memory: 150.28 MB, Beats 9.71%
```
```c++
class Solution {
    vector<int> kmp(string &s, int m) {
        int n = s.length(), i, k;
        vector<int> dp(n);
        k = 0;
        for (i = 1; i < n; i ++) {
            if (s[k] == s[i]) {
                k += 1;
                dp[i] = k;
            } else {
                while (k && s[k] != s[i]) {
                    k = dp[k - 1];
                }
                if (s[k] == s[i]) {
                    k += 1;
                }
                dp[i] = k;
            }
        }
        return vector<int>(dp.begin() + m + 1, dp.end());
    }
public:
    int shortestMatchingSubstring(string s, string p) {
        int n = p.length(), i = 0, j, k = 0, na, nb, nc, ans = INT_MAX;
        string a, b, c, cs;
        vector<int> dp_a, dp_b, dp_c;
        for (j = 0; j < n; j ++) {
            if (p[j] == '*' || j == n - 1) {
                if (k == 0) {
                    a = p.substr(i, j - i);
                } else if (k == 1) {
                    b = p.substr(i, j - i);
                } else {
                    c = p.substr(i);
                }
                i = j + 1;
                k += 1;
            }
        }
        na = a.length();
        nb = b.length();
        nc = c.length();
        cs = a + "#" + s;
        dp_a = move(kmp(cs, na));
        cs = b + "#" + s;
        dp_b = move(kmp(cs, nb));
        cs = c + "#" + s;
        dp_c = move(kmp(cs, nc));
        i = 0;
        j = 0;
        k = 0;
        while (i + nb + nc < dp_a.size()){
            while (i < dp_a.size() && dp_a[i] != na) {
                i += 1;
            }
            if (i >= dp_a.size()) {
                break;
            }
            while (j < dp_b.size() && (j < i + nb || dp_b[j] != nb)) {
                j += 1;
            }
            if (j >= dp_b.size()) {
                break;
            }
            while (k < dp_c.size() && (k < j + nc || dp_c[k] != nc)) {
                k += 1;
            }
            if (k >= dp_c.size()) {
                break;
            }
            ans = min(ans, k - i + na);
            i += 1;
        }
        return ans == INT_MAX? -1 : ans;
    }
};
```
