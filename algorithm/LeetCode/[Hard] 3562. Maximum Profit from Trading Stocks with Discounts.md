3562. Maximum Profit from Trading Stocks with Discounts

You are given an integer `n`, representing the number of employees in a company. Each employee is assigned a unique ID from 1 to `n`, and employee 1 is the CEO. You are given two **1-based** integer arrays, `present` and `future`, each of length `n`, where:

* `present[i]` represents the current price at which the ith employee can buy a stock today.
* `future[i]` represents the expected price at which the ith employee can sell the stock tomorrow.

The company's hierarchy is represented by a 2D integer array `hierarchy`, where `hierarchy[i] = [ui, vi]` means that employee `ui` is the direct boss of employee `vi`.

Additionally, you have an integer `budget` representing the total funds available for investment.

However, the company has a discount policy: if an employee's direct boss purchases their own stock, then the employee can buy their stock at half the original price `(floor(present[v] / 2))`.

Return the **maximum** profit that can be achieved without exceeding the given budget.

***Note*:

* You may buy each stock at most **once**.
* You **cannot** use any profit earned from future stock prices to fund additional investments and must buy only from budget.
 

**Example 1:**
```
Input: n = 2, present = [1,2], future = [4,3], hierarchy = [[1,2]], budget = 3

Output: 5

Explanation:
```

```
Employee 1 buys the stock at price 1 and earns a profit of 4 - 1 = 3.
Since Employee 1 is the direct boss of Employee 2, Employee 2 gets a discounted price of floor(2 / 2) = 1.
Employee 2 buys the stock at price 1 and earns a profit of 3 - 1 = 2.
The total buying cost is 1 + 1 = 2 <= budget. Thus, the maximum total profit achieved is 3 + 2 = 5.
```

**Example 2:**
```
Input: n = 2, present = [3,4], future = [5,8], hierarchy = [[1,2]], budget = 4

Output: 4

Explanation:
```

```
Employee 2 buys the stock at price 4 and earns a profit of 8 - 4 = 4.
Since both employees cannot buy together, the maximum profit is 4.
```

**Example 3:**
```
Input: n = 3, present = [4,6,8], future = [7,9,11], hierarchy = [[1,2],[1,3]], budget = 10

Output: 10

Explanation:
```

```
Employee 1 buys the stock at price 4 and earns a profit of 7 - 4 = 3.
Employee 3 would get a discounted price of floor(8 / 2) = 4 and earns a profit of 11 - 4 = 7.
Employee 1 and Employee 3 buy their stocks at a total cost of 4 + 4 = 8 <= budget. Thus, the maximum total profit achieved is 3 + 7 = 10.
```

**Example 4:**
```
Input: n = 3, present = [5,2,3], future = [8,5,6], hierarchy = [[1,2],[2,3]], budget = 7

Output: 12

Explanation:
```

```
Employee 1 buys the stock at price 5 and earns a profit of 8 - 5 = 3.
Employee 2 would get a discounted price of floor(2 / 2) = 1 and earns a profit of 5 - 1 = 4.
Employee 3 would get a discounted price of floor(3 / 2) = 1 and earns a profit of 6 - 1 = 5.
The total cost becomes 5 + 1 + 1 = 7 <= budget. Thus, the maximum total profit achieved is 3 + 4 + 5 = 12.
```

**Constraints:**

* `1 <= n <= 160`
* `present.length, future.length == n`
* `1 <= present[i], future[i] <= 50`
* `hierarchy.length == n - 1`
* `hierarchy[i] == [ui, vi]`
* `1 <= ui, vi <= n`
* `ui != vi`
* `1 <= budget <= 160`
* There are no duplicate edges.
* Employee 1 is the direct or indirect boss of every employee.
* The input graph `hierarchy` is **guaranteed** to have no cycles.

# Submissions
---
**Solution 1: (DP Top-Down, Tree)**
```
Runtime: 447 ms, Beats 95.45%
Memory: 161.44 MB, Beats 9.09%
```
```c++
class Solution {
    void dfs(int u, const vector<int>& present, const vector<int>& future,
             const vector<vector<int>>& tree, vector<vector<vector<int>>>& dp, int budget) {
        // Store children dp
        vector<pair<vector<int>, vector<int>>> childDPs;

        for (int v : tree[u]) {
            dfs(v, present, future, tree, dp, budget);
            childDPs.emplace_back(dp[v][0], dp[v][1]);
        }

        for (int parentBought = 0; parentBought <= 1; ++parentBought) {
            int price = parentBought ? present[u] / 2 : present[u];
            int profit = future[u] - price;

            vector<int> curr(budget + 1, 0);

            // Option 1: don't buy u
            vector<int> base(budget + 1, 0);
            for (const auto& child : childDPs) {
                vector<int> next(budget + 1, 0);
                for (int b1 = 0; b1 <= budget; ++b1) {
                    if (base[b1] == 0 && b1 != 0) continue;
                    for (int b2 = 0; b1 + b2 <= budget; ++b2) {
                        next[b1 + b2] = max(next[b1 + b2], base[b1] + child.first[b2]);
                    }
                }
                base = move(next);
            }

            for (int b = 0; b <= budget; ++b) {
                curr[b] = max(curr[b], base[b]);
            }

            // Option 2: buy u
            if (price <= budget) {
                vector<int> baseBuy(budget + 1, 0);
                for (const auto& child : childDPs) {
                    vector<int> next(budget + 1, 0);
                    for (int b1 = 0; b1 <= budget; ++b1) {
                        if (baseBuy[b1] == 0 && b1 != 0) continue;
                        for (int b2 = 0; b1 + b2 <= budget; ++b2) {
                            next[b1 + b2] = max(next[b1 + b2], baseBuy[b1] + child.second[b2]);
                        }
                    }
                    baseBuy = move(next);
                }

                for (int b = price; b <= budget; ++b) {
                    curr[b] = max(curr[b], baseBuy[b - price] + profit);
                }
            }

            dp[u][parentBought] = move(curr);
        }
    }
public:
    int maxProfit(int n, vector<int>& present, vector<int>& future, vector<vector<int>>& hierarchy, int budget) {
        vector<vector<int>> tree(n);
        for (const auto& edge : hierarchy) {
            tree[edge[0] - 1].push_back(edge[1] - 1);
        }

        // dp[node][parentBought][budget]
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(2, vector<int>(budget + 1, 0)));
        dfs(0, present, future, tree, dp, budget);

        int ans = 0;
        for (int b = 0; b <= budget; ++b) {
            ans = max(ans, dp[0][0][b]);
        }
        return ans;
    }
};
```

**Solution 2: (Tree Dynamic Programming, DP Bottom-Up, taken not-taken, O(n * budget^2))**

dp(u,state,b):
* state = 0: the maximum profit of the subtree rooted at u with budget b when the discount is not available (that is, when the parent node is not purchased).
* state = 1: the maximum profit of the subtree rooted at u with budget b when the discount is available (the parent node must be purchased).

* Do not purchase node u
subProfit(0,b)

* Purchase node u
    * If state = 0, discounts are not available. The profit is
    subProfit(1, b − present_u) + future_u − present_u
    * If state = 1, discounts are available. The profit is
    subProfit(1, b − ⌊present_u / 2⌋) + future_u − ⌊present_u / 2⌋

    present = [4,6,8], future = [7,9,11], hierarchy = [[1,2],[1,3]], budget = 10

                      p  f
                 > 1 [4, 7]
                dp0 dp1 uSize subProfit0 subProfit1
                        18
0
1
2
3                                        6
4                                        7
5                                        7
6                3  3         3          7
7                3  3         3          7
8                3  3         3          7
9                3  3         3          7
10               10 3         3          7
              /       \
          > 3          2
           [8,11]     [6,9]
    dp0 dp1 uSize    dp0 dp1 uSize
            8                6
0
1
2
3                        6
4       7                6
5       7                6
6       7            3   6
7       7            3   6
8   3   7            3   6
9   3   7            3   6
10  3   7            3   6

```
Runtime: 320 ms, Beats 86.11%
Memory: 105.26 MB, Beats 73.61%
```
```c++
class Solution {
public:
    int maxProfit(int n, vector<int>& present, vector<int>& future, vector<vector<int>>& hierarchy, int budget) {
        vector<vector<int>> g(n);

        for (auto& e : hierarchy) {
            g[e[0] - 1].push_back(e[1] - 1);
        }

        auto dfs = [&](auto&& self,
                       int u) -> tuple<vector<int>, vector<int>, int> {
            int cost = present[u];
            int dCost = present[u] / 2;  // discounted cost

            // dp[u][state][budget]
            // state = 0: Do not purchase parent node, state = 1: Must purchase
            // parent node
            auto dp0 = vector(budget + 1, 0);
            auto dp1 = vector(budget + 1, 0);

            // subProfit[state][budget]
            // state = 0: discount not available, state = 1: discount available
            auto subProfit0 = vector(budget + 1, 0);
            auto subProfit1 = vector(budget + 1, 0);

            int uSize = cost;

            for (auto v : g[u]) {
                auto [subDp0, subDp1, vSize] = self(self, v);
                uSize += vSize;
                for (int i = budget; i >= 0; i--) {
                    for (int sub = 0; sub <= min(vSize, i); sub++) {
                        subProfit0[i] = max(subProfit0[i],
                                            subProfit0[i - sub] + subDp0[sub]);
                        subProfit1[i] = max(subProfit1[i],
                                            subProfit1[i - sub] + subDp1[sub]);
                    }
                }
            }

            for (int i = 0; i <= budget; i++) {
                dp0[i] = dp1[i] = subProfit0[i];

                if (i >= dCost) {
                    dp1[i] = max(subProfit0[i],
                                 subProfit1[i - dCost] + future[u] - dCost);
                }

                if (i >= cost) {
                    dp0[i] = max(subProfit0[i],
                                 subProfit1[i - cost] + future[u] - cost);
                }
            }

            return {dp0, dp1, uSize};
        };

        return std::get<0>(dfs(dfs, 0))[budget];
    }
};
```

**Solution 3: (Tree Dynamic Programming, DP Bottom-Up, taken not-taken, O(n * budget^2))**
```
Runtime: 297 ms, Beats 73.71%
Memory: 105.08 MB, Beats 75.33%
```
```c++
class Solution {
    tuple<vector<int>, vector<int>, int> dfs(int u, int budget, vector<vector<int>> &g, vector<int> &present, vector<int> &future) {
        int cost = present[u];
        int dCost = present[u] / 2;  // discounted cost

        // dp[u][state][budget]
        // state = 0: Do not purchase parent node, state = 1: Must purchase
        // parent node
        auto dp0 = vector<int>(budget + 1);
        auto dp1 = vector<int>(budget + 1);

        // subProfit[state][budget]
        // state = 0: discount not available, state = 1: discount available
        auto subProfit0 = vector<int>(budget + 1);
        auto subProfit1 = vector<int>(budget + 1);

        int uPrice = cost;

        for (auto v: g[u]) {
            auto &&[subDp0, subDp1, vPrice] = dfs(v, budget, g, present, future);
            uPrice += vPrice;
            for (int b = budget; b >= 0; b--) {
                for (int price = 0; price <= min(vPrice, b); price += 1) {
                    subProfit0[b] = max(subProfit0[b],
                                        subProfit0[b - price] + subDp0[price]);
                    subProfit1[b] = max(subProfit1[b],
                                        subProfit1[b - price] + subDp1[price]);
                }
            }
        }

        for (int b = 0; b <= budget; b++) {
            dp0[b] = dp1[b] = subProfit0[b];

            if (b >= dCost) {
                dp1[b] = max(subProfit0[b],
                                subProfit1[b - dCost] + future[u] - dCost);
            }

            if (b >= cost) {
                dp0[b] = max(subProfit0[b],
                                subProfit1[b - cost] + future[u] - cost);
            }
        }

        return {dp0, dp1, uPrice};
    };
public:
    int maxProfit(int n, vector<int>& present, vector<int>& future, vector<vector<int>>& hierarchy, int budget) {
        vector<vector<int>> g(n);
        for (auto& e : hierarchy) {
            g[e[0] - 1].push_back(e[1] - 1);
        }
        return std::get<0>(dfs(0, budget, g, present, future))[budget];
    }
};
```
