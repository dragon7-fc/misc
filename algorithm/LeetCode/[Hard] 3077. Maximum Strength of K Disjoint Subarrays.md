3077. Maximum Strength of K Disjoint Subarrays

You are given a **0-indexed** array of integers `nums` of length `n`, and a positive odd integer `k`.

The **strength** of `x` subarrays is defined as `strength = sum[1] * x - sum[2] * (x - 1) + sum[3] * (x - 2) - sum[4] * (x - 3) + ... + sum[x] * 1` where `sum[i]` is the sum of the elements in the `i`th subarray. Formally, strength is sum of `(-1)^{i+1} * sum[i] * (x - i + 1)` over all `i`'s such `that 1 <= i <= x`.

You need to select k disjoint **subarrays**  from `nums`, such that their **strength** is **maximum**.

Return the **maximum possible strength** that can be obtained.

Note that the selected subarrays don't need to cover the entire array.

 

**Example 1:**
```
Input: nums = [1,2,3,-1,2], k = 3
Output: 22
Explanation: The best possible way to select 3 subarrays is: nums[0..2], nums[3..3], and nums[4..4]. The strength is (1 + 2 + 3) * 3 - (-1) * 2 + 2 * 1 = 22.
```

**Example 2:**
```
Input: nums = [12,-2,-2,-2,-2], k = 5
Output: 64
Explanation: The only possible way to select 5 disjoint subarrays is: nums[0..0], nums[1..1], nums[2..2], nums[3..3], and nums[4..4]. The strength is 12 * 5 - (-2) * 4 + (-2) * 3 - (-2) * 2 + (-2) * 1 = 64.
```

**Example 3:**
```
Input: nums = [-1,-2,-3], k = 1
Output: -1
Explanation: The best possible way to select 1 subarray is: nums[0..0]. The strength is -1.
```

**Constraints:**

* `1 <= n <= 10^4`
* `-109 <= nums[i] <= 10^9`
* `1 <= k <= n`
* `1 <= n * k <= 10^6`
* `k` is odd.

# Submissions
---
**Solution 1: (DP Top-Down)**
```
Runtime: 2071 ms
Memory: 561.55 MB
```
```c++
class Solution {
    vector<vector<vector<long long>>> dp;
    long long solve(int i, long long k, bool started, vector<int> &nums){
        if (k == 0) {
            return 0;
        }
        if (i == nums.size()) {
            if (k == 1 && started) {
                return 0;
            }
            return -1e15;
        }
        if (dp[i][k][started] != -1e16) {
            return dp[i][k][started];
        }
        long long rst = -1e15;
        if (started) {
            rst = solve(i, k - 1, false, nums);
        }
        rst = max(rst, (k % 2 == 0 ? -1 : 1) * k * nums[i] + solve(i + 1, k, true, nums));
        if (!started) {
            rst = max(rst, solve(i + 1, k, false, nums));
        }
        return dp[i][k][started] = rst;
    }
public:
    long long maximumStrength(vector<int>& nums, int k) {
        dp = vector<vector<vector<long long>>> (nums.size(), vector<vector<long long>> (k + 1, vector<long long> (2, -1e16)));
        long long ans = -1e15;
        return solve(0, (long long)k, false, nums);
    }
};
```

**Solution 2: (DP Bottom-Up)**
```
Runtime: 290 ms, Beats 65.00%
Memory: 269.41 MB, Beats 63.75%
```
```c++
class Solution {
public:
    long long maximumStrength(vector<int>& nums, int k) {
        int n = nums.size(), i, j;
        vector<long long> pre_sum(n + 1);
        for (int i = 0; i < n; ++i) {
            pre_sum[i + 1] = pre_sum[i] + nums[i];
        }
        vector<vector<long long>> dp0(n + 1, vector<long long>(k + 1, LLONG_MIN)), dp1(n + 1, vector<long long>(k + 1, LLONG_MIN));
        for (i = 0; i <= n; ++i) {
            dp0[i][0] = dp1[i][0] = 0;
        }
        for (i = n - 1; i >= 0; --i) 
        {
            for (j = 1; j <= min(k, n - i); j ++) {     
                long long multiplier = (j % 2 == 1) ? 1 : -1;
               
                dp0[i][j] = max({dp0[i + 1][j], dp0[i + 1][j - 1], dp1[i + 1][j - 1]}) + static_cast<long long>(nums[i]) * static_cast<long long>(multiplier) * j;
                dp1[i][j] = max(dp0[i][j], dp1[i + 1][j]);
            }
        }

        return max(dp0[0][k], dp1[0][k]);
    }
};
```

**Solution 3: (DP Bottom-Up)**

    nums = [1,  2,  3, -1,  2], k = 3
            ---------  --   -
3           3   9  18  15  21          
                3   9  18  18
            ------------------
-2             -4  -2  20  20
                3   9  18  15
            -----------------
1                  -1   9  22
                   -4  -2  -2


    nums = [12, -2, -2, -2, -2], k = 5
            --  --  --  --  --
5           60  50  40  30  20  
             0  60  60  60  60
            ----------------------------
-4              68  68  68  68
                60  68  68  68
            ----------------------------
3                   62  62  62
                    68  68  68
            ----------------------------
-2                      66  66
                        68  68
            ----------------------------
1                           64
                             ~

    nums = [-1, -2, -3], k = 1
            --
1           -1  -1  -1  
             0  -1  -1

```
Runtime: 264 ms, Beats 70.00%
Memory: 267.79 MB, Beats 66.25%
```
```c++
class Solution {
public:
    long long maximumStrength(vector<int>& nums, int k) {
        int n = nums.size(), i, j;
        vector<vector<long long>> dp0(n, vector<long long>(k, LONG_LONG_MIN)), dp1(n, vector<long long>(k, LONG_LONG_MIN));
        dp1[0][0] = 1LL * k * nums[0];
        for (i = 1; i < n; i ++) {
            dp1[i][0] = max(dp1[i - 1][0] + 1LL * k * nums[i], 1LL * k * nums[i]);
            dp0[i][0] = max(dp0[i - 1][0], dp1[i - 1][0]);
            for (j = 1; j <= min(i, k - 1); j ++) {
                dp1[i][j] = max({dp1[i - 1][j], dp1[i - 1][j - 1], dp0[i - 1][j - 1]}) + 1LL * (k - j) * (j % 2? -1: 1) * nums[i];
                dp0[i][j] = max(dp1[i - 1][j], dp0[i - 1][j]);
            }
        }
        return max(dp1[n - 1][k - 1], dp0[n - 1][k - 1]);
    }
};
```
