2940. Find Building Where Alice and Bob Can Meet

You are given a **0-indexed** array heights of positive integers, where `heights[i]` represents the height of the `i`th building.

If a person is in building `i`, they can move to any other building `j` if and only if `i < j` and `heights[i] < heights[j]`.

You are also given another array `queries` where `queries[i] = [ai, bi]`. On the `i`th query, Alice is in building `ai` while Bob is in building `bi`.

Return an array `ans` where `ans[i]` is the **index of the leftmost building** where Alice and Bob can meet on the `i`th query. If Alice and Bob cannot move to a common building on query `i`, set `ans[i]` to `-1`.

 

**Example 1:**
```
Input: heights = [6,4,8,5,2,7], queries = [[0,1],[0,3],[2,4],[3,4],[2,2]]
Output: [2,5,-1,5,2]
Explanation: In the first query, Alice and Bob can move to building 2 since heights[0] < heights[2] and heights[1] < heights[2]. 
In the second query, Alice and Bob can move to building 5 since heights[0] < heights[5] and heights[3] < heights[5]. 
In the third query, Alice cannot meet Bob since Alice cannot move to any other building.
In the fourth query, Alice and Bob can move to building 5 since heights[3] < heights[5] and heights[4] < heights[5].
In the fifth query, Alice and Bob are already in the same building.  
For ans[i] != -1, It can be shown that ans[i] is the leftmost building where Alice and Bob can meet.
For ans[i] == -1, It can be shown that there is no building where Alice and Bob can meet.
```

**Example 2:**
```
Input: heights = [5,3,8,2,6,1,4,6], queries = [[0,7],[3,5],[5,2],[3,0],[1,6]]
Output: [7,6,-1,4,6]
Explanation: In the first query, Alice can directly move to Bob's building since heights[0] < heights[7].
In the second query, Alice and Bob can move to building 6 since heights[3] < heights[6] and heights[5] < heights[6].
In the third query, Alice cannot meet Bob since Bob cannot move to any other building.
In the fourth query, Alice and Bob can move to building 4 since heights[3] < heights[4] and heights[0] < heights[4].
In the fifth query, Alice can directly move to Bob's building since heights[1] < heights[6].
For ans[i] != -1, It can be shown that ans[i] is the leftmost building where Alice and Bob can meet.
For ans[i] == -1, It can be shown that there is no building where Alice and Bob can meet.
```

**Constraints:**

* `1 <= heights.length <= 5 * 10^4`
* `1 <= heights[i] <= 10^9`
* `1 <= queries.length <= 5 * 10^4`
* `queries[i] = [ai, bi]`
* `0 <= ai, bi <= heights.length - 1`

# Submissions
---
**Solution 1: (Mono stack)**
```
Runtime: 408 ms
Memory: 192 MB
```
```c++
class Solution {
public:
    vector<int> leftmostBuildingQueries(vector<int>& heights, vector<vector<int>>& queries) {
        int n = heights.size();
        vector<int> next(n, -1);
        stack<int> st;
        for ( int i = n-1; i >= 0; --i ) {
            while ( !st.empty() && heights[st.top()] <= heights[i] ) {
                st.pop();
            }
            if ( !st.empty() ) {
                next[i] = st.top();
            }
            st.push(i);
        } 
        vector<int> ans;
        for ( auto q : queries ) {
            if ( q[0] == q[1] ) {
                ans.push_back(q[0]);
                continue;
            }
            if ( q[0] > q[1] ) {
                swap(q[0], q[1]);
            }
            if ( heights[q[1]] > heights[q[0]] ) {
                ans.push_back(q[1]);
                continue;
            }
            if ( next[q[0]] == -1 ) {
                ans.push_back(-1);
                continue;
            }
            int i = next[q[1]];
            if ( i == -1 ) {
                ans.push_back(-1);
                continue;
            }
            while ( i >= 0 && i < n && heights[i] <= heights[q[0]] ) {
                i = next[i];
            }
            ans.push_back(i);
        }
        return ans;
    }
};
```

**Solution 2: (Sort Queries)**
```
Runtime: 394 ms
Memory: 175.1 MB
```
```c++
class Solution {
public:
    vector<int> leftmostBuildingQueries(vector<int>& heights, vector<vector<int>>& queries) {
        vector<int> mono, idx, res(queries.size());
        for (int i = 0; i < queries.size(); ++i) {
            sort(begin(queries[i]), end(queries[i]));
            if (queries[i][0] == queries[i][1] || heights[queries[i][0]] < heights[queries[i][1]])
                res[i] = queries[i][1];
            else
                idx.push_back(i);
        }
        sort(begin(idx), end(idx), [&](int i, int j) { return queries[i][1] > queries[j][1]; });
        int j = heights.size() - 1;
        for (int i : idx) {
            int a = queries[i][0], b = queries[i][1];
            while (j > b) {
                while (!mono.empty() && heights[mono.back()] <= heights[j])
                    mono.pop_back();
                mono.push_back(j--);
            }
            auto it = upper_bound(rbegin(mono), rend(mono), a, [&](int i, int j){
                return heights[i] < heights[j];
            });
            res[i] = it == rend(mono) ? -1 : *it;
        }
        return res;
    }
};
```
