3695. Maximize Alternating Sum Using Swaps

You are given an integer array `nums`.

You want to maximize the **alternating sum** of `nums`, which is defined as the value obtained by adding elements at even indices and subtracting elements at odd indices. That is, `nums[0] - nums[1] + nums[2] - nums[3]...`

You are also given a 2D integer array `swaps` where `swaps[i] = [pi, qi]`. For each pair `[pi, qi]` in `swaps`, you are allowed to swap the elements at indices `pi` and `qi`. These swaps can be performed any number of times and in any order.

Return the maximum possible **alternating sum** of `nums`.

 

**Example 1:**
```
Input: nums = [1,2,3], swaps = [[0,2],[1,2]]

Output: 4

Explanation:

The maximum alternating sum is achieved when nums is [2, 1, 3] or [3, 1, 2]. As an example, you can obtain nums = [2, 1, 3] as follows.

Swap nums[0] and nums[2]. nums is now [3, 2, 1].
Swap nums[1] and nums[2]. nums is now [3, 1, 2].
Swap nums[0] and nums[2]. nums is now [2, 1, 3].
```

**Example 2:**
```
Input: nums = [1,2,3], swaps = [[1,2]]

Output: 2

Explanation:

The maximum alternating sum is achieved by not performing any swaps.
```

**Example 3:**
```
Input: nums = [1,1000000000,1,1000000000,1,1000000000], swaps = []

Output: -2999999997

Explanation:

Since we cannot perform any swaps, the maximum alternating sum is achieved by not performing any swaps.
```
 

**Constraints:**

* `2 <= nums.length <= 10^5`
* `1 <= nums[i] <= 10^9`
* `0 <= swaps.length <= 10^5`
* `swaps[i] = [pi, qi]`
* `0 <= pi < qi <= nums.length - 1`
* `[pi, qi] != [pj, qj]`

# Submissions
---
**Solution 1: (DFS, Group)**
```
Runtime: 304 ms, Beats 46.98%
Memory: 325.58 MB, Beats 34.78%
```
```c++
class Solution {
    void dfs(int u, vector<vector<int>> &g, vector<bool> &visited, vector<vector<int>> &g2) {
        g2.back().push_back(u);
        visited[u] = true;
        for (auto v: g[u]) {
            if (!visited[v]) {
                dfs(v, g, visited, g2);
            }
        }
    }
public:
    long long maxAlternatingSum(vector<int>& nums, vector<vector<int>>& swaps) {
        int n = nums.size(), i, p, q;
        long long ans = 0;
        vector<bool> visited(n);
        vector<vector<int>> g(n), g2;
        for (auto swap: swaps) {
            p = swap[0];
            q = swap[1];
            g[p].push_back(q);
            g[q].push_back(p);
        }
        for (i = 0; i < n; i ++) {
            if (!visited[i] && g[i].size()) {
                g2.push_back({});
                dfs(i, g, visited, g2);
            }
        }
        for (i = 0; i < n; i ++) {
            if (!visited[i]) {
                if (i%2 == 0) {
                    ans += nums[i];
                } else {
                    ans -= nums[i];
                }
            }
        }
        for (auto &iv: g2) {
            int cnt = 0;
            vector<int> dp;
            for (auto j: iv) {
                if (j%2) {
                    cnt += 1;
                }
                dp.push_back(nums[j]);
            }
            sort(dp.begin(), dp.end());
            for (i = 0; i < dp.size(); i ++) {
                if (i < cnt) {
                    ans -= dp[i];
                } else {
                    ans += dp[i];
                }
            }
        }
        return ans;
    }
};
```

**Solution 2: (Union Find)**
```
Runtime: 1028 ms, Beats 29.63%
Memory: 153.56 MB, Beats 100.00%
```
```c++
class Solution(object):
    def maxAlternatingSum(self, nums, swaps):
        """
        :type nums: List[int]
        :type swaps: List[List[int]]
        :rtype: int
        """
        n = len(nums)
        f = list(range(n))

        def find(x):
            if f[x] != x:
                f[x] = find(f[x])
            return f[x]

        for i, j in swaps:
            f[find(i)] = find(j)

        groups = [[] for _ in range(n)]
        for i in range(n):
            groups[find(i)].append(i)

        res = 0
        for g in groups:
            if not g: continue
            v = sorted(nums[i] for i in g)
            odd = sum(i % 2 for i in g)
            res += sum(v) - 2 * sum(v[:odd])
        return res
```
