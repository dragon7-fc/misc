3816. Lexicographically Smallest String After Deleting Duplicate Characters

You are given a string `s` that consists of lowercase English letters.

You can perform the following operation any number of times (possibly zero times):

* Choose any letter that appears **at least twice** in the current string `s` and delete any **one** occurrence.

Return the **lexicographically smallest** resulting string that can be formed this way.

 

**Example 1:**
```
Input: s = "aaccb"

Output: "aacb"

Explanation:

We can form the strings "acb", "aacb", "accb", and "aaccb". "aacb" is the lexicographically smallest one.

For example, we can obtain "aacb" by choosing 'c' and deleting its first occurrence.
```

**Example 2:**
```
Input: s = "z"

Output: "z"

Explanation:

We cannot perform any operations. The only string we can form is "z".
```
 

**Constraints:**

* `1 <= s.length <= 10^5`
* `s` contains lowercase English letters only.

# Submissions
---
**Solution 1: (Greedy)**
```
Runtime: 189 ms, Beats 42.09%
Memory: 30.35 MB, Beats 100.00%
```
```c++
class Solution {
public:
    string lexSmallestAfterDeletion(string s) {
        int n = s.length();

        map<char,int>freq;
        for(auto ch : s) freq[ch]++;

        string ans = "";
        for(int i=0; i<n; i++) {
            if(freq[s[i]] > 1 && ( (i == n-1) || s[i] > s[i+1])) {
                freq[s[i]]--;
                while(!ans.empty() && freq[ans.back()] > 1 && ans.back() > s[i+1]) {
                    freq[ans.back()]--;
                    ans.pop_back();
                }
            }
            else ans += s[i];
        }

        return ans;
    }
};
```
