2911. Minimum Changes to Make K Semi-palindromes

Given a string `s` and an integer `k`, partition `s` into `k` **substrings** such that the sum of the number of letter changes required to turn each **substring** into a **semi-palindrome** is minimized.

Return an integer denoting the **minimum** number of letter changes required.

**Notes**

* A string is a **palindrome** if it can be read the same way from left to right and right to left.
* A string with a length of `len` is considered a **semi-palindrome** if there exists a positive integer `d` such that `1 <= d < len` and `len % d == 0`, and if we take indices that have the same modulo by `d`, they form a **palindrome**. For example, `"aa"`, `"aba"`, `"adbgad"`, and, `"abab"` are **semi-palindrome** and `"a"`, `"ab"`, and, `"abca"` are not.
* A **substring** is a contiguous sequence of characters within a string.
 

**Example 1:**
```
Input: s = "abcac", k = 2
Output: 1
Explanation: We can divide s into substrings "ab" and "cac". The string "cac" is already a semi-palindrome. If we change "ab" to "aa", it becomes a semi-palindrome with d = 1.
It can be shown that there is no way to divide the string "abcac" into two semi-palindrome substrings. Therefore, the answer would be at least 1.
```

**Example 2:**
```
Input: s = "abcdef", k = 2
Output: 2
Explanation: We can divide it into substrings "abc" and "def". Each of the substrings "abc" and "def" requires one change to become a semi-palindrome, so we need 2 changes in total to make all substrings semi-palindrome.
It can be shown that we cannot divide the given string into two substrings in a way that it would require less than 2 changes.
```

**Example 3:**
```
Input: s = "aabbaa", k = 3
Output: 0
Explanation: We can divide it into substrings "aa", "bb" and "aa".
The strings "aa" and "bb" are already semi-palindromes. Thus, the answer is zero.
```

**Constraints:**

* `2 <= s.length <= 200`
* `1 <= k <= s.length / 2`
* `s` consists only of lowercase English letters.

# Submissions
---
**Solution 1: (DP)**

__Explanation__
div[len] is a list of all factors d of len,
where 1 <= d < len and len % d == 0.

dp(i, k) means the cost to split s[:i] (i first characters of s)
into k semi-palindromes.
We will try to split out all the suffixes of s[:i].

change(i, j) means the cost to make substring s[i:j] semi-palindrome.
semi(i, j, d) means the cost to make substring s[i:j] semi-palindrome with module by d.

Finally we return dp(n, k)


__Complexity__
There are n^2 pairs of (i,j),
and have logn factors.

For funciton semi,
Time and space are O(n^2logn).

For funciton change,
Time O(n^2logn), space are O(n^2).

For funciton dp,
Time O(nnk), space are O(nk).

* Time O(nnlogn + nnk)
* Space O(n^2logn)

```
Runtime: 455 ms
Memory: 36.6 MB
```
```python
class Solution:
    def minimumChanges(self, s: str, k: int) -> int:
        div = defaultdict(lambda: [1])
        n = len(s)
        for d in range(2, n):
             for v in range(d + d, n + 1, d):
                div[v].append(d)

        @cache
        def change(i, j):
            if i + 1 >= j: return inf
            return min(semi(i, j, d) for d in div[j - i])

        @cache
        def semi(i, j, d):
            if i >= j: return 0
            return semi(i + d, j - d, d) + sum(s[i + ii] != s[j - d + ii] for ii in range(d))

        @cache
        def dp(i, k):
            if k == 1:
                return change(0, i)
            return min(dp(j, k - 1) + change(j, i) for j in range((k - 1) * 2, i - 1))

        return dp(n, k)
```

**Solution 2: (DP Top-Down, 2 level DP)**

                                MinChange(nxt + 1, k - 1)
                     vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
                      substring 2
                      change[nxt+1][nxt2]
                     vvvvvvvvvvvvv
                     vnxt+1    vnxt2
    s .........................................................
          ^ind      ^nxt 
          ^^^^^^^^^^^                                  ^^^^^^^
           change[idx][nxt]                            substring k
             substring 1
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                        MinChange(0, k)

                            n
           vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
substring  ............................................ changes[l][r]
           ^l                                        ^r
              0        1                         len - 1
           ^^^^^^^^ ^^^^^^^^ ^^^^^^^^ ^^^^^^^^ ^^^^^^^^ 
                        f
                    ^part0 ^part(f - 1)
                      ^l + i*f + part    ^l + (len - 1 - i)*f + part
```
Runtime: 179, ms Beats 82.76%
Memory: 11.56 MB, Beats 87.93%
```
```c++
class Solution {
    int dp[291][201];
    int changes[201][201];
    vector<vector<int>> fact;
    int n;
    string s;

    int ChangesForSemiPalindrome (int l, int r) {
        int n = r - l + 1;
        int ans = 1e9;
        for (auto f : fact[n]) {
            int len = n / f;
            int change = 0;
            for (int part = 0; part < f; part ++) { 
                for (int i = 0; i < len / 2; i ++) {
                    if (s[l + i * f + part] != s[l + (len - i - 1) * f + part]) {
                        change += 1;
                    }
                }
            }
            ans = min (ans, change);
        }
        return ans;
    }
    int MinChange (int ind, int k) {
        if (ind == n) {
            return (k == 0? 0 : 1e9);
        }
        if (k == 0) {
            return 1e9;
        }
        int &ans = dp[k][ind];
        if (ans != -1) {
            return ans;
        }
        ans = 1e9;
        for (int nxt = ind; nxt < n; nxt ++) {
            ans = min (ans, changes[ind][nxt] + MinChange(nxt+1, k-1));
        }
        return ans;
    }
public:
    int minimumChanges(string s, int k) {
        this->s = s;
        n = s.length();
        fact.clear();
        fact.resize(n + 1);
        for (int f = 1; f <= n; f ++) {
            for (int a = f + f; a <= n; a += f) {
                fact[a].push_back(f);
            }
        }
        for (int j = 0; j < n; j ++) {
            for (int k = j; k < n; k ++) {
                changes[j][k] = ChangesForSemiPalindrome(j, k);
            }
        }
        memset(dp, -1, sizeof(dp));
        return MinChange(0, k);
    }
};
```
