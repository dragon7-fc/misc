3671. Sum of Beautiful Subsequences

You are given an integer array `nums` of length `n`.

For every **positive** integer `g`, we define the beauty of `g` as the product of `g` and the number of strictly increasing **subsequences** of `nums` whose greatest common divisor (GCD) is exactly `g`.

Return the sum of beauty values for all positive integers `g`.

Since the answer could be very large, return it modulo `10^9 + 7`.

 

**Example 1:**
```
Input: nums = [1,2,3]

Output: 10

Explanation:

All strictly increasing subsequences and their GCDs are:

Subsequence	GCD
[1]	1
[2]	2
[3]	3
[1,2]	1
[1,3]	1
[2,3]	1
[1,2,3]	1
Calculating beauty for each GCD:

GCD	Count of subsequences	Beauty (GCD × Count)
1	5	1 × 5 = 5
2	1	2 × 1 = 2
3	1	3 × 1 = 3
Total beauty is 5 + 2 + 3 = 10.
```

**Example 2:**
```
Input: nums = [4,6]

Output: 12

Explanation:

All strictly increasing subsequences and their GCDs are:

Subsequence	GCD
[4]	4
[6]	6
[4,6]	2
Calculating beauty for each GCD:

GCD	Count of subsequences	Beauty (GCD × Count)
2	1	2 × 1 = 2
4	1	4 × 1 = 4
6	1	6 × 1 = 6
Total beauty is 2 + 4 + 6 = 12.
```
 

**Constraints:**

* `1 <= n == nums.length <= 10^4`
* `1 <= nums[i] <= 7 * 10^4`

# Submissions
---
**Solution 1: (Inclusion/Exclusion)**

Intuition
We want to count, for each possible GCD value g, how many strictly increasing subsequences have GCD exactly g.
A key observation:

If a subsequence has GCD divisible by x, then all of its elements are multiples of x.
So for each x, if we collect all numbers in the array that are divisible by x, then every subsequence in this collection contributes to some GCD that is a multiple of x.
This allows us to reduce the problem to counting strictly increasing subsequences over these filtered arrays.
Approach
Build multiples list:
For each x up to the maximum element in the array, construct
A[x]={a 
i
​
 ∈nums:x∣a 
i
​
 }
while preserving the original order.

Count increasing subsequences:
For each A[x], count the number of strictly increasing subsequences.

Use coordinate compression on values of A[x].
Apply a Fenwick tree (BIT) to count subsequences efficiently:
when processing a value v,
new=1+(number of subsequences ending with values < v).
Extract exact GCD counts:
Let num_inc(x) be the count from step 2.
This counts subsequences whose GCD is a multiple of x.
To isolate those with GCD exactly x, apply inclusion–exclusion over multiples:
dp[x]=num_inc(x)−∑ 
y=2x,3x,…
​
 dp[y].

Compute the answer:
Finally,
Answer=∑ 
x=1
max(nums)
​
 x⋅dp[x](mod10 
9
 +7).

Complexity
Time complexity:
Each number contributes to A[d] for each divisor (d) of the number.
Since the maximum number of divisors for a 
i
​
 ≤7⋅10 
4
  is at most about 128,
O(n⋅maxτ(a 
i
​
 )⋅logn)≈O(nlogn),
where τ(x) is the divisor count function.

Space complexity:
We store subsequences grouped by divisors and Fenwick trees for compressed values:
O(n⋅maxτ(a 
i
​
 ))≈O(n).

```
Runtime: 2544 ms, Beats 5.61%
Memory: 527.29 MB, Beats 5.18%
```
```c++
class Solution {
public:
    int totalBeauty(vector<int>& nums) {
        const int MOD = 1'000'000'007;
        int n = (int)nums.size();
        int maxA = *max_element(nums.begin(), nums.end());

        vector<vector<int>> divisors(maxA + 1);
        for (int d = 1; d <= maxA; ++d)
            for (int m = d; m <= maxA; m += d)
                divisors[m].push_back(d);

        vector<vector<int>> A(maxA + 1);
        A.shrink_to_fit();

        for (int x : nums) {
            for (int d : divisors[x]) A[d].push_back(x);
        }

        vector<int> num_inc(maxA + 1, 0);

        auto count_increasing = [&](const vector<int>& seq) -> int {
            if (seq.empty()) return 0;
            vector<int> vals = seq;
            sort(vals.begin(), vals.end());
            vals.erase(unique(vals.begin(), vals.end()), vals.end());
            int m = (int)vals.size();
            vector<int> bit(m + 1, 0);

            auto add = [&](int i, int v) {
                for (; i <= m; i += i & -i) {
                    int x = bit[i] + v;
                    if (x >= MOD) x -= MOD;
                    bit[i] = x;
                }
            };
            auto sum = [&](int i) {
                long long s = 0;
                for (; i > 0; i -= i & -i) {
                    s += bit[i];
                    if (s >= MOD) s -= MOD;
                }
                return (int)s;
            };

            long long total = 0;
            for (int v : seq) {
                int r = int(lower_bound(vals.begin(), vals.end(), v) - vals.begin()) + 1;
                int less = sum(r - 1);
                int add_here = less + 1;
                if (add_here >= MOD) add_here -= MOD;
                add(r, add_here);
                total += add_here;
                if (total >= MOD) total -= MOD;
            }
            return (int)(total % MOD);
        };

        for (int x = 1; x <= maxA; ++x) {
            if (!A[x].empty()) num_inc[x] = count_increasing(A[x]);
        }

        vector<int> dp(maxA + 1, 0);
        for (int x = maxA; x >= 1; --x) {
            long long v = num_inc[x];
            for (int y = x + x; y <= maxA; y += x) {
                v -= dp[y];
                if (v < 0) v += MOD;
            }
            dp[x] = (int)v;
        }

        long long ans = 0;
        for (int x = 1; x <= maxA; ++x) {
            if (dp[x]) {
                ans = (ans + 1LL * x * dp[x]) % MOD;
            }
        }
        return (int)ans;
    }
};
```
