3346. Maximum Frequency of an Element After Performing Operations II

You are given an integer array `nums` and two integers `k` and `numOperations`.

You must perform an **operawtion** `numOperations` times on `nums`, where in each operation you:

* Select an index `i` that was not selected in any previous operations.
* Add an integer in the range `[-k, k]` to `nums[i]`.

Return the **maximum** possible **frequency** of any element in `nums` after performing the **operations**.

 

**Example 1:**
```
Input: nums = [1,4,5], k = 1, numOperations = 2

Output: 2

Explanation:

We can achieve a maximum frequency of two by:

Adding 0 to nums[1]. nums becomes [1, 4, 5].
Adding -1 to nums[2]. nums becomes [1, 4, 4].
```

**Example 2:**
```
Input: nums = [5,11,20,20], k = 5, numOperations = 1

Output: 2

Explanation:

We can achieve a maximum frequency of two by:

Adding 0 to nums[1].
```

**Constraints:**

* `1 <= nums.length <= 10^5`
* `1 <= nums[i] <= 10^5`
* `0 <= k <= 10^5`
* `0 <= numOperations <= nums.length`

# Submissions
---
**Solution 1: (Sliding Window)**
```
Runtime: 183 ms
Memory: 123.29 MB
```c++
class Solution {
public:
    int maxFrequency(vector<int>& nums, int k, int numOperations) {
        int n = nums.size(), ans = 0, left = 0, right = 0;
        sort(nums.begin(), nums.end());  // Sort the array for sliding window approach

        // HashMap to store frequency of each number
        unordered_map<int, int> count;
        for (int num : nums) {
            count[num]++;
        }

        // First pass: choose an existing number as the reference point
        for (int mid = 0; mid < n; mid++) {
            // Adjust left pointer to keep nums[mid] - nums[left] within `k`
            while (nums[mid] - nums[left] > k) {
                left++;
            }

            // Adjust right pointer to keep nums[right] - nums[mid] within `k`
            while (right < n - 1 && nums[right + 1] - nums[mid] <= k) {
                right++;
            }

            int total = right - left + 1;  // Calculate range size
            // Update ans with maximum achievable frequency for nums[mid] as the target
            ans = max(ans, min(total - count[nums[mid]], numOperations) + count[nums[mid]]);
        }

        // Second pass: choose a non-existent number as reference point
        left = 0;
        for (right = 0; right < n; right++) {
            int mid = (nums[left] + nums[right]) / 2;  // Calculate hypothetical midpoint

            // Adjust left pointer to ensure midpoint is within `k` range from both ends
            while (mid - nums[left] > k || nums[right] - mid > k) {
                left++;
                mid = (nums[left] + nums[right]) / 2;
            }

            // Update ans with maximum achievable frequency with the hypothetical midpoint
            ans = max(ans, min(right - left + 1, numOperations));
        }

        return ans;
    }
};
```

**Solution 2: (Sort + Enumerate + Binary Search)**
```
Runtime: 920 ms, Beats 52.13%
Memory: 213.00 MB, Beats 54.50%
```
```c++
class Solution {
public:
    int maxFrequency(vector<int>& nums, int k, int numOperations) {
        sort(nums.begin(), nums.end());
        int ans = 0;
        unordered_map<int, int> numCount;
        set<int> modes;

        auto addMode = [&](int value) {
            modes.insert(value);
            if (value - k >= nums.front()) {
                modes.insert(value - k);
            }
            if (value + k <= nums.back()) {
                modes.insert(value + k);
            }
        };

        int lastNumIndex = 0;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] != nums[lastNumIndex]) {
                numCount[nums[lastNumIndex]] = i - lastNumIndex;
                ans = max(ans, i - lastNumIndex);
                addMode(nums[lastNumIndex]);
                lastNumIndex = i;
            }
        }

        numCount[nums[lastNumIndex]] = nums.size() - lastNumIndex;
        ans = max(ans, (int)nums.size() - lastNumIndex);
        addMode(nums[lastNumIndex]);

        auto leftBound = [&](int value) {
            int left = 0, right = nums.size() - 1;
            while (left < right) {
                int mid = (left + right) / 2;
                if (nums[mid] < value) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            return left;
        };

        auto rightBound = [&](int value) {
            int left = 0, right = nums.size() - 1;
            while (left < right) {
                int mid = (left + right + 1) / 2;
                if (nums[mid] > value) {
                    right = mid - 1;
                } else {
                    left = mid;
                }
            }
            return left;
        };

        for (int mode : modes) {
            int l = leftBound(mode - k);
            int r = rightBound(mode + k);

            int tempAns;
            if (numCount.count(mode)) {
                tempAns = min(r - l + 1, numCount[mode] + numOperations);
            } else {
                tempAns = min(r - l + 1, numOperations);
            }
            ans = max(ans, tempAns);
        }

        return ans;
    }
};
```

**Solution 3: (Sort + Enumerate + Binary Search, brute force all candidate)**
```
Runtime: 723 ms, Beats 57.35%
Memory: 213.02 MB, Beats 53.08%
```
```c++
class Solution {
public:
    int maxFrequency(vector<int>& nums, int k, int numOperations) {
        sort(nums.begin(), nums.end());
        int ans = 0;
        unordered_map<int, int> numCount;
        set<int> modes;

        auto addMode = [&](int value) {
            modes.insert(value);
            if (value - k >= nums.front()) {
                modes.insert(value - k);
            }
            if (value + k <= nums.back()) {
                modes.insert(value + k);
            }
        };

        int lastNumIndex = 0;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] != nums[lastNumIndex]) {
                numCount[nums[lastNumIndex]] = i - lastNumIndex;
                ans = max(ans, i - lastNumIndex);
                addMode(nums[lastNumIndex]);
                lastNumIndex = i;
            }
        }

        numCount[nums[lastNumIndex]] = nums.size() - lastNumIndex;
        ans = max(ans, (int)nums.size() - lastNumIndex);
        addMode(nums[lastNumIndex]);

        for (int mode : modes) {
            int l = lower_bound(nums.begin(), nums.end(), mode - k) - nums.begin();
            int r = lower_bound(nums.begin(), nums.end(), mode + k + 1) - nums.begin();

            int tempAns;
            if (numCount.count(mode)) {
                tempAns = min(r - l, numCount[mode] + numOperations);
            } else {
                tempAns = min(r - l, numOperations);
            }
            ans = max(ans, tempAns);
        }

        return ans;
    }
};
```
