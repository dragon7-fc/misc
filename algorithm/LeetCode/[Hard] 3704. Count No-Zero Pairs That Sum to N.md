3704. Count No-Zero Pairs That Sum to N

A **no-zero** integer is a **positive** integer that does not contain the digit 0 in its decimal representation.

Given an integer `n`, count the number of pairs `(a, b)` where:

* `a` and `b` are no-zero integers.
* `a + b = n`

Return an integer denoting the number of such pairs.

 

**Example 1:**
```
Input: n = 2

Output: 1

Explanation:

The only pair is (1, 1).
```

**Example 2:**
```
Input: n = 3

Output: 2

Explanation:

The pairs are (1, 2) and (2, 1).
```

**Example 3:**
```
Input: n = 11

Output: 8

Explanation:

The pairs are (2, 9), (3, 8), (4, 7), (5, 6), (6, 5), (7, 4), (8, 3), and (9, 2). Note that (1, 10) and (10, 1) do not satisfy the conditions because 10 contains 0 in its decimal representation.
```
 

**Constraints:**

`2 <= n <= 10^15`

# Submissions
---
**Solution 1: (Digit DP)**

Intuition
We need to count pairs (a, b) such that:

a + b = n

Both a and b have no zeros in their decimal form.

A brute force approach (trying all pairs) is too slow for large n, so we use digit DP — processing digits from least significant to most significant while carrying addition overflow.

Approach
We treat the addition a + b = n digit by digit from right to left (like manual addition).

At each position, we try all digits i for a and j for b (from 1–9, since zeros aren’t allowed) and keep track of:

ind: current digit index

carry: carry from previous addition

za, zb: whether we’ve used a zero digit in a or b (invalid states are avoided). If we use zero in any case then we need to take all zero from that position means number has ended. Ex - 000123

We recurse over digits ensuring i + j + carry produces the correct digit in n.
Memoization (dp) avoids recomputation of overlapping subproblems.

Complexity
Time complexity:
O(d * 9 * 9) ≈ O(81 * d) (where d = number of digits in n)

Space complexity:
Space: O(d * 2 * 2 * 2) (tiny, ~640 states)

```
Runtime: 0 ms, Beats 100.00%
Memory: 9.10 MB, Beats 100.00%
```
```c++
class Solution {
    string s;
    long long dp[20][20][2][2];

    long long solve(int ind, int carry, bool za, bool zb) {

        if (ind == s.length()) {
            if (carry) {
                return 0;
            }
            return 1;
        }

        int n = s.length();

        if (dp[ind][carry][za][zb] != -1) {
            return dp[ind][carry][za][zb];
        }

        int eda = (za ? 0 : 9);
        int edb = (zb ? 0 : 9);
        int sa = ((ind == 0) ? 1 : 0);
        int sb = ((ind == 0) ? 1 : 0);

        int num = s[ind] - '0';

        long long cnt = 0;

        for (int i = sa; i <= eda; i++) {
            for (int j = sb; j <= edb; j++) {
                int x = i + j + carry;
                if (x % 10 == num) {
                    cnt += solve(ind + 1, x / 10, za | (i == 0), zb | (j == 0));
                }
            }
        }

        return dp[ind][carry][za][zb] = cnt;
    }
public:
    long long countNoZeroPairs(long long n) {
        this->s = to_string(n);
        reverse(s.begin(), s.end());
        memset(dp, -1, sizeof(dp));

        return solve(0, 0, false, false);
    }
};
```
