3850. Count Sequences to K

You are given an integer array `nums`, and an integer `k`.

Start with an initial value `val = 1` and process nums from left to right. At each index `i`, you must choose exactly one of the following actions:

Multiply `val` by `nums[i]`.
Divide `val` by `nums[i]`.
Leave `val` unchanged.
After processing all elements, `val` is considered equal to `k` only if its final rational value exactly equals `k`.

Return the count of distinct sequences of choices that result in `val == k`.

**Note**: Division is rational (exact), not integer division. For example, `2 / 4 = 1 / 2`.

 

**Example 1:**
```
Input: nums = [2,3,2], k = 6

Output: 2

Explanation:

The following 2 distinct sequences of choices result in val == k:

Sequence	Operation on nums[0]	Operation on nums[1]	Operation on nums[2]	Final val
1	Multiply: val = 1 * 2 = 2	Multiply: val = 2 * 3 = 6	Leave val unchanged	6
2	Leave val unchanged	Multiply: val = 1 * 3 = 3	Multiply: val = 3 * 2 = 6	6
```

**Example 2:**
```
Input: nums = [4,6,3], k = 2

Output: 2

Explanation:

The following 2 distinct sequences of choices result in val == k:

Sequence  | Operation on nums[0]      | Operation on nums[1]        | Operation on nums[2]            | Final val
1         | Multiply: val = 1 * 4 = 4 | Divide: val = 4 / 6 = 2 / 3	| Multiply: val = (2 / 3) * 3 = 2 | 2
2	      | Leave val unchanged	      | Multiply: val = 1 * 6 = 6	| Divide: val = 6 / 3 = 2         | 2
```

**Example 3:**
```
Input: nums = [1,5], k = 1

Output: 3

Explanation:

The following 3 distinct sequences of choices result in val == k:

Sequence | Operation on nums[0]      | Operation on nums[1] | Final val
1	     | Multiply: val = 1 * 1 = 1 | Leave val unchanged	| 1
2	     | Divide: val = 1 / 1 = 1   | Leave val unchanged	| 1
3	     | Leave val unchanged       | Leave val unchanged	| 1
```

**Constraints:**

* `1 <= nums.length <= 19`
* `1 <= nums[i] <= 6`
* `1 <= k <= 10^15`

# Submissions
---
**Solution 1: (DP Top-Down)**

Simple clasical DP with 3 different option at each value of nums - can skip or consider for multiplication or then consider for division
also it is stated that we should match exact rational value and not the decimal truncated division, this implies - we should only consider the final value of val which is a integer as k is given integer.
To get an integer value of val, the total values computed by multiplication should be properly divided by the division.
We just track the the total value considered for multiplication and then total values considered for division and at the end we will check if the multiplication total is divisible by the total divisible value. But this will lead to TLE as this will traverse the total of 3^20 ways of check
To limit the operation we need to remove duplication and memorise the steps values. But again this is not possible by tracking the multiplication value and division values as each of them can span upto 10^10. so we cannot store 20 x 10^10 x 10^10 items.
To fix this, we have following way :
we can see the number possible are only 2 to 6. we can ignore 1, as it do not have impact on multiplication or division. So the prime factors possible are 2, 3 and 5.
we can track the number of time 2, 3 and 5 are therere in final values will help. So we take 3 variable c2, c3, and c5. For multiplication we add the factors of nums[i] to these var and for division we need to subtract there factors.

```
Runtime: 864 ms, Beats 23.96%
Memory: 160.94 MB, Beats 28.67%
```
```c++
class Solution {
    unordered_map <string, int> dp;
    int solve(vector<int>& nums, long long k, int i, int c2, int c3, int c5){
        if(i >= nums.size()){
            if(c2 >= 0 && c3 >= 0 && c5 >= 0 && (k == pow(2, c2) * pow(3, c3) * pow(5, c5))){  // Final value of val will be accumulation of each factors counts. Also if any of the count is negative then it won't result in a integer value and hence invalid value.
                return 1;
            }
            return 0;
        }
        string key = to_string(i) + "#" +  to_string(c2) + "#" + to_string(c3) + "#" + to_string(c5);
        if(dp.find(key) != dp.end()) return dp[key];

        int tc2 = (nums[i] == 4)?1:0, tc3 = 0, tc5 = (nums[i] == 5)?1:0;
        if(nums[i] % 2 == 0) tc2 ++;
        if(nums[i] % 3 == 0) tc3++;

        int ans = solve(nums, k, i+1, c2, c3, c5);              // skip
        ans += solve(nums, k, i+1, c2+tc2, c3 + tc3, c5 + tc5); // consider for multiplication
        ans += solve(nums, k, i+1, c2-tc2, c3 - tc3, c5 - tc5); // consider for division
        
        return  dp[key] = ans;
    }
public:
    int countSequences(vector<int>& nums, long long k) {
        return solve(nums, k, 0, 0, 0, 0);
    }
};
```
