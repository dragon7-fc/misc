3661. Maximum Walls Destroyed by Robots

There is an endless straight line populated with some robots and walls. You are given integer arrays `robots`, `distance`, and `walls`:
* `robots[i]` is the position of the `i`th robot.
* `distance[i]` is the maximum distance the `i`th robot's bullet can travel.
* `walls[j]` is the position of the `j`th wall.

Every robot has **one** bullet that can either fire to the left or the right at most `distance[i]` meters.

A bullet destroys every wall in its path that lies within its range. Robots are fixed obstacles: if a bullet hits another robot before reaching a wall, it **immediately stops** at that robot and cannot continue.

Return the **maximum** number of unique walls that can be destroyed by the robots.

**Notes**:

* A wall and a robot may share the same position; the wall can be destroyed by the robot at that position.
* Robots are not destroyed by bullets.
 

**Example 1:**
```
Input: robots = [4], distance = [3], walls = [1,10]

Output: 1

Explanation:

robots[0] = 4 fires left with distance[0] = 3, covering [1, 4] and destroys walls[0] = 1.
Thus, the answer is 1.
```

**Example 2:**
```
Input: robots = [10,2], distance = [5,1], walls = [5,2,7]

Output: 3

Explanation:

robots[0] = 10 fires left with distance[0] = 5, covering [5, 10] and destroys walls[0] = 5 and walls[2] = 7.
robots[1] = 2 fires left with distance[1] = 1, covering [1, 2] and destroys walls[1] = 2.
Thus, the answer is 3.
```

**Example 3:**
```
Input: robots = [1,2], distance = [100,1], walls = [10]

Output: 0

Explanation:

In this example, only robots[0] can reach the wall, but its shot to the right is blocked by robots[1]; thus the answer is 0.
```
 

**Constraints:**

* `1 <= robots.length == distance.length <= 10^5`
* `1 <= walls.length <= 10^5`
* `1 <= robots[i], walls[j] <= 10^9`
* `1 <= distance[i] <= 10^5`
* All values in `robots` are unique
* All values in `walls` are unique

# Submissions
---
**Solution 1: (DP, Binary Search)**

Intuition
At every robot we have two options either we can fire to the left or fire to the right. We can use DP to find the optimal solution to get the maximum no of walls we can break.

Approach
Dp[i][0] = Maximum no of walls i can break till i if i chose to shoot left at i
Dp[i][1] = Maximum no of walls i can break till i if i chose to shoot right at i

Complexity
Time complexity: O(nlogn)
Space complexity: O(n)

```
Runtime: 191 ms, Beats 50.00%
Memory: 192.49 MB, Beats 100.00%
```
```c++
class Solution {
public:
    int maxWalls(vector<int>& robots, vector<int>& distance, vector<int>& walls) {
        int n = robots.size();
        vector<array<int,2>> x(n);
        for(int i=0; i<n; i++) x[i][0] = robots[i],x[i][1] = distance[i];
        sort(walls.begin(),walls.end());
        sort(x.begin(),x.end());
        x.push_back({(int)1e9,0});

        // finds the no of walls in the range [l,r];
        auto query=[&](int l,int r){
            if(l>r) return 0;
            auto it1 = upper_bound(walls.begin(),walls.end(),r);
            auto it2 = lower_bound(walls.begin(),walls.end(),l);
            int res = it1-it2;
            return res;
        };
        
        vector<array<int,2>> dp(n);
        // base case
        dp[0][0] = query(x[0][0] - x[0][1],x[0][0]);
        if(n>1) dp[0][1] = query(x[0][0],min(x[1][0]-1, x[0][0]+x[0][1]));
        else dp[0][1] = query(x[0][0], x[0][0] + x[0][1]);

        //transition
        for(int i=1; i<n; i++){
            dp[i][1] = max(dp[i-1][1],dp[i-1][0]) + query(x[i][0],min(x[i+1][0]-1,x[i][0]+x[i][1]));
            
            dp[i][0] = dp[i-1][0]+ query(max(x[i][0]-x[i][1],x[i-1][0]+1),x[i][0]);
            int res = dp[i-1][1] 
                        + query(max(x[i][0]-x[i][1],x[i-1][0]+1),x[i][0]) 
                        - query(max(x[i][0]-x[i][1],x[i-1][0]+1),min(x[i-1][0]+x[i-1][1],x[i][0]-1));
            dp[i][0] = max(res,dp[i][0]);
        }
        return max(dp[n-1][0],dp[n-1][1]);
    }
};
```
