3444. Minimum Increments for Target Multiples in an Array

You are given two arrays, `nums` and `target`.

In a single operation, you may increment any element of `nums` by 1.

Return the **minimum** number of operations required so that each element in `target` has **at least** one multiple in `nums`.

 

**Example 1:**
```
Input: nums = [1,2,3], target = [4]

Output: 1

Explanation:

The minimum number of operations required to satisfy the condition is 1.

Increment 3 to 4 with just one operation, making 4 a multiple of itself.
```

**Example 2:**
```
Input: nums = [8,4], target = [10,5]

Output: 2

Explanation:

The minimum number of operations required to satisfy the condition is 2.

Increment 8 to 10 with 2 operations, making 10 a multiple of both 5 and 10.
```

**Example 3:**
```
Input: nums = [7,9,10], target = [7]

Output: 0

Explanation:

Target 7 already has a multiple in nums, so no additional operations are needed.
```
 

**Constraints:**

* `1 <= nums.length <= 5 * 10^4`
* `1 <= target.length <= 4`
* `target.length <= nums.length`
* `1 <= nums[i], target[i] <= 10^4`

# Submissions
---
**Solution 1: (DP, Bitmask)**
```
Runtime: 295 ms, Beats -%
Memory: 186.06 MB, Beats -%
```
```c++
class Solution {
    long long lcm(long long a, long long b) {
        return a / __gcd(a, b) * b;
    }
public:
    int minimumIncrements(vector<int>& nums, vector<int>& target) {
        long long k = target.size();
        unordered_map<long long, long long> mpp;

        for (long long mask = 1; mask < (1 << k); mask++) {
            vector<long long> subset;
            for (long long i = 0; i < k; i++) {
                if (mask & (1 << i)) {
                    subset.push_back(target[i]);
                }
            }
            long long currlcm = subset[0];
            for (long long j = 1; j < subset.size(); j++) {
                currlcm = lcm(currlcm, subset[j]);
            }
            mpp[mask] = currlcm;
        }

        long long fullmask = (1 << k) - 1;
        vector<long long> dp(1 << k, INT_MAX);
        dp[0] = 0;

        for (auto num : nums) {
            vector<pair<long long, long long>> maskcost;
            for (auto& entry : mpp) {
                long long mask = entry.first;
                long long lcmval = entry.second;
                long long rm = num % lcmval;
                long long cost = (rm == 0) ? 0 : (lcmval - rm);
                maskcost.emplace_back(mask, cost);
            }

            vector<long long> newdp = dp;
            for (long long prevmask = 0; prevmask < (1 << k); prevmask++) {
                if (dp[prevmask] == INT_MAX) continue;
                for (auto& mc : maskcost) {
                    long long mask = mc.first;
                    long long cost = mc.second;
                    long long nmask = prevmask | mask;
                    long long ncost = dp[prevmask] + cost;
                    if (ncost < newdp[nmask]) {
                        newdp[nmask] = ncost;
                    }
                }
            }

            dp = newdp;
        }

        return dp[fullmask] == INT_MAX ? -1 : dp[fullmask];
    }
};
```
