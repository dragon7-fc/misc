1703. Minimum Adjacent Swaps for K Consecutive Ones

You are given an integer array, `nums`, and an integer `k`. `nums` comprises of only `0`'s and `1`'s. In one move, you can choose two **adjacent** indices and swap their values.

Return the **minimum** number of moves required so that nums has `k` **consecutive** `1`'s.

 

**Example 1:**
```
Input: nums = [1,0,0,1,0,1], k = 2
Output: 1
Explanation: In 1 move, nums could be [1,0,0,0,1,1] and have 2 consecutive 1's.
```

**Example 2:**
```
Input: nums = [1,0,0,0,0,0,1,1], k = 3
Output: 5
Explanation: In 5 moves, the leftmost 1 can be shifted right until nums = [0,0,0,0,0,1,1,1].
```

**Example 3:**
```
Input: nums = [1,1,0,1], k = 2
Output: 0
Explanation: nums already has 2 consecutive 1's.
```

**Constraints:**

* `1 <= nums.length <= 105`
* `nums[i] is 0 or 1`.
* `1 <= k <= sum(nums)`

# Submissions
---
**Solution 1: (Bit Manipulations)**

**Short Explanation**

Find all index of nums[i] if nums[i] == 1.
Now the problem changes to,
find k consecute element in A,
that has minimum distance to their median sequence.
To solve this, we need to use the prefix sum of A,
which is B in this solution.


**Complexity**

* Time O(n)
* Space O(n)

```
Runtime: 1308 ms
Memory Usage: 24.4 MB
```
```python
class Solution:
    def minMoves(self, nums: List[int], k: int) -> int:
        A = [i for i, a in enumerate(nums) if a]
        n = len(A)
        B = [0] * (n + 1)
        res = float('inf')
        for i in range(n):
            B[i + 1] = B[i] + A[i]
        for i in range(len(A) - k + 1):
            res = min(res, B[i + k] - B[k // 2 + i] - B[(k + 1) // 2 + i] + B[i])
        res -= (k // 2) * ((k + 1) // 2)
        return res
```

**Solution 2: (Sliding Window, Prefix Sum, distance to median)**

    1 0 1 0 1 0 1 1 0 1 1 1, k = 5
    -   -   -   - -   - - -
total: [0, 2, 4, 6, 7, 9, 10, 11]
        <<<<----->>>>
              v
       [4  4  4  4  4]

cost = (4 - 0) + (4 - 2) + (6 - 4) + (7 - 4)
        x         x             x         x
     = (6 + 7) - (0 + 2) 
        >>>>>     <<<<<
     -> prefixsum

```
Runtime: 16 ms, Beats 39.78%
Memory: 158.42 MB, Beats 5.52%
```
```c++
class Solution {
public:
    int minMoves(vector<int>& nums, int k) {
        long long result = INT_MAX;
        vector<long long> total; //to store indices of all 1s
        for (int i = 0; i < nums.size(); i ++) {
            if (nums[i]) {
                total.push_back(i);
            }
        }   
        int n = total.size();
        vector<long long> s = {0}; //to store the prefix sum of the indices of 1s
        for (int i = 0; i < n; i ++) {
            s.push_back(s.back() + total[i]);
        }
        for (int i = k / 2; i < n - (k - 1)/ 2; i ++) {
            long long current = 1LL * k / 2 * total[i] - (s[i] - s[i - k / 2]) - 1LL * k / 2 * (k / 2 + 1) / 2; //calculate the distances to combine all left k/2 1s with the median value
            current += 1LL * s[i + 1 + (k-1) / 2] - s[i + 1] - (k - 1) / 2 * total[i] - 1LL * (k - 1) / 2 * ((k - 1) / 2 + 1) / 2; //to calculate the distances to combine all right (k-1)/2 1s with the median value
            result = min(result, current);
        }
        return result;
    }
};
```
