3806. Maximum Bitwise AND After Increment Operations

You are given an integer array `nums` and two integers `k` and `m`.

You may perform at most `k` operations. In one operation, you may choose any index `i` and increase `nums[i]` by 1.

Return an integer denoting the **maximum** possible **bitwise AND** of any **subset** of size `m` after performing up to `k` operations optimally.

 

**Example 1:**
```
Input: nums = [3,1,2], k = 8, m = 2

Output: 6

Explanation:

We need a subset of size m = 2. Choose indices [0, 2].
Increase nums[0] = 3 to 6 using 3 operations, and increase nums[2] = 2 to 6 using 4 operations.
The total number of operations used is 7, which is not greater than k = 8.
The two chosen values become [6, 6], and their bitwise AND is 6, which is the maximum possible.
```

**Example 2:**
```
Input: nums = [1,2,8,4], k = 7, m = 3

Output: 4

Explanation:

We need a subset of size m = 3. Choose indices [0, 1, 3].
Increase nums[0] = 1 to 4 using 3 operations, increase nums[1] = 2 to 4 using 2 operations, and keep nums[3] = 4.
The total number of operations used is 5, which is not greater than k = 7.
The three chosen values become [4, 4, 4], and their bitwise AND is 4, which is the maximum possible.
```

**Example 3:**
```
Input: nums = [1,1], k = 3, m = 2

Output: 2

Explanation:

We need a subset of size m = 2. Choose indices [0, 1].
Increase both values from 1 to 2 using 1 operation each.
The total number of operations used is 2, which is not greater than k = 3.
The two chosen values become [2, 2], and their bitwise AND is 2, which is the maximum possible.
```

**Constraints:**

* `1 <= n == nums.length <= 5 * 10^4`
* `1 <= nums[i] <= 10^9`
* `1 <= k <= 10^9`
* `1 <= m <= n`

# Submissions
---
**Solution 1: (Max Bits)**

Problem Statement
You are given an integer array nums and two integers k and m. You may perform at most k operations. In one operation, you may choose any index i and increase nums[i] by 1. Return an integer denoting the maximum possible bitwise AND of any subset of size m after performing up to k operations optimally.

Approach
The solution builds the maximum AND value bit by bit from the most significant bit (bit 30) to the least significant bit (bit 0). For each bit position, we check if setting that bit in the result is feasible given the budget k and the constraint of modifying at most m elements.

The key insight is that for the bitwise AND of m elements to have a particular bit set, all m elements must have that bit set. We greedily try to set higher bits first because they contribute more to the final value.

For each bit position i, we construct a candidate target t by setting bit i in our current answer a. Then for each element in nums, we calculate the minimum cost to make it compatible with target t. The cost c[j] represents the smallest value we need to add to nums[j] so that when we AND it with t, we get t.

The cost calculation works as follows:

r = t & ~v gives us the bits that are set in t but not in v (missing bits)
If r is 0, the element already has all required bits, so cost is 0
Otherwise, we find the highest missing bit h
We construct the minimum value needed by setting h and preserving bits from t below h
After computing costs for all elements, we use nth_element to find the m smallest costs efficiently in O(n) time. If the sum of the m smallest costs fits within budget k, we can set this bit in the final answer.

Dry Run
Let's trace through Example 1: nums = [3,1,2], k = 8, m = 2

Initial state: a = 0, n = 3, m = 2

Bit 30 to 3: All these bits result in targets too large, costs exceed k = 8, so they are not set.

Bit 2 (value 4):

t = 0 | 4 = 4 (binary: 100)
For nums[0] = 3 (011): r = 100 & ~011 = 100, h = 100, c[0] = 4 - 3 = 1? No wait, let me recalculate more carefully.
For nums[0] = 3 (011): missing bit 2, need to reach at least 4, cost = 1
For nums[1] = 1 (001): missing bit 2, need to reach at least 4, cost = 3
For nums[2] = 2 (010): missing bit 2, need to reach at least 4, cost = 2
m smallest costs: [1, 2], sum = 3 <= 8, so a = 4
Bit 1 (value 2):

t = 4 | 2 = 6 (binary: 110)
For nums[0] = 3 (011): missing bits 2,1, need to reach 6, cost = 3
For nums[1] = 1 (001): missing bits 2,1, need to reach 6, cost = 5
For nums[2] = 2 (010): missing bits 2,1, need to reach 6, cost = 4
m smallest costs: [3, 4], sum = 7 <= 8, so a = 6
Bit 0 (value 1):

t = 6 | 1 = 7 (binary: 111)
For nums[0] = 3: need to reach 7, cost = 4
For nums[1] = 1: need to reach 7, cost = 6
For nums[2] = 2: need to reach 7, cost = 5
m smallest costs: [4, 5], sum = 9 > 8, so bit 0 is not set
Final answer: a = 6

```
Runtime: 51 ms, Beats 99.06%
Memory: 54.85 MB, Beats 94.76%
```
```c++
class Solution {
public:
    int maximumAND(vector<int>& nums, int k, int m) {
        long long a = 0;
        int n = nums.size();
        vector<long long> c(n);

        for (int i = 30; i >= 0; --i) {
            long long t = a | (1LL << i);
            for (int j = 0; j < n; ++j) {
                long long v = nums[j], r = t & ~v;
                if (!r) c[j] = 0;
                else {
                    long long h = 1LL << (63 - __builtin_clzll(r));
                    c[j] = ((v & ~(h * 2 - 1)) | h | (t & (h - 1))) - v;
                }
            }
            if (m < n) nth_element(c.begin(), c.begin() + m, c.end());
            long long s = 0;
            for (int j = 0; j < m; ++j) s += c[j];
            if (s <= k) a = t;
        }
        return a;
    }
};
```
